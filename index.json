[{"content":"前言 嘿，大家好！我一直觉得拥有一个个人博客是件很酷的事情。它不仅是一个记录学习心得和分享技术经验的地方，更是一个展示自我的平台。在这篇文章中，我想和大家分享一下我在博客迁移过程中的心路历程。从最初的 Hexo 到现在的 Hugo，中间我还尝试了 Typecho、VitePress、WordPress 和 Halo。每一次迁移都让我对博客系统有了更深的理解。\n博客迁移历程 Hexo 初体验 最开始，我选择了 Hexo。想想当时，我刚刚接触编程，对很多编程的基础知识都还不是很熟悉，而又想要拥有一个记录自己学习心得和分享技术经验的地方；基于这个想法，我选择了 Hexo。它是一个轻量级的静态博客系统，使用 Markdown 语法编写文章，主题和插件也很丰富。更重要的是，它可以基于 Github Pages 免费部署，这对于我这个穷学生来说，这无疑是一个巨大的诱惑。\n然而，随着大陆对 Github 的访问越来越不稳定，以及对 Vercel 的访问限制，我不得不经常折腾去更换部署平台，套 CDN 加速，这让我感觉很麻烦。我开始思考，能不能拥有一个自己的服务器，然后自己部署博客呢？但随着我的文章越来越多，Hexo 的生成速度越来越慢，网站的访问速度动辄就要好几秒钟，这让我感觉很糟糕，于是我开始寻找其他博客系统。\nTypecho 的简约之美 接下来，我转向了 Typecho。它的优点是轻量级，对服务器要求低，而且是 PHP 驱动的，部署起来也很简单。界面简洁，专注写作，真的是很不错。不过，Typecho 的插件和主题市场相对较少，不支持多种类型的主题和插件，对于一些特殊需求根本无法满足。而且一旦遇到了问题，Typecho 的社区支持相对较少，这让我感觉很糟糕。\nWordPress 的全能之选 随着学习以及工作的压力，我越来越不想在博客上花费太多时间，希望博客系统能够尽可能的简单，可以一键式部署，这样我就可以把更多的精力放在写作以及工作、学习上。WordPress 无疑是最成熟的博客系统了。功能强大，插件丰富，主题样式多样，社区支持也很完善。用了一段时间后，我发现在模板方面，WordPress 丰富的模板库几乎全部都是以英语为主的，这导致了在中国大陆使用 WordPress 时，英文模板默认使用的谷歌字体成了站点加载速度的短板。即使有了 GoogleFonts 插件也无济于事，异步加载导致的字体跳变极其的突兀且影响观感。最后一点则是 WordPress 在资源占用方面并不算友好，尤其是以图片为主题的站点，长期使用对于内存是一个考验。综上，在考虑优劣后，我决定去换一个平台继续写作。\nVitePress 的现代化尝试 作为一个前端开发者，VitePress 的现代化构建方案让我很心动。它基于 Vue 3 和 Vite，开发体验非常好，构建速度也很快。不过，它更适合做技术文档，而不是个人博客，所以我又开始寻找新的选择。\nHalo 的新生力量 选择了很久后，最终定下了 HALO 作为新的博客架构。就决定是你了——Halo！\n了解到 Halo 是从 1panel 的应用商店中发现的，索性去官网了解了一番，又从 V2EX 上看到了 Halo 官方征集用户需求的帖子，感觉官方很会听取用户意见和建议，相关的问题也反应很迅速。再加上 Halo 设计的调性我十分中意，索性直接下载安装，直接把 WordPress 的数据迁入了 Halo。\n在使用 Halo 这几年里，我感受到了 Halo 的强大。从一开始使用的 Butterfly 主题，到 Hao 主题，再到后面追求的 Chirpy 主题，我也成为了 Halo Chirpy 主题的代码贡献者。Halo 无论在部署的便捷性，还是社区的交流，Halo 都给了我很大的帮助。而且从 Halo 1.x 到 2.x 的更新，Halo 的性能得到了很大的提升，插件系统的不断完善以及 Halo 的应用生态的逐渐丰富，让我可以只写内容，其他的事情交给 Halo。甚至于像平台收录，SEO 优化，CDN 加速，这些事情都可以交给 Halo 去处理。\n我一直想着，如果不出意外，我应该会一直使用 Halo 作为我的博客架构，直到我不再需要博客。\n但自从我更换了我的服务器厂商，2H2G 的内存，让我在跑 Halo 时，内存占用直接飙到 100% 并且直接宕机直到服务器自动关闭我的 Halo 进程，这让我感觉很糟糕（同样是 2H2G 的内存，阿里/腾讯/华为的云服务器，都可以正常运行；但是！京东云\u0026mdash;）\n所以，我不得不开始寻找新的博客系统。\nHugo 经过多次迁移，我最终选择了 Hugo。为什么呢？因为它有以下几个优点：\n极致的速度：Hugo 是用 Go 语言编写的，构建速度快得惊人。 简单部署：它是静态站点，不需要数据库，部署起来非常简单。 维护方便：使用 Markdown 写作，版本控制也很方便。 高度定制：支持自定义主题和功能，满足我的各种需求。 安全可靠：静态网站天然安全，不用担心被攻击。 而对于传统静态博客的部署问题，我也可以使用 Github Actions 来实现自动化部署。\nHugo 的这些优点让我感到非常满意，尤其是在我需要一个快速、稳定且易于维护的博客系统时。它让我可以专注于内容创作，而不必担心技术上的琐事。\n","permalink":"https://waite.wang/posts/blog/first-post-in-hugo/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e嘿，大家好！我一直觉得拥有一个个人博客是件很酷的事情。它不仅是一个记录学习心得和分享技术经验的地方，更是一个展示自我的平台。在这篇文章中，我想和大家分享一下我在博客迁移过程中的心路历程。从最初的 Hexo 到现在的 Hugo，中间我还尝试了 Typecho、VitePress、WordPress 和 Halo。每一次迁移都让我对博客系统有了更深的理解。\u003c/p\u003e","title":"博客迁移小记"},{"content":" Devbox 地址：https://cloud.sealos.run/?uid=Kt1gH3_BTa\nCursor 地址: https://www.cursor.com/settings\n创建数据库和初始项目 我们这里创建一个 MongoDB 数据库\n创建完之后在 DevBox 创建一个 NodeJS + Express 的项目,注意创建在 3000 端口\n选择用 Cursor 打开，这里会提示安装插件，安装即可\n打开后 Ctrl + L 打开 AI 创作窗口，选择 Composer 输入提示词创建项目。\n请为我开发一个基于 Node.js 和Express 框架的 Todo List 后端项目。项目需要实现以下四个 RESTful API 接口： 1. 查询所有待办事项 - 接口名: GET /api/get-todo - 功能: 从数据库的\u0026#39;list\u0026#39;集合中查询并返回所有待办事项 - 参数: 无 - 返回: 包含所有待办事项的数组 2. 添加新的待办事项 - 接口名: POST /api/add-todo - 功能: 向\u0026#39;list\u0026#39;集合中添加新的待办事项 - 参数: { \u0026#34;value\u0026#34;: string, // 待办事项的具体内容 \u0026#34;isCompleted\u0026#34;: boolean // 是否完成，默认为 false } - 返回: 新添加的待办事项对象，包含自动生成的唯一 id 3. 更新待办事项状态 - 接口名: POST /api/update-todo/ - 功能: 根据 id 更新指定待办事项的完成状态（将 isCompleted 值取反） - 参数: id - 返回: 更新后的待办事项对象 4. 删除待办事项 - 接口名: POST /api/del-todo/ - 功能: 根据 id 删除指定的待办事项 - 参数: id - 返回: 删除操作的结果状态 技术要求： 1. 使用 Express 框架构建 API 2. 使用 MongoDB 作为数据库，通过 Mongoose 进行数据操作 3. 实现适当的错误处理和输入验证 4. 使用异步/等待（async/await）语法处理异步操作 5. 遵循 RESTful API 设计原则 6. 添加基本的日志记录功能 ### 这里数据库连接方式要填写！！！ 以下是数据库连接方式： 这里 AI 会自动帮我们创建项目结构以及生成相应代码\n在终端运行 node app.js 这里可能会报错，如果看不懂报错直接复制丢给 AI 即可， 这里提示我们安装依赖包，按要求安装\n这里我们可以看到运行成功了\n在 DevBox 打开后端项目详情，看到公网地址，我们可以根据这个域名访问到我们的后端项目\n为了测试接口 我们可以让 Cursor 帮我们生成测试用例\n可以看到接口正常运行了\n创建 Web 端 创建一个 Vue 项目，并且更改端口为 5173（不要为3000或者其他常用端口即可） 用 Cursor 打开项目，输入提示词 请为我开发一个基于 Vue 3 的Todo List 应用。要求如下： 1. 功能需求： - 添加新的待办事项 - 标记待办事项为完成/未完成 - 删除待办事项 - 统计待办事项完成度 - 过滤显示（全部/已完成/未完成） 2. UI/UX 设计要求： - 全屏响应式设计，适配不同设备 - 拥有亮色模式和夜间模式 - 现代化、简洁的界面风格 - 丰富的色彩运用，但保持整体和谐 - 流畅的交互动画，提升用户体验 - 在按钮和需要的地方添加上图标 - 参考灵感：结合苹果官网的设计美学 要求： 1. 直接以当前目录作为项目根目。注意 此目录已经初始化完了vue3项目结构 直接修改即可 2. 如果需要执行命令，请暂停创建文件，让我先执行命令 3. 请你根据我的需要，一步一步思考，给我开发这个项目。特别是UI部分 一定要足够美观和现代化 后端接口如下： https://wpifxnmfmpef.sealoshzh.site/api/ API 接口： 1. 查询所有待办事项 - 接口名: GET /api/get-todo - 功能: 从数据库的\u0026#39;list\u0026#39;集合中查询并返回所有待办事项 - 参数: 无 - 返回: 包含所有待办事项的数组 2. 添加新的待办事项 - 接口名: POST /api/add-todo - 功能: 向\u0026#39;list\u0026#39;集合中添加新的待办事项 - 参数: { \u0026#34;value\u0026#34;: string, // 待办事项的具体内容 \u0026#34;isCompleted\u0026#34;: boolean // 是否完成，默认为 false } - 返回: 新添加的待办事项对象，包含自动生成的唯一 id 3. 更新待办事项状态 - 接口名: POST /api/update-todo/ - 功能: 根据 id 更新指定待办事项的完成状态（将 isCompleted 值取反） - 参数: id - 返回: 更新后的待办事项对象 4. 删除待办事项 - 接口名: POST /api/del-todo/ - 功能: 根据 id 删除指定的待办事项 - 参数: id - 返回: 删除操作的结果状态 按提示安装\n安装后输入继续，将会继续帮我们创建项目，创建成功使用 npm run dev 启动项目\n可以看到項目正常启动，并且功能正常，如果想要更改可以继续精华提示词\n生成的代码 https://github.com/Waite0603/todolist-cursor-nodeApi\nhttps://github.com/Waite0603/todolist-cursor-web\n","permalink":"https://waite.wang/posts/project/use-cursor-and-devbox-to-create-todelis-web/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDevbox 地址：https://cloud.sealos.run/?uid=Kt1gH3_BTa\u003c/p\u003e\n\u003cp\u003eCursor 地址: \u003ca href=\"https://www.cursor.com/settings\"\u003ehttps://www.cursor.com/settings\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"创建数据库和初始项目\"\u003e创建数据库和初始项目\u003c/h2\u003e\n\u003cp\u003e我们这里创建一个 MongoDB 数据库\u003c/p\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202412272051422.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202412272051422.png\" alt=\"image-20241227205105497\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cp\u003e创建完之后在 DevBox 创建一个 NodeJS + Express 的项目,注意创建在 3000 端口\u003c/p\u003e","title":"使用Cursor+DevBox 从零创建一个 TodeList 网页应用"},{"content":"HTTP [HTTP ](#http) 一 、基础概念\n请求和响应报文 URL 二、HTTP 方法\nGET HEAD POST PUT PATCH DELETE OPTIONS CONNECT TRACE 三、HTTP 状态码\n1XX 信息 2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务器错误 四、HTTP 首部\n通用首部字段 请求首部字段 响应首部字段 实体首部字段 五、具体应用\n连接管理 Cookie 缓存 内容协商 内容编码 范围请求 分块传输编码 多部分对象集合 虚拟主机 通信数据转发 六、HTTPS\n加密 认证 完整性保护 HTTPS 的缺点 七、HTTP/2.0\nHTTP/1.x 缺陷 二进制分帧层 服务端推送 首部压缩 八、HTTP/1.1 新特性\n九、GET 和 POST 比较\n作用 参数 安全 幂等性 可缓存 XMLHttpRequest 参考资料\n一 、基础概念 请求和响应报文 客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。\n请求报文结构：\n第一行是包含了请求方法、URL、协议版本； 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。 一个空行用来分隔首部和内容主体 Body 最后是请求的内容主体 GET http://www.example.com/ HTTP/1.1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cache-Control: max-age=0 If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT If-None-Match: \u0026#34;3147526947+gzip\u0026#34; Proxy-Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 xxx param1=1\u0026amp;param2=2 响应报文结构：\n第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了 接下来多行也是首部内容 一个空行分隔首部和内容主体 最后是响应的内容主体 HTTP/1.1 200 OK Age: 529651 Cache-Control: max-age=604800 Connection: keep-alive Content-Encoding: gzip Content-Length: 648 Content-Type: text/html; charset=UTF-8 Date: Mon, 02 Nov 2020 17:53:39 GMT Etag: \u0026#34;3147526947+ident+gzip\u0026#34; Expires: Mon, 09 Nov 2020 17:53:39 GMT Keep-Alive: timeout=4 Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT Proxy-Connection: keep-alive Server: ECS (sjc/16DF) Vary: Accept-Encoding X-Cache: HIT \u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Example Domain\u0026lt;/title\u0026gt; // 省略... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; URL HTTP 使用 URL（ U niform Resource Locator，统一资源定位符）来定位资源，它是 URI（Uniform Resource Identifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。\nwikipedia：统一资源标志符 wikipedia: URL rfc2616：3.2.2 http URL What is the difference between a URI, a URL and a URN? 二、HTTP 方法 客户端发送的 请求报文 第一行为请求行，包含了方法字段。\nGET 获取资源\n当前网络请求中，绝大部分使用的是 GET 方法。\nHEAD 获取报文首部\n和 GET 方法类似，但是不返回报文实体主体部分。\n主要用于确认 URL 的有效性以及资源更新的日期时间等。\nPOST 传输实体主体\nPOST 主要用来传输数据，而 GET 主要用来获取资源。\n更多 POST 与 GET 的比较请见第九章。\nPUT 上传文件\n由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。\nPUT /new.html HTTP/1.1 Host: example.com Content-type: text/html Content-length: 16 \u0026lt;p\u0026gt;New File\u0026lt;/p\u0026gt; PATCH 对资源进行部分修改\nPUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。\nPATCH /file.txt HTTP/1.1 Host: www.example.com Content-Type: application/example If-Match: \u0026#34;e0023aa4e\u0026#34; Content-Length: 100 [description of changes] DELETE 删除文件\n与 PUT 功能相反，并且同样不带验证机制。\nDELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法\n查询指定的 URL 能够支持的方法。\n会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。\nCONNECT 要求在与代理服务器通信时建立隧道\n使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\nCONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径\n服务器会将通信路径返回给客户端。\n发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。\n通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。\nrfc2616：9 Method Definitions 三、HTTP 状态码 服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。\n状态码 类别 含义 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、HTTP 首部 有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。\n各种首部字段及其含义如下（不需要全记，仅供查阅）：\n通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 五、具体应用 连接管理 1. 短连接与长连接 当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。\n长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。\n从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2. 流水线 默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。\n流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。\nCookie HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。\nCookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。\nCookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。\n1. 用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 2. 创建过程 服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。\nHTTP/1.0 200 OK Content-type: text/html Set-Cookie: yummy_cookie=choco Set-Cookie: tasty_cookie=strawberry [page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。\nGET /sample_page.html HTTP/1.1 Host: www.example.org Cookie: yummy_cookie=choco; tasty_cookie=strawberry 3. 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 4. 作用域 Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。\nPath 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (\u0026quot;/\u0026quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：\n/docs /docs/Web/ /docs/Web/HTTP 5. JavaScript 浏览器通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。\ndocument.cookie = \u0026#34;yummy_cookie=choco\u0026#34;; document.cookie = \u0026#34;tasty_cookie=strawberry\u0026#34;; console.log(document.cookie); 6. HttpOnly 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。\nSet-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 7. Secure 标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。\n8. Session 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。\nSession 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。\n使用 Session 维护用户登录状态的过程如下：\n用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。\n9. 浏览器禁用 Cookie 此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。\n10. Cookie 与 Session 选择 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 缓存 1. 优点 缓解服务器压力； 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 2. 实现方法 让代理服务器进行缓存； 让客户端浏览器进行缓存。 3. Cache-Control HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。\n3.1 禁止进行缓存\nno-store 指令规定不能对请求或响应的任何一部分进行缓存。\nCache-Control: no-store 3.2 强制确认缓存\nno-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。\nCache-Control: no-cache 3.3 私有缓存和公共缓存\nprivate 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。\nCache-Control: private public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。\nCache-Control: public 3.4 缓存过期机制\nmax-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。\nmax-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。\nCache-Control: max-age=31536000 Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。\nExpires: Wed, 04 Jul 2012 08:26:05 GMT 在 HTTP/1.1 中，会优先处理 max-age 指令； 在 HTTP/1.0 中，max-age 指令会被忽略掉。 4. 缓存验证 需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。\nETag: \u0026#34;82e22293907ce725faf67773957acd12\u0026#34; 可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。\nIf-None-Match: \u0026#34;82e22293907ce725faf67773957acd12\u0026#34; Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。\nLast-Modified: Wed, 21 Oct 2015 07:28:00 GMT If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT 内容协商 通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。\n1. 类型 1.1 服务端驱动型\n客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。\n它存在以下问题：\n服务器很难知道客户端浏览器的全部信息； 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）； 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。 1.2 代理驱动型\n服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。\n2. Vary Vary: Accept-Language 在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。\n例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 Vary: Accept-Language 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。\n内容编码 内容编码将实体主体进行压缩，从而减少传输的数据量。\n常用的内容编码有：gzip、compress、deflate、identity。\n浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。\n范围请求 如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。\n1. Range 在请求报文中添加 Range 首部字段指定请求的范围。\nGET /z4d4kWk.jpg HTTP/1.1 Host: i.imgur.com Range: bytes=0-1023 请求成功的话服务器返回的响应包含 206 Partial Content 状态码。\nHTTP/1.1 206 Partial Content Content-Range: bytes 0-1023/146515 Content-Length: 1024 ... (binary content) 2. Accept-Ranges 响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。\nAccept-Ranges: bytes 3. 响应状态码 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。 分块传输编码 Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。\n多部分对象集合 一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。\n例如，上传多个表单时可以使用如下方式：\nContent-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\u0026#34;submit-name\u0026#34; Larry --AaB03x Content-Disposition: form-data; name=\u0026#34;files\u0026#34;; filename=\u0026#34;file1.txt\u0026#34; Content-Type: text/plain ... contents of file1.txt ... --AaB03x-- 虚拟主机 HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。\n通信数据转发 1. 代理 代理服务器接受客户端的请求，并且转发给其它服务器。\n使用代理的主要目的是：\n缓存 负载均衡 网络访问控制 访问日志记录 代理服务器分为正向代理和反向代理两种：\n用户察觉得到正向代理的存在。 而反向代理一般位于内部网络中，用户察觉不到。 2. 网关 与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。\n3. 隧道 使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。\n六、HTTPS HTTP 有以下安全性问题：\n使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。\n通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。\n加密 1. 对称密钥加密 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。\n优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 2.非对称密钥加密 非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。\n公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。\n非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。\n优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 3. HTTPS 采用的加密方式 上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：\n使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性; 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key） 认证 通过使用 证书 来对通信方进行认证。\n数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。\n服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。\n进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。\n完整性保护 SSL 提供报文摘要功能来进行完整性保护。\nHTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。\nHTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。\nHTTPS 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 七、HTTP/2.0 HTTP/1.x 缺陷 HTTP/1.x 实现简单是以牺牲性能为代价的：\n客户端需要使用多个连接才能实现并发和缩短延迟； 不会压缩请求和响应首部，从而导致不必要的网络流量； 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 二进制分帧层 HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。\n在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。\n一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 服务端推送 HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。\n首部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。\nHTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。\n不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。\n八、HTTP/1.1 新特性 详细内容请见上文\n默认是长连接 支持流水线 支持同时打开多个 TCP 连接 支持虚拟主机 新增状态码 100 支持分块传输编码 新增缓存处理指令 max-age 九、GET 和 POST 比较 作用 GET 用于获取资源，而 POST 用于传输实体主体。\n参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。\n因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。\nGET /test/demo_form.asp?name1=value1\u0026amp;name2=value2 HTTP/1.1 POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1\u0026amp;name2=value2 安全 安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。\nGET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。\n安全的方法除了 GET 之外还有：HEAD、OPTIONS。\n不安全的方法除了 POST 之外还有 PUT、DELETE。\n幂等性 幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。\n所有的安全方法也都是幂等的。\n在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。\nGET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：\nGET /pageX HTTP/1.1 GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：\nPOST /add_row HTTP/1.1 -\u0026gt; Adds a 1nd row POST /add_row HTTP/1.1 -\u0026gt; Adds a 2nd row POST /add_row HTTP/1.1 -\u0026gt; Adds a 3rd row DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：\nDELETE /idX/delete HTTP/1.1 -\u0026gt; Returns 200 if idX exists DELETE /idX/delete HTTP/1.1 -\u0026gt; Returns 404 as it just got deleted DELETE /idX/delete HTTP/1.1 -\u0026gt; Returns 404 可缓存 如果要对响应进行缓存，需要满足以下条件：\n请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest 为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：\nXMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。\n在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 参考资料 上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014. MDN : HTTP HTTP/2 简介 htmlspecialchars Difference between file URI and URL in java How to Fix SQL Injection Using Java PreparedStatement \u0026amp; CallableStatement 浅谈 HTTP 中 Get 与 Post 的区别 Are http:// and www really necessary? HTTP (HyperText Transfer Protocol) Web-VPN: Secure Proxies with SPDY \u0026amp; Chrome File:HTTP persistent connection.svg Proxy server What Is This HTTPS/SSL Thing And Why Should You Care? What is SSL Offloading? Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption An Introduction to Mutual SSL Authentication The Difference Between URLs and URIs Cookie 与 Session 的区别 COOKIE 和 SESSION 有什么区别 Cookie/Session 的机制与安全 HTTPS 证书原理 What is the difference between a URI, a URL and a URN? XMLHttpRequest XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST? Symmetric vs. Asymmetric Encryption – What are differences? Web 性能优化与 HTTP/2 HTTP/2 简介 ","permalink":"https://waite.wang/posts/web/http-basic/","summary":"\u003ch1 id=\"http\"\u003eHTTP\u003c/h1\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003cul\u003e\n\u003cli\u003e[HTTP\u003c/li\u003e\n\u003cli\u003e](#http)\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#%E4%B8%80-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\"\u003e一 、基础概念\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87\"\u003e请求和响应报文\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#url\"\u003eURL\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#%E4%BA%8Chttp-%E6%96%B9%E6%B3%95\"\u003e二、HTTP 方法\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#get\"\u003eGET\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#head\"\u003eHEAD\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#post\"\u003ePOST\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#put\"\u003ePUT\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#patch\"\u003ePATCH\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#delete\"\u003eDELETE\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#options\"\u003eOPTIONS\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#connect\"\u003eCONNECT\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#trace\"\u003eTRACE\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#%E4%B8%89http-%E7%8A%B6%E6%80%81%E7%A0%81\"\u003e三、HTTP 状态码\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#1xx-%E4%BF%A1%E6%81%AF\"\u003e1XX 信息\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#2xx-%E6%88%90%E5%8A%9F\"\u003e2XX 成功\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#3xx-%E9%87%8D%E5%AE%9A%E5%90%91\"\u003e3XX 重定向\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF\"\u003e4XX 客户端错误\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF\"\u003e5XX 服务器错误\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#%E5%9B%9Bhttp-%E9%A6%96%E9%83%A8\"\u003e四、HTTP 首部\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"\u003e通用首部字段\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"\u003e请求首部字段\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"\u003e响应首部字段\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5\"\u003e实体首部字段\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"#%E4%BA%94%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8\"\u003e五、具体应用\u003c/a\u003e\u003c/p\u003e","title":"Http 基础"},{"content":"Vuepress 或部分静态文档自动同步服务器 使用 Github action 加服务器 git commit hash 匹配\n本文以 Vuepress 为例子, 其他同理\n请确保 服务器 安装 git 环境, 本文不再赘述\nGithub Action 原理: 通过 Github Action 工作流把代码编译并且部署到 gh_pages 分支\n本文示例使用 npm 部署, yarn 在 yaml 中更改配置\n创建 .github/workflows/文件名.yml\n# 工作流的名称，如果省略，则使用当前文件名 name: Auto Deploy # 从工作流生成的工作流运行的名称，如果省略，则使用提交时的commit信息 run-name: Deploy by @${{ github.actor }} # 触发部署的条件 on: # 每当 push 到 master 分支时触发部署 push: branches: - main # 当前流程要执行的任务，可以是多个。[my_first_job]就是一个任务 jobs: my_first_job: # 任务的名称，不设置则默认my_first_job name: build-and-deploy # 运行所需要的虚拟机环境 runs-on: ubuntu-latest # 每个任务下的运行步骤，短横杠 - 表示一个步骤，从上至下依次执行。 steps: # clone 该仓库的源码到工作流中 - name: Clone Code uses: actions/checkout@v3 with: # \u0026#34;最近更新时间\u0026#34;等 git 日志相关信息，需要拉取全部提交记录 fetch-depth: 0 # 安装 Node 环境 - name: Setup Node.js uses: actions/setup-node@v3 with: # 选择要使用的 node 版本 node-version: \u0026#39;16\u0026#39; # 如果你的依赖是使用npm的，用这种 # 缓存 npm node_modules - name: Cache dependencies uses: actions/cache@v3 with: path: ~/.npm key: ${{ runner.os }}-npm-cache-${{ hashFiles(\u0026#39;**/package-lock.json\u0026#39;) }} restore-keys: | ${{ runner.os }}-npm-cache- # 安装依赖 npm - name: Install dependencies # 如果没有命中缓存才执行 npm install if: steps.cache-deps.outputs.cache-hit != \u0026#39;true\u0026#39; run: npm install # 如果你的依赖是使用yarn的，用这种 # 缓存 yarn node_modules # - name: Cache dependencies # uses: actions/cache@v3 # id: yarn-cache # with: # path: | # **/node_modules # key: ${{ runner.os }}-yarn-${{ hashFiles(\u0026#39;**/yarn.lock\u0026#39;) }} # restore-keys: | # ${{ runner.os }}-yarn- # 安装依赖 yarn # - name: Install dependencies # # 如果没有命中缓存才执行 npm install # if: steps.npm-cache.outputs.cache-hit != \u0026#39;true\u0026#39; # run: yarn --frozen-lockfile # 运行构建脚本 - name: Run Build Script run: npm run build # 部署到 GitHub Pages - name: Deploy to GitHub Pages # 此actions的官方文档 https://github.com/JamesIves/github-pages-deploy-action uses: JamesIves/github-pages-deploy-action@v4 with: # 要部署的文件夹，必填 FOLDER: src/.vuepress/dist # 希望部署的分支，默认gh-pages BRANCH: gh-pages # # 仓库范围的访问令牌，可以将个人令牌的值存储在GitHub Secrets中 # # 默认情况是不需要填的，如果您需要更多权限，例如部署到另一个存储库才需要填写 # # ACCESS_TOKEN 对应GitHub Secrets中设置的字段，不要照搬 # TOKEN: ${{ secrets.ACCESS_TOKEN }} # # 部署到GitHub的不同仓库 \u0026lt;用户名\u0026gt;/\u0026lt;仓库名\u0026gt; # # 此选项必须配置了TOKEN才能正常执行 # REPOSITORY-NAME: leoleor/leo2 注意 !!!!!! 需要开启以下设置, 不然会报错 -\u0026gt; The deploy step encountered an error: The process '/usr/bin/git' failed with exit code 128 ❌\n服务器设置 在你的网页目录 git clone, 克隆指定分支 \u0026lt;!-- The command to use is --\u0026gt; git clone --branch \u0026lt;branchname\u0026gt; --single-branch \u0026lt;remote-repo-url\u0026gt; \u0026lt;!-- From your terminal run --\u0026gt; git clone --branch gh-pages --single-branch https://github.com/XXX/xxx.git 编写 sh 脚本文件 cd / cd {{your site folder}} git pull 设置定时脚本执行, 或者通过配置服务器 crontab 来实现自动更新 这是一个定时任务命令，每隔10分钟会执行一次 /root/update-blog.sh 脚本。脚本的输出会被重定向到 /www/logs/update-blog.log 文件中，2\u0026gt;\u0026amp;1 则表示将错误输出也重定向到同一个日志文件中。\ncrontab -e */10 * * * * /bin/bash /root/update-blog.sh \u0026gt;\u0026gt; /www/logs/update-blog.log 2\u0026gt;\u0026amp;1 也可以在本地编译, 例如 hugo, 可以 每个 commit 都有其对应的 hash 值, 可以定时 git pull 从仓库拉取内容, 并对比 pull 前后 commit 值的变化, 以判断是否存在更新. 如果存在更新, 则执行重新构建的流程. cd {{your site folder}} commit=$(cat .git/refs/heads/main) git pull new_commit=$(cat .git/refs/heads/main) if [[ \u0026#34;$new_commit\u0026#34; != \u0026#34;$commit\u0026#34; ]]; then # 改为你的网站构建流程, ps: rm -rf public/* -\u0026gt; ./hugo {{execute your site rebuild program}} fi echo \u0026#34;----------------------------------------------------------------------------\u0026#34; endDate=`date +\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;` echo \u0026#34;\u0026gt;\u0026gt; [$endDate] Successful\u0026#34; echo \u0026#34;----------------------------------------------------------------------------\u0026#34; 其他 如果你博客的 GitHub 仓库不是公开仓库, 那在执行 git pull 的时候可能需要输入用户名和密码, 无法实现自动化. 你需要在服务器项目路径内执行 git config credential.helper store, 然后手动 git pull 一次, 凭证将自动保存在服务器, 下次无需输入密码.\nCentOS 服务器 git clone下载加速（下载过慢或超时） 以下为本人实践之后, 在进行以下之前, 请先行检查代理/ 缓存大小/ 权限 等等问题, 以下方法可能仅仅适用于笔者, 不确保一定可以成功\n# 缓存 git config --global http.postBuffer 104857600 # 代理 git config --global --unset http.proxy git config --global --unset https.proxy 在 CentOS 服务器 上通过 git clone 下载项目，速度很慢或直接超时 [root@VM-0-11-centos home]# git clone https://github.com/dengzemiao/DZMLuckyDraw.git 正克隆到 \u0026#39;DZMLuckyDraw\u0026#39;... error: RPC failed; result=35, HTTP code = 0 fatal: The remote end hung up unexpectedly git clone 特别慢，是因为 github.global.ssl.fastly.net 域名被限制了，只要找到这个域名对应的 IP 地址，然后在 hosts 文件中加上 ip–\u0026gt;域名 的映射，刷新 DNS 缓存便可。\nnslookup 命令获取 github IP 地址\n如果没有安装，则需要安装一下 yum -y install bind-utils 获取 IP 地址 nslookup github.global.ssl.fastly.net nslookup github.com 修改 hosts 文件\n编辑 hosts sudo vim /etc/hosts 填入内容，保存 格式： x.x.x.x http://global-ssl.fastly.net x.x.x.x http://github.com 例如拿上面得到的IP地址： 69.171.229.73 http://global-ssl.fastly.net 13.250.177.223 http://github.com nscd 命令更新 DNS 缓存\n如果没有安装，则需要安装一下 yum install -y nscd 更新 DNS 缓存 $ nscd -i hosts 然后再次执行 git clone，则会进入下载。 ","permalink":"https://waite.wang/posts/tools/static-document-compilation-automatic-synchronization-server/","summary":"\u003ch1 id=\"vuepress-或部分静态文档自动同步服务器\"\u003eVuepress 或部分静态文档自动同步服务器\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e使用 Github action 加服务器 git commit hash 匹配\u003c/p\u003e\n\u003cp\u003e本文以 Vuepress 为例子, 其他同理\u003c/p\u003e\n\u003cp\u003e请确保 服务器 安装 git 环境, 本文不再赘述\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"github-action\"\u003eGithub Action\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e原理: 通过 Github Action 工作流把代码编译并且部署到 gh_pages 分支\u003c/p\u003e","title":"静态文档 Github 自动同步服务器"},{"content":"auth模块的介绍 1、导包\nfrom django.contrib import auth 2、默认使用auth_user表来存储用户数据\n# 默认用户表是位置 from django.contrib.auth.models import User mysql\u0026gt; show tables; +----------------------------+ | Tables_in_django_rest01 | +----------------------------+ | auth_group | | auth_group_permissions | | auth_permission | | auth_user | | auth_user_groups | | auth_user_user_permissions | | django_admin_log | | django_content_type | | django_migrations | | django_session | +----------------------------+ 10 rows in set (0.00 sec) auth_group: 存储用户组信息。每个用户组可以有多个权限。 auth_group_permissions: 存储用户组和权限的关联关系。一个用户组可以有多个权限。 auth_permission: 存储系统中定义的所有权限。权限通常与特定的模型和操作相关联。 auth_user: 存储用户账户信息，如用户名、密码、电子邮件等。 auth_user_groups: 存储用户和用户组的关联关系。一个用户可以属于多个用户组。 auth_user_user_permissions: 存储用户特定的权限，这些权限不会通过用户组继承。 django_admin_log: 存储管理站点的操作日志，如添加、更改或删除记录。 django_content_type: 存储Django中所有模型的元数据，包括app_label和model字段，用于确定对象类型。 django_migrations: 存储关于应用的迁移历史信息，包括迁移的名称和应用时间。 django_session: 存储会话数据，用于支持Django的会话框架。 mysql\u0026gt; desc auth_user; +--------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | password | varchar(128) | NO | | NULL | | | last_login | datetime(6) | YES | | NULL | | | is_superuser | tinyint(1) | NO | | NULL | | | username | varchar(150) | NO | UNI | NULL | | | first_name | varchar(30) | NO | | NULL | | | last_name | varchar(150) | NO | | NULL | | | email | varchar(254) | NO | | NULL | | | is_staff | tinyint(1) | NO | | NULL | | | is_active | tinyint(1) | NO | | NULL | | | date_joined | datetime(6) | NO | | NULL | | +--------------+--------------+------+-----+---------+----------------+ 11 rows in set (0.01 sec) mysql\u0026gt; 常用方法 1、authenticate()用来校验用户名及密码\nfrom django.contrib.auth import authenticate, login, logout # 如果校验成功就返回当前用户,否则就返回None user = authenticate(username=\u0026#39;username\u0026#39;, password=\u0026#39;password\u0026#39;) 2、login(HttpRequest, user)用户用户登录,使用这个登录方式会生成相关的session\n3、logout(request)退出操作,清除相关的session\n4、is_authenticated()用来判断当前请求是否通过认证\ndef my_view(request): if not request.user.is_authenticated(): return redirect(\u0026#39;%s?next=%s\u0026#39; % (settings.LOGIN_URL, request.path)) 5、login_requierd()必须登录的装饰器\nfrom django.contrib.auth.decorators import login_required @login_required def my_view(request): pass 若用户没有登录，则会跳转到django默认的 登录URL '/accounts/login/ ' 并传递当前访问url的绝对路径 (登陆成功后，会重定向到该路径)。如果需要自定义登录的URL，则需要在settings.py文件中通过LOGIN_URL进行修改。\nLOGIN_URL = \u0026#39;/login/\u0026#39; # 这里配置成你项目登录页面的路由 6、create_user()创建普通用户的\nfrom django.contrib.auth.models import User user = User.objects.create_user（username=\u0026#39;用户名\u0026#39;,password=\u0026#39;密码\u0026#39;,email=\u0026#39;邮箱\u0026#39;,...） 7、create_superuser()创建超级用户\n8、check_password(password)检查密码是否正确(用户登录)\nuser.check_password(\u0026#39;密码\u0026#39;) 9、set_password(password)设置密码(用于注册及修改密码)\n扩展auth_user表 默认你创建好了一个 app, 没有的话 python manage.py startapp web\n修改 web/models from django.db import models from django.contrib.auth.models import AbstractUser class UserProfileModel(AbstractUser): \u0026#34;\u0026#34;\u0026#34; 创建一个用户的模型 \u0026#34;\u0026#34;\u0026#34; SEX_CHOICES = [ (\u0026#39;male\u0026#39;, \u0026#39;男\u0026#39;), (\u0026#39;female\u0026#39;, \u0026#39;女\u0026#39;) ] phone = models.CharField(max_length=11, verbose_name=\u0026#39;手机号\u0026#39;, unique=True) birthday = models.DateField(verbose_name=\u0026#39;生日\u0026#39;, null=True, blank=True) sex = models.CharField(max_length=6, choices=SEX_CHOICES, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;性别\u0026#39;) # 头像 avatar = models.CharField(max_length=100, default=\u0026#39;default.jpg\u0026#39;, verbose_name=\u0026#39;头像\u0026#39;) address = models.CharField(max_length=100, default=\u0026#39;\u0026#39;, verbose_name=\u0026#39;地址\u0026#39;) class Meta(object): db_table = \u0026#39;user_profile\u0026#39; verbose_name = \u0026#39;用户信息\u0026#39; verbose_name_plural = verbose_name def __str__(self): # 定义模型对象的显示信息 return self.username 修改settings.py, 添加设置让django用 我们web下的modles.py中的user模型 # Custom user model AUTH_USER_MODEL = \u0026#39;web.UserProfileModel\u0026#39; 迁移模型到数据库 $ python manage.py makemigrations $ python manage.py migrate 创建超级用户，登录后台 python manage.py createsuperuser Username: Email address: Password: Password (again): Superuser created successfully. 开启服务后进去一看，用户管理那一栏不见了\n在 web/admin/py 中注册一下就好了 from django.contrib import admin from web.models import UserProfileModel # Register your models here. admin.site.register(UserProfileModel) ","permalink":"https://waite.wang/posts/python/django-comes-with-auth-database/","summary":"\u003ch2 id=\"auth模块的介绍\"\u003eauth模块的介绍\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e1、导包\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-py\" data-lang=\"py\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003edjango.contrib\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eauth\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e2、默认使用\u003ccode\u003eauth_user\u003c/code\u003e表来存储用户数据\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-py\" data-lang=\"py\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 默认用户表是位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003edjango.contrib.auth.models\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eUser\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emysql\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eshow\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etables\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"c1\"\u003e----------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eTables_in_django_rest01\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"c1\"\u003e----------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_group\u003c/span\u003e\u003cspan class=\"w\"\u003e                 \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_group_permissions\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_permission\u003c/span\u003e\u003cspan class=\"w\"\u003e            \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user\u003c/span\u003e\u003cspan class=\"w\"\u003e                  \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user_groups\u003c/span\u003e\u003cspan class=\"w\"\u003e           \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user_user_permissions\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edjango_admin_log\u003c/span\u003e\u003cspan class=\"w\"\u003e           \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edjango_content_type\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edjango_migrations\u003c/span\u003e\u003cspan class=\"w\"\u003e          \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edjango_session\u003c/span\u003e\u003cspan class=\"w\"\u003e             \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"c1\"\u003e----------------------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003erows\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ein\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e00\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eauth_group\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储用户组信息。每个用户组可以有多个权限。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eauth_group_permissions\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储用户组和权限的关联关系。一个用户组可以有多个权限。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eauth_permission\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储系统中定义的所有权限。权限通常与特定的模型和操作相关联。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储用户账户信息，如用户名、密码、电子邮件等。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user_groups\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储用户和用户组的关联关系。一个用户可以属于多个用户组。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user_user_permissions\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储用户特定的权限，这些权限不会通过用户组继承。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edjango_admin_log\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储管理站点的操作日志，如添加、更改或删除记录。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edjango_content_type\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储\u003c/span\u003e\u003cspan class=\"n\"\u003eDjango中所有模型的元数据\u003c/span\u003e\u003cspan class=\"err\"\u003e，包括\u003c/span\u003e\u003cspan class=\"n\"\u003eapp_label和model字段\u003c/span\u003e\u003cspan class=\"err\"\u003e，用于确定对象类型。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edjango_migrations\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储关于应用的迁移历史信息，包括迁移的名称和应用时间。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003edjango_session\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"err\"\u003e存储会话数据，用于支持\u003c/span\u003e\u003cspan class=\"n\"\u003eDjango的会话框架\u003c/span\u003e\u003cspan class=\"err\"\u003e。\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emysql\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003edesc\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauth_user\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"c1\"\u003e--------------+--------------+------+-----+---------+----------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eField\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eType\u003c/span\u003e\u003cspan class=\"w\"\u003e         \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNull\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eKey\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eDefault\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eExtra\u003c/span\u003e\u003cspan class=\"w\"\u003e          \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"c1\"\u003e--------------+--------------+------+-----+---------+----------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"w\"\u003e           \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e      \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ePRI\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eauto_increment\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epassword\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003evarchar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e128\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003elast_login\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatetime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eYES\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eis_superuser\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etinyint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eusername\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003evarchar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e150\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eUNI\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003efirst_name\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003evarchar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e30\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003elast_name\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003evarchar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e150\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eemail\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003evarchar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e254\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eis_staff\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etinyint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eis_active\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003etinyint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edate_joined\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003edatetime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNO\u003c/span\u003e\u003cspan class=\"w\"\u003e   \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e     \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eNULL\u003c/span\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e                \u003c/span\u003e\u003cspan class=\"o\"\u003e|\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"c1\"\u003e--------------+--------------+------+-----+---------+----------------+\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003erows\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003ein\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eset\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e01\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003emysql\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"常用方法\"\u003e常用方法\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e1、\u003ccode\u003eauthenticate()\u003c/code\u003e用来校验用户名及密码\u003c/p\u003e","title":"Django自带 Auth 数据库扩展字段"},{"content":" 可以参考 https://waite.wang/posts/web/vue-project-construction-specification/ 参考: https://blog.csdn.net/u011296285/article/details/136597099\n配置eslint代码检查 npm i eslint -D 初始化\nnpx eslint --init 选择配置(根据自己需求选择)\n? How would you like to use ESLint? To check syntax and find problems ? What type of modules does your project use? JavaScript modules (import/export) ? Which framework does your project use? Vue.js ? Does your project use TypeScript? Yes ? Where does your code run? None ? How would you like to define a style for your project? Use a popular style guide ? Which style guide do you want to follow? Airbnb ? What format do you want your config file to be in? JavaScript 修改.eslintrc.js\n// @see https://eslint.bootcss.com/docs/rules/ ​ module.exports = { env: { browser: true, es2021: true, node: true, }, globals: {}, /* 指定如何解析语法 */ parser: \u0026#39;vue-eslint-parser\u0026#39;, /** 优先级低于 parse 的语法解析配置 */ parserOptions: { ecmaVersion: \u0026#39;latest\u0026#39;, sourceType: \u0026#39;module\u0026#39;, parser: \u0026#39;@typescript-eslint/parser\u0026#39;, jsxPragma: \u0026#39;React\u0026#39;, ecmaFeatures: { jsx: true, }, }, /* 继承已有的规则 */ extends: [\u0026#39;eslint:recommended\u0026#39;, \u0026#39;plugin:vue/vue3-essential\u0026#39;, \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, \u0026#39;plugin:prettier/recommended\u0026#39;], plugins: [\u0026#39;vue\u0026#39;, \u0026#39;@typescript-eslint\u0026#39;], overrides: [ { files: [\u0026#39;*.ts\u0026#39;, \u0026#39;*.tsx\u0026#39;, \u0026#39;*.vue\u0026#39;], rules: { \u0026#39;no-undef\u0026#39;: 0, }, }, ], /* * \u0026#39;off\u0026#39; 或 0 ==\u0026gt; 关闭规则 * \u0026#39;warn\u0026#39; 或 1 ==\u0026gt; 打开的规则作为警告（不影响代码执行） * \u0026#39;error\u0026#39; 或 2 ==\u0026gt; 规则作为一个错误（代码不能执行，界面报错） */ rules: { // typeScript (https://typescript-eslint.io/rules) \u0026#39;@typescript-eslint/no-unused-vars\u0026#39;: 2, // 禁止定义未使用的变量 \u0026#39;@typescript-eslint/prefer-ts-expect-error\u0026#39;: 2, // 禁止使用 @ts-ignore \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: 0, // 禁止使用 any 类型 \u0026#39;@typescript-eslint/no-non-null-assertion\u0026#39;: 0, \u0026#39;@typescript-eslint/no-namespace\u0026#39;: 0, // 禁止使用自定义 TypeScript 模块和命名空间。 \u0026#39;@typescript-eslint/semi\u0026#39;: 0, \u0026#39;no-prototype-builtins\u0026#39;: 0, // 可以使用obj.hasOwnProperty() \u0026#39;@typescript-eslint/no-var-requires\u0026#39;: 0, // 不允许在import 中使用require \u0026#39;@typescript-eslint/no-empty-function\u0026#39;: 2, // 关闭空方法检查 // eslint-plugin-vue (https://eslint.vuejs.org/rules/) \u0026#39;vue/multi-word-component-names\u0026#39;: 0, // 要求组件名称始终为 “-” 链接的单词 \u0026#39;vue/script-setup-uses-vars\u0026#39;: 2, // 防止\u0026lt;script setup\u0026gt;使用的变量\u0026lt;template\u0026gt;被标记为未使用 \u0026#39;vue/no-mutating-props\u0026#39;: 0, // 不允许组件 prop的改变 \u0026#39;vue/no-v-html\u0026#39;: 0, // 禁止使用 v-html \u0026#39;vue/no-setup-props-destructure\u0026#39;: 0, // 禁止 props 解构传递给 setup \u0026#39;vue/no-v-model-argument\u0026#39;: 0, // 不允许添加要在 v-model 自定义组件中使用的参数 \u0026#39;vue/component-definition-name-casing\u0026#39;: [2, \u0026#39;PascalCase\u0026#39;], // 强制使用组件定义名称的特定大小写 PascalCase | kebab-case \u0026#39;vue/attribute-hyphenation\u0026#39;: [2, \u0026#39;always\u0026#39;, { ignore: [] }], // 对模板中的自定义组件强制实施属性命名样式 \u0026#39;vue/no-dupe-keys\u0026#39;: [2, { groups: [] }], // 不允许重复字段名称 \u0026#39;vue/no-dupe-v-else-if\u0026#39;: 2, // 不允许 / v-else-if 链中的 v-if 重复条件 \u0026#39;vue/no-duplicate-attributes\u0026#39;: 2, // 禁止属性重复 \u0026#39;vue/no-ref-as-operand\u0026#39;: 2, // 使用ref对象必须.value \u0026#39;vue/first-attribute-linebreak\u0026#39;: [ 2, { singleline: \u0026#39;ignore\u0026#39;, multiline: \u0026#39;below\u0026#39;, }, ], // 强制设置第一个属性的位置 ​ \u0026#39;@typescript-eslint/no-this-alias\u0026#39;: [ \u0026#39;warn\u0026#39;, { allowDestructuring: false, // Disallow `const { props, state } = this`; true by default allowedNames: [\u0026#39;_this\u0026#39;], // this的別名可以为_this }, ], // eslint（https://eslint.bootcss.com/docs/rules/） \u0026#39;no-unexpected-multiline\u0026#39;: 2, // 禁止空余的多行 \u0026#39;no-await-in-loop\u0026#39;: 2, // 该规则不允许在循环体中使用 await \u0026#39;no-dupe-else-if\u0026#39;: 2, // 禁止 if-else-if 链中的重复条件 \u0026#39;no-const-assign\u0026#39;: 2, // 禁止重新分配 const 变量 \u0026#39;no-dupe-keys\u0026#39;: 2, // 禁止对象字面量中的重复键 \u0026#39;no-multiple-empty-lines\u0026#39;: [\u0026#39;warn\u0026#39;, { max: 1 }], // 不允许多个空行 \u0026#39;no-unused-vars\u0026#39;: 2, // 禁止未使用的变量 \u0026#39;use-isnan\u0026#39;: 2, // 检查 NaN 时需要调用 isNaN() \u0026#39;valid-typeof\u0026#39;: 2, // 强制将 typeof 表达式与有效字符串进行比较 \u0026#39;no-var\u0026#39;: 2, // 要求使用 let 或 const 而不是 var \u0026#39;no-extra-semi\u0026#39;: 2, // 禁止不必要的分号 \u0026#39;no-multi-str\u0026#39;: 2, // 禁止多行字符串 \u0026#39;no-unused-labels\u0026#39;: 2, // 禁止未使用的标签 // 在打开数组括号之后和关闭数组括号之前强制换行 \u0026#39;array-bracket-newline\u0026#39;: [2, \u0026#39;consistent\u0026#39;], eqeqeq: [2, \u0026#39;smart\u0026#39;], // 必须使用全等 \u0026#39;arrow-spacing\u0026#39;: 2, // 在箭头函数中的箭头前后强制执行一致的间距 // 在函数调用的参数之间强制换行 \u0026#39;function-call-argument-newline\u0026#39;: [2, \u0026#39;consistent\u0026#39;], \u0026#39;no-undef\u0026#39;: 2, // 禁止使用未声明的变量，除非在 /*global */ 注释中提及 complexity: [2, 15], indent: [2, 4, { SwitchCase: 1 }], \u0026#39;valid-jsdoc\u0026#39;: 0, //jsdoc规则 \u0026#39;no-console\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? 2 : 0, \u0026#39;no-debugger\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? 2 : 0, \u0026#39;no-useless-escape\u0026#39;: 0, // 禁止不必要的转义字符 \u0026#39;@typescript-eslint/ban-types\u0026#39;: 0, // 允许使用function 声明函数 \u0026#39;prettier/prettier\u0026#39;: [ 2, { //在单独的箭头函数参数周围包括括号 always：(x) =\u0026gt; x \\ avoid：x =\u0026gt; x arrowParens: \u0026#39;always\u0026#39;, // 开始标签的右尖括号是否跟随在最后一行属性末尾，默认false bracketSameLine: false, // 对象字面量的括号之间打印空格 bracketSpacing: true, // 是否格式化一些文件中被嵌入的代码片段的风格(auto|off;默认auto) embeddedLanguageFormatting: \u0026#39;auto\u0026#39;, // 指定 HTML 文件的空格敏感度 (css|strict|ignore;默认css) htmlWhitespaceSensitivity: \u0026#39;ignore\u0026#39;, // 一行最多多少个字符 printWidth: 150, // 超出打印宽度 (always | never | preserve ) proseWrap: \u0026#39;preserve\u0026#39;, // 对象属性是否使用引号(as-needed | consistent | preserve; quoteProps: \u0026#39;as-needed\u0026#39;, // 指定要使用的解析器，不需要写文件开头的 @prettier requirePragma: false, // 不需要自动在文件开头插入 @prettier insertPragma: false, // 最后不需要引号 semi: false, // 使用单引号 (true:单引号;false:双引号) singleQuote: true, // 缩进空格数，默认2个空格 tabWidth: 4, // 多行时尽可能打印尾随逗号。 trailingComma: \u0026#39;es5\u0026#39;, // 使用制表符而不是空格缩进行 useTabs: false, // Vue文件脚本和样式标签缩进 vueIndentScriptAndStyle: false, // 换行符使用 lf 结尾是 可选值\u0026#34;\u0026lt;auto|lf|crlf|cr\u0026gt;\u0026#34; endOfLine: \u0026#39;auto\u0026#39;, }, ], }, } .eslintignore忽略文件\n/dist/* Prettier npm install -D eslint-plugin-prettier prettier eslint-config-prettier prettier.config.ts\nmodule.exports = { // 一行最多多少个字符 printWidth: 150, // 超出打印宽度 (always | never | preserve ) proseWrap: \u0026#39;preserve\u0026#39;, // 对象属性是否使用引号(as-needed | consistent | preserve; quoteProps: \u0026#39;as-needed\u0026#39;, // 指定要使用的解析器，不需要写文件开头的 @prettier requirePragma: false, // 不需要自动在文件开头插入 @prettier insertPragma: false, // 最后不需要引号 semi: false, // 使用单引号 (true:单引号;false:双引号) singleQuote: true, // 缩进空格数，默认2个空格 tabWidth: 4, // 多行时尽可能打印尾随逗号。 trailingComma: \u0026#39;es5\u0026#39;, // 使用制表符而不是空格缩进行 useTabs: false, // Vue文件脚本和样式标签缩进 vueIndentScriptAndStyle: false, // 换行符使用 lf 结尾是 可选值\u0026#34;\u0026lt;auto|lf|crlf|cr\u0026gt;\u0026#34; endOfLine: \u0026#39;auto\u0026#39;, } prettierignore忽略文件\n/dist/* /html/* .local /node_modules/** **/*.svg **/*.sh /public/* 配置 package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;lint\u0026#34;: \u0026#34;eslint --ext .js,.vue,.ts src\u0026#34;, \u0026#34;prettier\u0026#34;: \u0026#34;prettier --write .\u0026#34;, } } 运行 npm run lint 和 npm run prettier 检查代码\nHusky npm install -D husky package.json\n{ \u0026#34;husky\u0026#34;: { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;npm run lint \u0026amp;\u0026amp; npm run prettier\u0026#34; } } } 会在根目录生成.husky文件夹，里面有pre-commit文件，里面有执行的命令, 可以执行修订\n问题 解决uniapp开发过程中view、image等标签出现诸如“类型{ class: string； }的参数不能赋给类型\u0026hellip;\u0026hellip;”的问题? 在对插件等各方面检查后发现了问题所在，主要问题是在开发过程中这些标签被认为了是 Vue 组件，所以某些属性并没有出现在相关interface上，所以忽略掉这这些原生内容即可。具体操作如下：\n{ \u0026#34;extends\u0026#34;: \u0026#34;@vue/tsconfig/tsconfig.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;sourceMap\u0026#34;: true, \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;ignoreDeprecations\u0026#34;: \u0026#34;5.0\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@/*\u0026#34;: [\u0026#34;./src/*\u0026#34;] }, \u0026#34;lib\u0026#34;: [\u0026#34;esnext\u0026#34;, \u0026#34;dom\u0026#34;], \u0026#34;types\u0026#34;: [ \u0026#34;@dcloudio/types\u0026#34;, \u0026#34;@types/wechat-miniprogram\u0026#34;, \u0026#34;@uni-helper/uni-ui-types\u0026#34;, \u0026#34;@uni-helper/uni-app-types\u0026#34;, ] }, //加入配置，将标签视为原始组件 \u0026#34;vueCompilerOptions\u0026#34;: { \u0026#34;nativeTags\u0026#34;: [\u0026#34;block\u0026#34;, \u0026#34;component\u0026#34;, \u0026#34;template\u0026#34;, \u0026#34;slot\u0026#34;] }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.d.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;] } ","permalink":"https://waite.wang/posts/mini-program/create-uniapp-standard/","summary":"\u003cblockquote\u003e\n\u003cp\u003e可以参考 \u003ca href=\"https://waite.wang/posts/web/vue-project-construction-specification/\"\u003ehttps://waite.wang/posts/web/vue-project-construction-specification/\u003c/a\u003e\n参考: \u003ca href=\"https://blog.csdn.net/u011296285/article/details/136597099\"\u003ehttps://blog.csdn.net/u011296285/article/details/136597099\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"配置eslint代码检查\"\u003e配置eslint代码检查\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm i eslint -D\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e初始化\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpx eslint --init\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e选择配置(根据自己需求选择)\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? How would you like to use ESLint? To check syntax and find problems\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? What \u003cspan class=\"nb\"\u003etype\u003c/span\u003e of modules does your project use? JavaScript modules \u003cspan class=\"o\"\u003e(\u003c/span\u003eimport/export\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? Which framework does your project use? Vue.js\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? Does your project use TypeScript? Yes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? Where does your code run? None\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? How would you like to define a style \u003cspan class=\"k\"\u003efor\u003c/span\u003e your project? Use a popular style guide\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? Which style guide \u003cspan class=\"k\"\u003edo\u003c/span\u003e you want to follow? Airbnb\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e? What format \u003cspan class=\"k\"\u003edo\u003c/span\u003e you want your config file to be in? JavaScript\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e修改.eslintrc.js\u003c/p\u003e","title":"uniapp+vite+vue3+ts配置eslint代码检查及prettier规范检查"},{"content":"Stage 模型 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/start-with-ets-stage-0000001477980905-V2\n一个应用只能有一个 @EntryAbility，但可以有多个 @PageAbility。\n（Stage模型）目录结构 AppScope \u0026gt; app.json5：应用的全局配置信息。 entry：HarmonyOS工程模块，编译构建生成一个HAP包。 src \u0026gt; main \u0026gt; ets：用于存放ArkTS源码。 src \u0026gt; main \u0026gt; ets \u0026gt; entryability：应用/服务的入口。 src \u0026gt; main \u0026gt; ets \u0026gt; pages：应用/服务包含的页面 src \u0026gt; main \u0026gt; resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。 src \u0026gt; main \u0026gt; module.json5：Stage模型模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。 build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。 oh_modules：用于存放三方库依赖信息。关于原npm工程适配ohpm操作，请参考历史工程迁移。 build-profile.json5：应用级配置信息，包括签名、产品配置等。 hvigorfile.ts：应用级编译构建任务脚本。 应用配置文件 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/14d_u7f6e_u6587_u4ef6_uff08stage_u6a21_u578b_uff09-0000001427902192-V2\napp.json5文件是应用的全局配置文件，用于配置应用的基本信息、版本信息、图标、名称、描述等。\n属性名称 含义 数据类型 是否可缺省 bundleName 标识应用的Bundle名称，用于标识应用的唯一性。该标签不可缺省。标签的值命名规则 ：- 字符串以字母、数字、下划线和符号“.”组成。- 以字母开头。- 最小长度7个字节，最大长度127个字节。推荐采用反域名形式命名（如com.example.demo，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。 字符串 该标签不可缺省。 bundleType 标识应用的Bundle类型，用于区分应用或者原子化服务。该标签可选值为app和atomicService ：- app：当前Bundle为普通应用。- atomicService：当前Bundle为元服务。 字符串 该标签可以缺省，缺省为app。 debug 标识应用是否可调试，该标签由IDE编译构建时生成。- true：可调试。- false：不可调试。 布尔值 该标签可以缺省，缺省为false。 icon 标识应用的图标，标签值为图标资源文件的索引。 字符串 该标签不可缺省。 label 标识应用的名称，标签值为字符串资源的索引。 字符串 该标签不可缺省。 description 标识应用的描述信息，标签值是字符串类型（最大255个字节）或对描述内容的字符串资源索引。 字符串 该标签可缺省，缺省值为空。 vendor 标识对应用开发厂商的描述。该标签的值是字符串类型（最大255个字节）。 字符串 该标签可以缺省，缺省为空。 versionCode 标识应用的版本号，该标签值为32位非负整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。开发者可以将该值设置为任何正整数，但是必须确保应用的新版本都使用比旧版本更大的值。该标签不可缺省，versionCode值应小于2^31次方。 数值 该标签不可缺省。 versionName 标识应用版本号的文字描述，用于向用户展示。该标签仅由数字和点构成，推荐采用“A.B.C.D”四段式的形式。四段式推荐的含义如下所示。第一段：主版本号/Major，范围0-99，重大修改的版本，如实现新的大功能或重大变化。第二段：次版本号/Minor，范围0-99，表示实现较突出的特点，如新功能添加或大问题修复。第三段：特性版本号/Feature，范围0-99，标识规划的新版本特性。第四段：修订版本号/Patch，范围0-999，表示维护版本，修复bug。标签最大字节长度为127。 字符串 该标签不可缺省。 minCompatibleVersionCode 标识应用能够兼容的最低历史版本号，用于跨设备兼容性判断。说明当前版本暂不支持跨设备能力。 数值 该标签可缺省，缺省值等于versionCode标签值。 minAPIVersion 标识应用运行需要的SDK的API最小版本。 数值 由build-profile.json5中的compatibleSdkVersion生成。 targetAPIVersion 标识应用运行需要的API目标版本。 数值 由build-profile.json5中的compileSdkVersion生成。 apiReleaseType 标识应用运行需要的API目标版本的类型，采用字符串类型表示。取值为“CanaryN”、“BetaN”或者“Release”，其中，N代表大于零的整数。- Canary：受限发布的版本。- Beta：公开发布的Beta版本。- Release：公开发布的正式版本。该字段由DevEco Studio读取当前使用的SDK的Stage来生成。 字符串 该标签可缺省，由IDE生成并覆盖。 multiProjects 标识当前工程是否支持多个工程的联合开发。- true：当前工程支持多个工程的联合开发。- false：当前工程不支持多个工程的联合开发。多工程开发可以参考文档：多工程构建。 布尔值 可缺省，缺省值为false。 tablet 标识对tablet设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。如果使用该属性对tablet设备做了特殊配置，则应用在tablet设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时tablet设备使用app.json5公共区域配置的属性值。 tv 标识对tv设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。如果使用该属性对tv设备做了特殊配置，则应用在tv设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时tv设备使用app.json5公共区域配置的属性值。 wearable 标识对wearable设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。如果使用该属性对wearable设备做了特殊配置，则应用在wearable设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时wearable设备使用app.json5公共区域配置的属性值。 car 标识对car设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。如果使用该属性对car设备做了特殊配置，则应用在car设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时car设备使用app.json5公共区域配置的属性值。 phone 标识对phone设备做的特殊配置，可以配置的属性字段有上文提到的：minAPIVersion、distributedNotificationEnabled。如果使用该属性对phone设备做了特殊配置，则应用在phone设备中会采用此处配置的属性值，并忽略在app.json5公共区域配置的属性值。 对象 该标签可缺省，缺省时phone设备使用app.json5公共区域配置的属性值。 module.json5文件是Stage模型模块配置文件，用于配置HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。 以下是一个示例:\n{ \u0026#34;module\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;entry\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;entry\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;$string:module_desc\u0026#34;, \u0026#34;mainElement\u0026#34;: \u0026#34;EntryAbility\u0026#34;, \u0026#34;deviceTypes\u0026#34;: [ \u0026#34;tv\u0026#34;, \u0026#34;tablet\u0026#34; ], \u0026#34;deliveryWithInstall\u0026#34;: true, \u0026#34;installationFree\u0026#34;: false, \u0026#34;pages\u0026#34;: \u0026#34;$profile:main_pages\u0026#34;, \u0026#34;virtualMachine\u0026#34;: \u0026#34;ark\u0026#34;, \u0026#34;metadata\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;resource\u0026#34;: \u0026#34;$profile:distributionFilter_config\u0026#34; } ], \u0026#34;abilities\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;EntryAbility\u0026#34;, \u0026#34;srcEntry\u0026#34;: \u0026#34;./ets/entryability/EntryAbility.ts\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;$string:EntryAbility_desc\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;$media:icon\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;$string:EntryAbility_label\u0026#34;, \u0026#34;startWindowIcon\u0026#34;: \u0026#34;$media:icon\u0026#34;, \u0026#34;startWindowBackground\u0026#34;: \u0026#34;$color:start_window_background\u0026#34;, \u0026#34;exported\u0026#34;: true, \u0026#34;skills\u0026#34;: [ { \u0026#34;entities\u0026#34;: [ \u0026#34;entity.system.home\u0026#34; ], \u0026#34;actions\u0026#34;: [ \u0026#34;ohos.want.action.home\u0026#34; ] } ] } ], \u0026#34;requestPermissions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ohos.abilitydemo.permission.PROVIDER\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;$string:reason\u0026#34;, \u0026#34;usedScene\u0026#34;: { \u0026#34;abilities\u0026#34;: [ \u0026#34;FormAbility\u0026#34; ], \u0026#34;when\u0026#34;: \u0026#34;inuse\u0026#34; } } ] } } 属性名称 含义 数据类型 是否可缺省 name 标识当前Module的名称，标签值采用字符串表示（最大长度31个字节），该名称在整个应用要唯一，仅支持英文字符。 字符串 该标签不可缺省。 type 标识当前Module的类型。类型有两种，分别：- entry：应用的主模块。- feature：应用的动态特性模块。-har：静态共享包模块。-shared：动态共享包模块。 字符串 该标签不可缺省。 srcEntry 标识当前Module所对应的代码路径，标签值为字符串（最长为127字节）。 字符串 该标签可缺省，缺省值为空。 description 标识当前Module的描述信息，标签值是字符串类型（最长255字节）或对描述内容的字符串资源索引。 字符串 该标签可缺省，缺省值为空。 process 标识当前Module的进程名，标签值为字符串类型（最长为31个字节）。如果在HAP标签下配置了process，该应用的所有UIAbility、DataShareExtensionAbility、ServiceExtensionAbility都运行在该进程中。说明：- 仅支持系统应用配置，三方应用配置不生效。 字符串 可缺省，缺省为app.json5文件下app标签下的bundleName。 mainElement 标识当前Module的入口UIAbility名称或者ExtensionAbility名称。标签最大字节长度为255。 字符串 该标签可缺省，缺省值为空。 deviceTypes 标识当前Module可以运行在哪类设备上，标签值采用字符串数组的表示。 字符串数组 该标签不可缺省。 deliveryWithInstall 标识当前Module是否在用户主动安装的时候安装，表示该Module对应的HAP是否跟随应用一起安装。- true：主动安装时安装。- false：主动安装时不安装。 布尔值 该标签不可缺省。 installationFree 标识当前Module是否支持免安装特性。- true：表示支持免安装特性，且符合免安装约束。- false：表示不支持免安装特性。说明：- 当应用的entry类型Module的该字段配置为true时，该应用的feature类型的该字段也需要配置为true。- 当应用的entry类型Module的该字段配置为false时，该应用的feature类型的该字段根据业务需求配置true或false。 布尔值 该标签不可缺省。 virtualMachine 标识当前Module运行的目标虚拟机类型，供云端分发使用，如应用市场和分发中心。该标签值为字符串。如果目标虚拟机类型为ArkTS引擎，则其值为“ark+版本号”。 字符串 该标签由IDE构建HAP的时候自动插入。 pages 标识当前Module的profile资源，用于列举每个页面信息。该标签最大长度为255个字节。 字符串 在有UIAbility的场景下，该标签不可缺省。 metadata 标识当前Module的自定义元信息，标签值为数组类型，只对当前Module、UIAbility、ExtensionAbility生效。 对象数组 该标签可缺省，缺省值为空。 abilities 标识当前Module中UIAbility的配置信息，标签值为数组类型，只对当前UIAbility生效。 对象 该标签可缺省，缺省值为空。 extensionAbilities 标识当前Module中ExtensionAbility的配置信息，标签值为数组类型，只对当前ExtensionAbility生效。 对象 该标签可缺省，缺省值为空。 requestPermissions 标识当前应用运行时需向系统申请的权限集合。 对象 该标签可缺省，缺省值为空。 testRunner 标识当前Module用于支持对测试框架的配置。 对象 该标签可缺省，缺省值为空。 详细可以查阅 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/module-configuration-file-0000001427744540-V2\n生命周期 UIAbility组件生命周期 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/uiability-lifecycle-0000001427902208-V2\nsrc/main/ets/entryability/EntryAbility.ts\nForeground和Background状态分别在UIAbility实例切换至前台和切换至后台时触发，对应于onForeground()回调和onBackground()回调。\nonForeground()回调，在UIAbility的UI界面可见之前，如UIAbility切换至前台时触发。可以在onForeground()回调中申请系统需要的资源，或者重新申请在onBackground()中释放的资源。\nonBackground()回调，在UIAbility的UI界面完全不可见之后，如UIAbility切换至后台时候触发。可以在onBackground()回调中释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。\n例如应用在使用过程中需要使用用户定位时，假设应用已获得用户的定位权限授权。在UI界面显示之前，可以在onForeground()回调中开启定位功能，从而获取到当前的位置信息。\n当应用切换到后台状态，可以在onBackground()回调中停止定位功能，以节省系统的资源消耗。\n页面和组件的生命周期 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-page-custom-components-lifecycle-0000001524296665-V2\n在开始之前，我们先明确自定义组件和页面的关系：\n自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用，可以调用组件的生命周期。 页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。 页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：\nonPageShow：页面每次显示时触发一次，包括路由过程、应用进入前台等场景。 onPageHide：页面每次隐藏时触发一次，包括路由过程、应用进入后台等场景。 onBackPress：当用户点击返回按钮时触发。 组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：\naboutToAppear：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。 aboutToDisappear：在自定义组件析构销毁之前执行。不允许在aboutToDisappear函数中改变状态变量，特别是@Link变量的修改可能会导致应用程序行为不稳定。 生命周期流程如下图所示，下图展示的是被@Entry装饰的组件（页面）生命周期。\n// Index.ets import router from \u0026#39;@ohos.router\u0026#39;; @Entry @Component struct MyComponent { @State showChild: boolean = true; // 只有被@Entry装饰的组件才可以调用页面的生命周期 onPageShow() { console.info(\u0026#39;Index onPageShow\u0026#39;); } // 只有被@Entry装饰的组件才可以调用页面的生命周期 onPageHide() { console.info(\u0026#39;Index onPageHide\u0026#39;); } // 只有被@Entry装饰的组件才可以调用页面的生命周期 onBackPress() { console.info(\u0026#39;Index onBackPress\u0026#39;); } // 组件生命周期 aboutToAppear() { console.info(\u0026#39;MyComponent aboutToAppear\u0026#39;); } // 组件生命周期 aboutToDisappear() { console.info(\u0026#39;MyComponent aboutToDisappear\u0026#39;); } build() { Column() { // this.showChild为true，创建Child子组件，执行Child aboutToAppear if (this.showChild) { Child() } // this.showChild为false，删除Child子组件，执行Child aboutToDisappear Button(\u0026#39;delete Child\u0026#39;).onClick(() =\u0026gt; { this.showChild = false; }) // push到Page2页面，执行onPageHide Button(\u0026#39;push to next page\u0026#39;) .onClick(() =\u0026gt; { router.pushUrl({ url: \u0026#39;pages/Second\u0026#39; }); }) } } } @Component struct Child { @State title: string = \u0026#39;Hello World\u0026#39;; // 组件生命周期 aboutToDisappear() { console.info(\u0026#39;[lifeCycle] Child aboutToDisappear\u0026#39;) } // 组件生命周期 aboutToAppear() { console.info(\u0026#39;[lifeCycle] Child aboutToAppear\u0026#39;) } build() { Text(this.title).fontSize(50).onClick(() =\u0026gt; { this.title = \u0026#39;Hello ArkUI\u0026#39;; }) } } UIAbility组件启动模式 具体重新观看: https://www.bilibili.com/video/BV1Sa4y1Z7B1/?p=27\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/uiability-launch-type-0000001428061476-V2\nUIAbility的启动模式是指UIAbility实例在启动时的不同呈现状态。针对不同的业务场景，系统提供了三种启动模式：\nsingleton（单实例模式） multiton（多实例模式） specified（指定实例模式） singleton启动模式 singleton启动模式为单实例模式，也是默认情况下的启动模式。\n每次调用startAbility()方法时，如果应用进程中该类型的UIAbility实例已经存在，则复用系统中的UIAbility实例。系统中只存在唯一一个该UIAbility实例，即在最近任务列表中只存在一个该类型的UIAbility实例。\n图1 单实例模式演示效果\n说明\n应用的UIAbility实例已创建，该UIAbility配置为单实例模式，再次调用startAbility()方法启动该UIAbility实例，此时只会进入该UIAbility的onNewWant()回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。\n如果需要使用singleton启动模式，在module.json5配置文件中的\u0026quot;launchType\u0026quot;字段配置为\u0026quot;singleton\u0026quot;即可。\n{ \u0026#34;module\u0026#34;: { // ... \u0026#34;abilities\u0026#34;: [ { \u0026#34;launchType\u0026#34;: \u0026#34;singleton\u0026#34;, // ... } ] } } multiton启动模式 multiton启动模式为多实例模式，每次调用startAbility()方法时，都会在应用进程中创建一个新的该类型UIAbility实例。即在最近任务列表中可以看到有多个该类型的UIAbility实例。这种情况下可以将UIAbility配置为multiton（多实例模式）。\n图2 多实例模式演示效果\nmultiton启动模式的开发使用，在module.json5配置文件中的\u0026quot;launchType\u0026quot;字段配置为\u0026quot;multiton\u0026quot;即可。\n{ \u0026#34;module\u0026#34;: { // ... \u0026#34;abilities\u0026#34;: [ { \u0026#34;launchType\u0026#34;: \u0026#34;multiton\u0026#34;, // ... } ] } } specified启动模式 specified启动模式为指定实例模式，针对一些特殊场景使用（例如文档应用中每次新建文档希望都能新建一个文档实例，重复打开一个已保存的文档希望打开的都是同一个文档实例）。\n在UIAbility实例创建之前，允许开发者为该实例创建一个唯一的字符串Key，创建的UIAbility实例绑定Key之后，后续每次调用startAbility()方法时，都会询问应用使用哪个Key对应的UIAbility实例来响应startAbility()请求。运行时由UIAbility内部业务决定是否创建多实例，如果匹配有该UIAbility实例的Key，则直接拉起与之绑定的UIAbility实例，否则创建一个新的UIAbility实例。\n图3 指定实例模式演示效果\n应用的UIAbility实例已创建，该UIAbility配置为指定实例模式，再次调用startAbility()方法启动该UIAbility实例，且AbilityStage的onAcceptWant()回调匹配到一个已创建的UIAbility实例。此时，再次启动该UIAbility时，只会进入该UIAbility的onNewWant()回调，不会进入其onCreate()和onWindowStageCreate()生命周期回调。\n例如有两个UIAbility：EntryAbility和FuncAbility，FuncAbility配置为specified启动模式，需要从EntryAbility的页面中启动FuncAbility。\n在FuncAbility中，将module.json5配置文件的\u0026quot;launchType\u0026quot;字段配置为\u0026quot;specified\u0026quot;。\n{ \u0026#34;module\u0026#34;: { // ... \u0026#34;abilities\u0026#34;: [ { \u0026#34;launchType\u0026#34;: \u0026#34;specified\u0026#34;, // ... } ] } } 在EntryAbility中，调用startAbility()方法时，在want参数中，增加一个自定义参数来区别UIAbility实例，例如增加一个\u0026quot;instanceKey\u0026quot;自定义参数。\n// 在启动指定实例模式的UIAbility时，给每一个UIAbility实例配置一个独立的Key标识 // 例如在文档使用场景中，可以用文档路径作为Key标识 function getInstance() { // ... } let want = { deviceId: \u0026#39;\u0026#39;, // deviceId为空表示本设备 bundleName: \u0026#39;com.example.myapplication\u0026#39;, abilityName: \u0026#39;FuncAbility\u0026#39;, moduleName: \u0026#39;module1\u0026#39;, // moduleName非必选 parameters: { // 自定义信息 instanceKey: getInstance(), }, } // context为调用方UIAbility的AbilityContext this.context.startAbility(want).then(() =\u0026gt; { // ... }).catch((err) =\u0026gt; { // ... }) 由于FuncAbility的启动模式配置为了指定实例启动模式，在FuncAbility启动之前，会先进入其对应的AbilityStage的onAcceptWant()生命周期回调中，解析传入的want参数，获取\u0026quot;instanceKey\u0026quot;自定义参数。根据业务需要通过AbilityStage的onAcceptWant()生命周期回调返回一个字符串Key标识。如果返回的Key对应一个已启动的UIAbility，则会将之前的UIAbility拉回前台并获焦，而不创建新的实例，否则创建新的实例并启动。\nimport AbilityStage from \u0026#39;@ohos.app.ability.AbilityStage\u0026#39;; export default class MyAbilityStage extends AbilityStage { onAcceptWant(want): string { // 在被调用方的AbilityStage中，针对启动模式为specified的UIAbility返回一个UIAbility实例对应的一个Key值 // 当前示例指的是module1 Module的FuncAbility if (want.abilityName === \u0026#39;FuncAbility\u0026#39;) { // 返回的字符串Key标识为自定义拼接的字符串内容 return `ControlModule_EntryAbilityInstance_${want.parameters.instanceKey}`; } return \u0026#39;\u0026#39;; } } 例如在文档应用中，可以对不同的文档实例内容绑定不同的Key值。当每次新建文档的时候，可以传入不同的新Key值（如可以将文件的路径作为一个Key标识），此时AbilityStage中启动UIAbility时都会创建一个新的UIAbility实例；当新建的文档保存之后，回到桌面，或者新打开一个已保存的文档，回到桌面，此时再次打开该已保存的文档，此时AbilityStage中再次启动该UIAbility时，打开的仍然是之前原来已保存的文档界面。\n以如下步骤所示进行举例说明。\n打开文件A，对应启动一个新的UIAbility实例，例如启动“UIAbility实例1”。 在最近任务列表中关闭文件A的进程，此时UIAbility实例1被销毁，回到桌面，再次打开文件A，此时对应启动一个新的UIAbility实例，例如启动“UIAbility实例2”。 回到桌面，打开文件B，此时对应启动一个新的UIAbility实例，例如启动“UIAbility实例3”。 回到桌面，再次打开文件A，此时对应启动的还是之前的“UIAbility实例2”。 网络连接 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/net-mgmt-overview-0000001478341009-V2\nHTTP数据请求 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/http-request-0000001478061585-V2\n应用通过HTTP发起一个数据请求，支持常见的GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE、CONNECT方法。\nHTTP数据请求功能主要由http模块提供。\n使用该功能需要申请ohos.permission.INTERNET权限。\n权限申请请参考访问控制（权限）开发指导。\n涉及的接口如下表，具体的接口说明请参考API文档。\n接口名 功能描述 createHttp() 创建一个http请求。 request() 根据URL地址，发起HTTP网络请求。 destroy() 中断请求任务。 on(type: \u0026lsquo;headersReceive\u0026rsquo;) 订阅HTTP Response Header 事件。 off(type: \u0026lsquo;headersReceive\u0026rsquo;) 取消订阅HTTP Response Header 事件。 once(\u0026lsquo;headersReceive\u0026rsquo;)8+ 订阅HTTP Response Header 事件，但是只触发一次。 request接口开发步骤 从@ohos.net.http.d.ts中导入http命名空间。 调用createHttp()方法，创建一个HttpRequest对象。 调用该对象的on()方法，订阅http响应头事件，此接口会比request请求先返回。可以根据业务需要订阅此消息。 调用该对象的request()方法，传入http请求的url地址和可选参数，发起网络请求。 按照实际业务需要，解析返回结果。 调用该对象的off()方法，取消订阅http响应头事件。 当该请求使用完毕时，调用destroy()方法主动销毁。 // 引入包名 import http from \u0026#39;@ohos.net.http\u0026#39;; // 每一个httpRequest对应一个HTTP请求任务，不可复用 let httpRequest = http.createHttp(); // 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息 // 从API 8开始，使用on(\u0026#39;headersReceive\u0026#39;, Callback)替代on(\u0026#39;headerReceive\u0026#39;, AsyncCallback)。 8+ httpRequest.on(\u0026#39;headersReceive\u0026#39;, (header) =\u0026gt; { console.info(\u0026#39;header: \u0026#39; + JSON.stringify(header)); }); httpRequest.request( // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定 \u0026#34;EXAMPLE_URL\u0026#34;, { method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET // 开发者根据自身业务需要添加header字段 header: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, // 当使用POST请求时此字段用于传递内容 extraData: { \u0026#34;data\u0026#34;: \u0026#34;data to send\u0026#34;, }, expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型 usingCache: true, // 可选，默认为true priority: 1, // 可选，默认为1 connectTimeout: 60000, // 可选，默认为60000ms readTimeout: 60000, // 可选，默认为60000ms usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定 }, (err, data) =\u0026gt; { if (!err) { // data.result为HTTP响应内容，可根据业务需要进行解析 console.info(\u0026#39;Result:\u0026#39; + JSON.stringify(data.result)); console.info(\u0026#39;code:\u0026#39; + JSON.stringify(data.responseCode)); // data.header为HTTP响应头，可根据业务需要进行解析 console.info(\u0026#39;header:\u0026#39; + JSON.stringify(data.header)); console.info(\u0026#39;cookies:\u0026#39; + JSON.stringify(data.cookies)); // 8+ } else { console.info(\u0026#39;error:\u0026#39; + JSON.stringify(err)); // 取消订阅HTTP响应头事件 httpRequest.off(\u0026#39;headersReceive\u0026#39;); // 当该请求使用完毕时，调用destroy方法主动销毁 httpRequest.destroy(); } } ); 案例 现在有这么一个接口: http://127.0.0.1:3000/shops?pageNo=1\u0026amp;\u0026amp;pageSize=4 返回值如下\n[ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;103茶餐厅\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;/images/s3fqawWswzk.jpg\u0026#34;, \u0026#34;/images/aZGOT1OjpJmLxG6urQ.jpg\u0026#34; ], \u0026#34;area\u0026#34;: \u0026#34;大关\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;金华路锦昌文华苑29号\u0026#34;, \u0026#34;avgPrice\u0026#34;: 80, \u0026#34;comments\u0026#34;: 3035, \u0026#34;score\u0026#34;: 37, \u0026#34;openHours\u0026#34;: \u0026#34;10:00-22:00\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;蔡馬洪涛烤肉·老北京铜锅涮羊肉\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;/images/faca41195272.jpg\u0026#34;, \u0026#34;/images/a9f88d706914.jpg\u0026#34;, \u0026#34;/images/jpJmLxG6urQ.jpg\u0026#34; ], \u0026#34;area\u0026#34;: \u0026#34;拱宸桥/上塘\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;上塘路1035号（中国工商银行旁）\u0026#34;, \u0026#34;avgPrice\u0026#34;: 85, \u0026#34;comments\u0026#34;: 1460, \u0026#34;score\u0026#34;: 46, \u0026#34;openHours\u0026#34;: \u0026#34;11:30-03:00\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;新白鹿餐厅(运河上街店)\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;/images/7cgjmzif2w2aalka4gms.jpg\u0026#34;, \u0026#34;/images/73w0k4d40mxjt54btzda.jpg\u0026#34;, \u0026#34;/images/uyb31c7yfqy95dejvis1.jpg\u0026#34; ], \u0026#34;area\u0026#34;: \u0026#34;运河上街\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;台州路2号运河上街购物中心F5\u0026#34;, \u0026#34;avgPrice\u0026#34;: 61, \u0026#34;comments\u0026#34;: 8045, \u0026#34;score\u0026#34;: 47, \u0026#34;openHours\u0026#34;: \u0026#34;10:30-21:00\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;Mamala(杭州远洋乐堤港店)\u0026#34;, \u0026#34;images\u0026#34;: [ \u0026#34;/images/xpm2bq95a3ro2lc4vp5u.jpg\u0026#34;, \u0026#34;/images/7kd3rq9hvtougx3mhnlt.jpg\u0026#34; ], \u0026#34;area\u0026#34;: \u0026#34;拱宸桥/上塘\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;丽水路66号远洋乐堤港商城2期1层B115号\u0026#34;, \u0026#34;avgPrice\u0026#34;: 290, \u0026#34;comments\u0026#34;: 9529, \u0026#34;score\u0026#34;: 49, \u0026#34;openHours\u0026#34;: \u0026#34;11:00-22:00\u0026#34; } ] //src/main/ets/viewmodel/ShopInfo.ts export default class ShopInfo { id: number name: string images: string[] area: string address: string avgPrice: number comments: number score: number openHours: string } // src/main/ets/model/ShopModel.ts import http from \u0026#39;@ohos.net.http\u0026#39; import ShopInfo from \u0026#39;../viewmodel/ShopInfo\u0026#39; class ShopModel { pageNo: number = 1 url: string = `http://127.0.0.1:3000/` getShopList(): Promise\u0026lt;ShopInfo[]\u0026gt; { return new Promise( (resolve, reject) =\u0026gt; { let httpRequest = http.createHttp() httpRequest.request( this.url + `shops?pageNo=${this.pageNo}\u0026amp;pageSize=4`, { method: http.RequestMethod.GET } ) .then((res: http.HttpResponse) =\u0026gt; { if (res.responseCode === 200) { // 请求成功 console.log(\u0026#34;Success\u0026#34;) resolve(JSON.parse(res.result.toString())) } else { console.log(\u0026#34;Error\u0026#34;, JSON.stringify(res)) reject(\u0026#34;Error\u0026#34;) } }) .catch((err: Error) =\u0026gt; { // 请求失败 console.log(\u0026#34;Error\u0026#34;, JSON.stringify(err)) reject(\u0026#34;Error\u0026#34;) }) } ) } } const shopModel = new ShopModel() export default shopModel as ShopModel // src/main/ets/views import ShopInfo from \u0026#39;../viewmodel/ShopInfo\u0026#39; @Component export default struct ShopItem { shop: ShopInfo build(){ Column({space: 5}){ Row(){ Text(this.shop.name) .fontSize(20) .fontWeight(FontWeight.Bold) .ellipsisTextOverFlow() } .width(\u0026#39;100%\u0026#39;) Row(){ Text(this.shop.address) .fontColor(\u0026#39;#a3a3a3\u0026#39;) .ellipsisTextOverFlow() }.width(\u0026#39;100%\u0026#39;) Row({space: 5}){ Rating({rating: this.shop.score/10 , indicator: true}).stars(5).stepSize(0.1) Text(`${this.shop.score / 10}`).fontColor(\u0026#39;#ffb04d\u0026#39;) Text(`${this.shop.comments}条`).fontColor(\u0026#39;#222\u0026#39;) Blank() Text(`￥${this.shop.avgPrice}/人`) }.width(\u0026#39;100%\u0026#39;) List({space: 10}){ ForEach(this.shop.images, (image) =\u0026gt; { ListItem(){ Column(){ Image(image) .width(150).aspectRatio(1.1).borderRadius(5) } } }) } .listDirection(Axis.Horizontal) .width(\u0026#39;100%\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .height(240) .padding(12) .backgroundColor(Color.White) .borderRadius(15) .shadow({radius: 6, color: \u0026#39;#1F000000\u0026#39;, offsetX: 2, offsetY: 4}) } } // 文本超出时的统一样式处理 @Extend(Text) function ellipsisTextOverFlow(line: number = 1){ .textOverflow({overflow: TextOverflow.Ellipsis}) .maxLines(line) } // src/main/ets/pages/Index.ets import ShopInfo from \u0026#39;../viewmodel/ShopInfo\u0026#39; @Component export default struct ShopItem { shop: ShopInfo build(){ Column({space: 5}){ Row(){ Text(this.shop.name) .fontSize(20) .fontWeight(FontWeight.Bold) .ellipsisTextOverFlow() } .width(\u0026#39;100%\u0026#39;) Row(){ Text(this.shop.address) .fontColor(\u0026#39;#a3a3a3\u0026#39;) .ellipsisTextOverFlow() }.width(\u0026#39;100%\u0026#39;) Row({space: 5}){ Rating({rating: this.shop.score/10 , indicator: true}).stars(5).stepSize(0.1) Text(`${this.shop.score / 10}`).fontColor(\u0026#39;#ffb04d\u0026#39;) Text(`${this.shop.comments}条`).fontColor(\u0026#39;#222\u0026#39;) Blank() Text(`￥${this.shop.avgPrice}/人`) }.width(\u0026#39;100%\u0026#39;) List({space: 10}){ ForEach(this.shop.images, (image) =\u0026gt; { ListItem(){ Column(){ Image(image) .width(150).aspectRatio(1.1).borderRadius(5) } } }) } .listDirection(Axis.Horizontal) .width(\u0026#39;100%\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .height(240) .padding(12) .backgroundColor(Color.White) .borderRadius(15) .shadow({radius: 6, color: \u0026#39;#1F000000\u0026#39;, offsetX: 2, offsetY: 4}) } } // 文本超出时的统一样式处理 @Extend(Text) function ellipsisTextOverFlow(line: number = 1){ .textOverflow({overflow: TextOverflow.Ellipsis}) .maxLines(line) } 第三方库 axios https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/ide-command-line-ohpm-0000001490235312-V2\nOHPM CLI 作为鸿蒙生态三方库的包管理工具，支持OpenHarmony共享包的发布、安装和依赖管理。\n下载ohpm工具包，点击链接获取。\n解压文件，进入“ohpm/bin”目录，打开命令行工具，执行如下指令init.bat初始化ohpm\n将ohpm配置到环境变量中。\nWindows环境变量设置方法：\n在此电脑 \u0026gt; 属性 \u0026gt; 高级系统设置 \u0026gt; 高级 \u0026gt; 环境变量中，将ohpm命令行工具的bin目录配置到系统或者用户的PATH变量中。\n安装完成之后，执行ohpm -v 输出版本号即为安装成功\n配置完环境变量后可能需要重启电脑才能生效\nOpenHarmony三方库中心仓: https://ohpm.openharmony.cn/#/cn/home\n以下为 使用案例\n// import http from \u0026#39;@ohos.net.http\u0026#39; import axios from \u0026#39;@ohos/axios\u0026#39; import ShopInfo from \u0026#39;../viewmodel/ShopInfo\u0026#39; class ShopModel { pageNo: number = 1 url: string = `http://127.0.0.1:3000/` getShopList(): Promise\u0026lt;ShopInfo[]\u0026gt; { return new Promise( (resolve, reject) =\u0026gt; { axios.get( this.url + `shops?pageNo=${this.pageNo}\u0026amp;pageSize=4`, ) .then((res) =\u0026gt; { if (res.status === 200) { // 请求成功 console.log(\u0026#34;Success\u0026#34;) resolve(res.data) } else { console.log(\u0026#34;Error\u0026#34;, JSON.stringify(res)) reject(\u0026#34;Error\u0026#34;) } }) .catch((err: Error) =\u0026gt; { // 请求失败 console.log(\u0026#34;Error\u0026#34;, JSON.stringify(err)) reject(\u0026#34;Error\u0026#34;) }) } ) } } const shopModel = new ShopModel() export default shopModel as ShopModel 数据持久化 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/app-data-persistence-overview-0000001505513497-V2\n应用数据持久化，是指应用将内存中的数据通过文件或数据库的形式保存到设备上。内存中的数据形态通常是任意的数据结构或数据对象，存储介质上的数据形态可能是文本、数据库、二进制文件等。\nHarmonyOS标准系统支持典型的存储数据形态，包括用户首选项、键值型数据库、关系型数据库。\n开发者可以根据如下功能介绍，选择合适的数据形态以满足自己应用数据的持久化需要。\n用户首选项（Preferences）：通常用于保存应用的配置信息。数据通过文本的形式保存在设备中，应用使用过程中会将文本中的数据全量加载到内存中，所以访问速度快、效率高，但不适合需要存储大量数据的场景。 键值型数据库（KV-Store）：一种非关系型数据库，其数据以“键值”对的形式进行组织、索引和存储，其中“键”作为唯一标识符。适合很少数据关系和业务关系的业务数据存储，同时因其在分布式场景中降低了解决数据库版本兼容问题的复杂度，和数据同步过程中冲突解决的复杂度而被广泛使用。相比于关系型数据库，更容易做到跨设备跨版本兼容。 关系型数据库（RelationalStore）：一种关系型数据库，以行和列的形式存储数据，广泛用于应用中的关系型数据的处理，包括一系列的增、删、改、查等接口，开发者也可以运行自己定义的SQL语句来满足复杂业务场景的需要。 在 harmony 中, 比较常用的是 用户首选项以及关系型数据库\n用户首选项 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/data-persistence-by-preferences-0000001505432513-V2\n用户首选项为应用提供Key-Value键值型的数据处理能力，支持应用持久化轻量级数据，并对其修改和查询。当用户希望有一个全局唯一存储的地方，可以采用用户首选项来进行存储。Preferences会将该数据缓存在内存中，当用户读取的时候，能够快速从内存中获取数据，当需要持久化时可以使用flush接口将内存中的数据写入持久化文件中。Preferences会随着存放的数据量越多而导致应用占用的内存越大，因此，Preferences不适合存放过多的数据，适用的场景一般为应用保存用户的个性化设置（字体大小，是否开启夜间模式）等。\nKey 为 string 类型, 要求非空且长度不超过80字节\nValue 可以是 string, number, boolean及以上类型数组, 大小不超过 8192 字节\n数据量建议不超过一万条\n下面对preferences 进行封装，基本思路：\n注意: 只要在真机预览才能看到效果\n在获取preferences实例后会将其保存单例中，这个单例是GlobalContext，方便后期可以通过单例直接获取实例；由于get()返回值类型是不确定性，定义一个联合类型的别名ValueType 来接收\n// src/main/ets/common/PreferencesUtil.ts import dataPreferences from \u0026#39;@ohos.data.preferences\u0026#39; import GlobalContext from \u0026#39;../../common/GlobalContext\u0026#39; import { LogUtils } from \u0026#39;../LogUtils\u0026#39; const LOG = \u0026#39;PreferencesUtils-PUT\u0026#39; // 默认文件名(数据库表名)，可以在构造函数进行修改 const PREFERENCES_NAME = \u0026#39;scjgPreferences\u0026#39; const KEY_PREFERENCES = \u0026#39;preferences\u0026#39; type ValueType = number | string | boolean | Array\u0026lt;number\u0026gt; | Array\u0026lt;string\u0026gt; | Array\u0026lt;boolean\u0026gt; class PreferencesUtils { // preferences的文件名-数据库表名 private preferencesName: string = PREFERENCES_NAME // 用于获取preferences实例的key值，保存到单例中 private keyPreferences: string = KEY_PREFERENCES constructor(name: string = PREFERENCES_NAME, key: string = KEY_PREFERENCES) { this.preferencesName = name this.keyPreferences = key } /** * 创建首选项实例 * @param context: 应用上下文 * @param preferencesName: 数据库表名 * @returns */ createPreferences(context): Promise\u0026lt;dataPreferences.Preferences\u0026gt; { let preferences = dataPreferences.getPreferences(context, this.preferencesName) GlobalContext.getContext().setObject(this.keyPreferences, preferences) return } /** * 获取首选项实例 * @returns */ getPreferences(): Promise\u0026lt;dataPreferences.Preferences\u0026gt; { return GlobalContext.getContext().getObject(this.keyPreferences) as Promise\u0026lt;dataPreferences.Preferences\u0026gt; } /** * 获取数据 * @param key: 读取key值 * @param def: 函数出参 * @returns */ async get(key: string, def?: ValueType): Promise\u0026lt;ValueType\u0026gt; { return (await this.getPreferences()).get(key, def) } // 获取全部数据 async getAll(): Promise\u0026lt;Object\u0026gt; { let preferences = await this.getPreferences() return preferences.getAll() } /** * 插入数据 * @param key: 存入key值 * @param value: 存储数据 * @returns */ async put(key: string, value: ValueType): Promise\u0026lt;void\u0026gt; { let promise = await this.getPreferences().then(async preferences =\u0026gt; { // 插入数据 await preferences.put(key, value) // 写入文件 await preferences.flush() }).catch(error =\u0026gt; { LogUtils.error(LOG, `code:${error.code}, message:${error.message}`) }) return promise } /** * 删除数据 * @param key: 删除key的value值 * @returns */ async delete(key: string): Promise\u0026lt;void\u0026gt; { return (await this.getPreferences()).delete(key).finally(async () =\u0026gt; { (await this.getPreferences()).flush() }) } // 清空数据 async clear(): Promise\u0026lt;void\u0026gt; { return (await this.getPreferences()).clear().finally(async () =\u0026gt; { (await this.getPreferences()).flush() }) } } export default new PreferencesUtils() // src/main/ets/common/GlobalContext.ts export default class GlobalContext { private constructor() {} private static instance: GlobalContext private _objects = new Map\u0026lt;string, Object\u0026gt;() public static getContext(): GlobalContext { if (!GlobalContext.instance) { GlobalContext.instance = new GlobalContext() } return GlobalContext.instance } getObject(value: string): Object | undefined { return this._objects.get(value) } setObject(key: string, objectClass: Object): void { this._objects.set(key, objectClass) } } 在EntryAbility中onCreate()方法初始化：\nexport default class EntryAbility extends UIAbility { onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void { PreferencesUtils.createPreferences(this.context) hilog.info(0x0000, \u0026#39;testTag\u0026#39;, \u0026#39;%{public}s\u0026#39;, \u0026#39;Ability onCreate\u0026#39;) } } import PreferencesUtils from \u0026#39;../common/PreferencesUtil\u0026#39; @Entry @Component struct member { @State text: string = \u0026#39;\u0026#39; aboutToAppear() { this.getAll() } async getAll() { this.text = JSON.stringify(await PreferencesUtils.getAll() as Object) console.log(\u0026#39;getAll\u0026#39;, this.text) } build() { Column() { Text(this.text) .width(\u0026#39;100%\u0026#39;) .height(60) Row() { Button(\u0026#39;get\u0026#39;) .onClick(async () =\u0026gt; { this.text = await PreferencesUtils.get(\u0026#39;userName\u0026#39;) as string }) Button(\u0026#39;getAll\u0026#39;) .onClick(async () =\u0026gt; { this.getAll() }) Button(\u0026#39;put\u0026#39;) .onClick(async () =\u0026gt; { await PreferencesUtils.put(\u0026#39;userName\u0026#39;, \u0026#39;李四\u0026#39;) await PreferencesUtils.put(\u0026#39;age\u0026#39;, 25) await PreferencesUtils.put(\u0026#39;sex\u0026#39;, \u0026#39;女\u0026#39;) this.getAll() }) Button(\u0026#39;delete\u0026#39;) .onClick(async () =\u0026gt; { await PreferencesUtils.delete(\u0026#39;sex\u0026#39;) this.getAll() }) Button(\u0026#39;clear\u0026#39;) .onClick(async () =\u0026gt; { await PreferencesUtils.clear() this.getAll() }) } .width(\u0026#39;100%\u0026#39;) .justifyContent(FlexAlign.Center) }.margin({ top: 50 }) } } 关系型数据库 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/data-persistence-by-rdb-store-0000001505752421-V2\n关系型数据库基于SQLite组件，适用于存储包含复杂关系数据的场景，比如一个班级的学生信息，需要包括姓名、学号、各科成绩等，又或者公司的雇员信息，需要包括姓名、工号、职位等，由于数据之间有较强的对应关系，复杂程度比键值型数据更高，此时需要使用关系型数据库来持久化保存数据。\n谓词：数据库中用来代表数据实体的性质、特征或者数据实体之间关系的词项，主要用来定义数据库的操作条件。 结果集：指用户查询之后的结果集合，可以对数据进行访问。结果集提供了灵活的数据访问方式，可以更方便地拿到用户想要的数据。 关系型数据库对应用提供通用的操作接口，底层使用SQLite作为持久化存储引擎，支持SQLite具有的数据库特性，包括但不限于事务、索引、视图、触发器、外键、参数化查询和预编译SQL语句。\n使用关系型数据库实现数据持久化，需要获取一个RdbStore。示例代码如下所示： import relationalStore from \u0026#39;@ohos.data.relationalStore\u0026#39;; // 导入模块 import UIAbility from \u0026#39;@ohos.app.ability.UIAbility\u0026#39;; class EntryAbility extends UIAbility { onWindowStageCreate(windowStage) { const STORE_CONFIG = { name: \u0026#39;RdbTest.db\u0026#39;, // 数据库文件名 securityLevel: relationalStore.SecurityLevel.S1 // 数据库安全级别 }; const SQL_CREATE_TABLE = \u0026#39;CREATE TABLE IF NOT EXISTS EMPLOYEE (ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB)\u0026#39;; // 建表Sql语句 relationalStore.getRdbStore(this.context, STORE_CONFIG, (err, store) =\u0026gt; { if (err) { console.error(`Failed to get RdbStore. Code:${err.code}, message:${err.message}`); return; } console.info(`Succeeded in getting RdbStore.`); store.executeSql(SQL_CREATE_TABLE); // 创建数据表 // 这里执行数据库的增、删、改、查等操作 }); } } 获取到RdbStore后，调用insert()接口插入数据。示例代码如下所示： const valueBucket = { \u0026#39;NAME\u0026#39;: \u0026#39;Lisa\u0026#39;, \u0026#39;AGE\u0026#39;: 18, \u0026#39;SALARY\u0026#39;: 100.5, \u0026#39;CODES\u0026#39;: new Uint8Array([1, 2, 3, 4, 5]) }; store.insert(\u0026#39;EMPLOYEE\u0026#39;, valueBucket, (err, rowId) =\u0026gt; { if (err) { console.error(`Failed to insert data. Code:${err.code}, message:${err.message}`); return; } console.info(`Succeeded in inserting data. rowId:${rowId}`); }) 关系型数据库没有显式的flush操作实现持久化，数据插入即保存在持久化文件。\n根据谓词指定的实例对象，对数据进行修改或删除。\n调用update()方法修改数据，调用delete()方法删除数据。示例代码如下所示：\n// 修改数据 const valueBucket = { \u0026#39;NAME\u0026#39;: \u0026#39;Rose\u0026#39;, \u0026#39;AGE\u0026#39;: 22, \u0026#39;SALARY\u0026#39;: 200.5, \u0026#39;CODES\u0026#39;: new Uint8Array([1, 2, 3, 4, 5]) }; let predicates = new relationalStore.RdbPredicates(\u0026#39;EMPLOYEE\u0026#39;); // 创建表\u0026#39;EMPLOYEE\u0026#39;的predicates predicates.equalTo(\u0026#39;NAME\u0026#39;, \u0026#39;Lisa\u0026#39;); // 匹配表\u0026#39;EMPLOYEE\u0026#39;中\u0026#39;NAME\u0026#39;为\u0026#39;Lisa\u0026#39;的字段 store.update(valueBucket, predicates, (err, rows) =\u0026gt; { if (err) { console.error(`Failed to update data. Code:${err.code}, message:${err.message}`); return; } console.info(`Succeeded in updating data. row count: ${rows}`); }) // 删除数据 let predicates = new relationalStore.RdbPredicates(\u0026#39;EMPLOYEE\u0026#39;); predicates.equalTo(\u0026#39;NAME\u0026#39;, \u0026#39;Lisa\u0026#39;); store.delete(predicates, (err, rows) =\u0026gt; { if (err) { console.error(`Failed to delete data. Code:${err.code}, message:${err.message}`); return; } console.info(`Delete rows: ${rows}`); }) 根据谓词指定的查询条件查找数据。\n调用query()方法查找数据，返回一个ResultSet结果集。示例代码如下所示：\nlet predicates = new relationalStore.RdbPredicates(\u0026#39;EMPLOYEE\u0026#39;); predicates.equalTo(\u0026#39;NAME\u0026#39;, \u0026#39;Rose\u0026#39;); store.query(predicates, [\u0026#39;ID\u0026#39;, \u0026#39;NAME\u0026#39;, \u0026#39;AGE\u0026#39;, \u0026#39;SALARY\u0026#39;, \u0026#39;CODES\u0026#39;], (err, resultSet) =\u0026gt; { if (err) { console.error(`Failed to query data. Code:${err.code}, message:${err.message}`); return; } console.info(`ResultSet column names: ${resultSet.columnNames}`); console.info(`ResultSet column count: ${resultSet.columnCount}`); }) 当应用完成查询数据操作，不再使用结果集（ResultSet）时，请及时调用close方法关闭结果集，释放系统为其分配的内存。\n删除数据库。\n调用deleteRdbStore()方法，删除数据库及数据库相关文件。示例代码如下\nimport UIAbility from \u0026#39;@ohos.app.ability.UIAbility\u0026#39;; class EntryAbility extends UIAbility { onWindowStageCreate(windowStage) { relationalStore.deleteRdbStore(this.context, \u0026#39;RdbTest.db\u0026#39;, (err) =\u0026gt; { if (err) { console.error(`Failed to delete RdbStore. Code:${err.code}, message:${err.message}`); return; } console.info(\u0026#39;Succeeded in deleting RdbStore.\u0026#39;); }); } } 以下是一个案例, 包含增, 查, 代码很粗糙\n// src/main/ets/utils/DbUtil.ts import common from \u0026#39;@ohos.app.ability.common\u0026#39;; import relationalStore from \u0026#39;@ohos.data.relationalStore\u0026#39;; import { ColumnInfo, ColumnType } from \u0026#39;../type/ColumnInfo\u0026#39;; import Logger from \u0026#39;./Logger\u0026#39;; // 操作的数据库名称 const DB_FILENAME: string = \u0026#39;OliannaWen.db\u0026#39; class DbUtil { // 使用变量来获取关系型数据库操作对象 rdbStore: relationalStore.RdbStore // 初始化数据库 initDB(context: common.UIAbilityContext): Promise\u0026lt;void\u0026gt; { let config: relationalStore.StoreConfig = { // 数据库名称 name: DB_FILENAME, // 数据库操作安全等级 securityLevel: relationalStore.SecurityLevel.S1 } return new Promise\u0026lt;void\u0026gt;((resolve, reject) =\u0026gt; { // 获取关系型数据库操作对象 relationalStore.getRdbStore(context, config) .then(rdbStore =\u0026gt; { this.rdbStore = rdbStore // 记录日志 Logger.debug(\u0026#39;rdbStore 初始化完成！\u0026#39;) resolve() }) .catch(reason =\u0026gt; { Logger.debug(\u0026#39;rdbStore 初始化异常\u0026#39;, JSON.stringify(reason)) reject(reason) }) }) } // 创建表函数，传入创建表语句 createTable(createSQL: string): Promise\u0026lt;void\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { this.rdbStore.executeSql(createSQL) .then(() =\u0026gt; { Logger.debug(\u0026#39;创建表成功\u0026#39;, createSQL) resolve() }) .catch(err =\u0026gt; { Logger.error(\u0026#39;创建表失败,\u0026#39; + err.message, JSON.stringify(err)) reject(err) }) }) } // 建立insert方法的映射关系（实体数据插入到数据库的字段映射） buildValueBucket(obj: any, columns: ColumnInfo[]): relationalStore.ValuesBucket { let value = {} columns.forEach(info =\u0026gt; { let val = obj[info.name] if (typeof val !== \u0026#39;undefined\u0026#39;) { value[info.columnName] = val } }) return value } // 新增方法，参数为表名称和新增对象 insert(tableName: string, obj: any, columns: ColumnInfo[]): Promise\u0026lt;number\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // 1.构建新增数据 let value = this.buildValueBucket(obj, columns) // 2.新增 this.rdbStore.insert(tableName, value, (err, id) =\u0026gt; { if (err) { Logger.error(\u0026#39;新增失败！\u0026#39;, JSON.stringify(err)) reject(err) } else { Logger.debug(\u0026#39;新增成功！新增id：\u0026#39;, id.toString()) resolve(id) } }) }) } // 删除方法,传入删除条件 delete(predicates: relationalStore.RdbPredicates): Promise\u0026lt;number\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { this.rdbStore.delete(predicates, (err, rows) =\u0026gt; { if (err) { Logger.error(\u0026#39;删除失败！\u0026#39;, JSON.stringify(err)) reject(err) } else { Logger.debug(\u0026#39;删除成功！删除行数：\u0026#39;, rows.toString()) resolve(rows) } }) }) } // 查询方法,传入查询条件,字段,返回结果 queryForList\u0026lt;T\u0026gt;(predicates: relationalStore.RdbPredicates, columns: ColumnInfo[]): Promise\u0026lt;T[]\u0026gt; { Logger.debug(\u0026#34;dddfafa\u0026#34;) return new Promise((resolve, reject) =\u0026gt; { this.rdbStore.query(predicates, columns.map(info =\u0026gt; info.columnName), (err, result) =\u0026gt; { if (err) { Logger.error(\u0026#39;查询失败！\u0026#39;, JSON.stringify(err)) reject(err) } else { Logger.debug(\u0026#39;查询成功！查询行数：\u0026#39;, result.rowCount.toString()) resolve(this.parseResultSet(result, columns)) } }) }) } // 解析结果集 parseResultSet\u0026lt;T\u0026gt;(result: relationalStore.ResultSet, columns: ColumnInfo[]): T[] { // 1.声明最终返回的结果 let arr = [] // 2.判断是否有结果 if (result.rowCount \u0026lt;= 0) { return arr } // 3.处理结果 while (!result.isAtLastRow) { // 3.1.去下一行 result.goToNextRow() // 3.2.解析这行数据，转为对象 let obj = {} columns.forEach(info =\u0026gt; { let val = null switch (info.type) { case ColumnType.LONG: val = result.getLong(result.getColumnIndex(info.columnName)) break case ColumnType.DOUBLE: val = result.getDouble(result.getColumnIndex(info.columnName)) break case ColumnType.STRING: val = result.getString(result.getColumnIndex(info.columnName)) break case ColumnType.BLOB: val = result.getBlob(result.getColumnIndex(info.columnName)) break } obj[info.name] = val }) // 3.3.将对象填入结果数组 arr.push(obj) Logger.debug(\u0026#39;查询到数据：\u0026#39;, JSON.stringify(obj)) } return arr } } let dbUtil: DbUtil = new DbUtil(); export default dbUtil as DbUtil // src/main/ets/entryability/EntryAbility.ets async onCreate(want, launchParam) { // 初始化任务表 await DbUtil.initDB(this.context) } import dbUtil from \u0026#39;../utils/DbUtil\u0026#39;; import Logger from \u0026#39;../utils/Logger\u0026#39;; import relationalStore from \u0026#39;@ohos.data.relationalStore\u0026#39;; enum ColumnType { LONG, DOUBLE, STRING, BLOB } interface ColumnInfo { // 实体字段 name: string // 映射到数据库对应的字段 columnName: string // 数据库字段类型 type: ColumnType } interface ValuesBucket { [key: string]: any; } const DB_NAME = \u0026#39;testDB\u0026#39;; const TABLE_NAME = \u0026#39;table1\u0026#39;; const SQL_CREATE_TABLE = ` CREATE TABLE IF NOT EXISTS ${TABLE_NAME} ( ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INTEGER, SALARY REAL, CODES BLOB ) ` const columns: ColumnInfo[] = [ { name: \u0026#39;NAME\u0026#39;, columnName: \u0026#39;NAME\u0026#39;, type: ColumnType.STRING }, { name: \u0026#39;AGE\u0026#39;, columnName: \u0026#39;AGE\u0026#39;, type: ColumnType.LONG }, { name: \u0026#39;SALARY\u0026#39;, columnName: \u0026#39;SALARY\u0026#39;, type: ColumnType.DOUBLE }, { name: \u0026#39;CODES\u0026#39;, columnName: \u0026#39;CODES\u0026#39;, type: ColumnType.BLOB }, ] const valBucket: ValuesBucket = { \u0026#39;NAME\u0026#39;: \u0026#39;John Doe\u0026#39;, \u0026#39;AGE\u0026#39;: 30, \u0026#39;SALARY\u0026#39;: 5000.50, \u0026#39;CODES\u0026#39;: new Uint8Array([1, 2, 3, 4, 5]), }; let predicates = new relationalStore.RdbPredicates(TABLE_NAME); const createTable = async () =\u0026gt; { const res = await dbUtil.createTable(SQL_CREATE_TABLE) Logger.debug(JSON.stringify(res)) } const insertData = async () =\u0026gt; { const res = await dbUtil.insert(TABLE_NAME, valBucket, columns); return res }; const queryData = async () =\u0026gt; { const res = await dbUtil.queryForList(predicates, columns) Logger.debug(JSON.stringify(res)) } export { createTable, insertData, queryData } import { createTable, insertData, queryData } from \u0026#39;../viewmodel/useDb\u0026#39; @Entry @Component struct Index { build() { Column({ space: 10 }) { Button(\u0026#34;Create\u0026#34;) .onClick(() =\u0026gt; { createTable() }) Button(\u0026#34;Insert\u0026#34;) .onClick(async () =\u0026gt; { insertData() }) Button(\u0026#34;Query\u0026#34;) .onClick(async () =\u0026gt; { await queryData() }) } .width(\u0026#39;100%\u0026#39;) } } 通知 基础通知 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V3/notification-guidelines-0000001281360946-V3\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-references-V3/js-apis-notification-0000001333321097-V3\n名称 值 说明 NOTIFICATION_CONTENT_BASIC_TEXT ContentType 普通类型通知。 NOTIFICATION_CONTENT_LONG_TEXT ContentType 长文本类型通知。 NOTIFICATION_CONTENT_PICTURE ContentType 图片类型通知。 NOTIFICATION_CONTENT_CONVERSATION ContentType 社交类型通知。 NOTIFICATION_CONTENT_MULTILINE ContentType 多行文本类型通知。 系统能力：以下各项对应的系统能力均为SystemCapability.Notification.Notification\n名称 可读 可写 类型 必填 描述 content 是 是 NotificationContent 是 通知内容。 id 是 是 number 否 通知ID。 slotType 是 是 SlotType 否 通道类型。 isOngoing 是 是 boolean 否 是否进行时通知。 isUnremovable 是 是 boolean 否 是否可移除。 deliveryTime 是 是 number 否 通知发送时间。 tapDismissed 是 是 boolean 否 通知是否自动清除。 autoDeletedTime 是 是 number 否 自动清除的时间。 wantAgent 是 是 WantAgent 否 点击跳转的WantAgent。 extraInfo 是 是 {[key: string]: any} 否 扩展参数。 color 是 是 number 否 通知背景颜色。 colorEnabled 是 是 boolean 否 通知背景颜色是否使能。 isAlertOnce 是 是 boolean 否 设置是否仅有一次此通知警报。 isStopwatch 是 是 boolean 否 是否显示已用时间。 isCountDown 是 是 boolean 否 是否显示倒计时时间。 isFloatingIcon 是 是 boolean 否 是否显示状态栏图标。 label 是 是 string 否 通知标签。 badgeIconStyle 是 是 number 否 通知角标类型。 showDeliveryTime 是 是 boolean 否 是否显示分发时间。 actionButtons 是 是 Array\u0026lt;NotificationActionButton\u0026gt; 否 通知按钮，最多两个按钮。 smallIcon 是 是 PixelMap 否 通知小图标。 largeIcon 是 是 PixelMap 否 通知大图标。 creatorBundleName 是 否 string 否 创建通知的包名。 creatorUid 是 否 number 否 创建通知的UID。 creatorPid 是 否 number 否 创建通知的PID。 creatorUserId8+ 是 否 number 否 创建通知的UserId。 hashCode 是 否 string 否 通知唯一标识。 groupName8+ 是 是 string 否 组通知名称。 template8+ 是 是 NotificationTemplate 否 通知模板。 distributedOption8+ 是 是 DistributedOptions 否 分布式通知的选项。 notificationFlags8+ 是 否 NotificationFlags 否 获取NotificationFlags。 import notify from \u0026#39;@ohos.notificationManager\u0026#39; import image from \u0026#39;@ohos.multimedia.image\u0026#39; @Entry @Component struct Index { // 全局任务 id idx: number = 100 // 图像 pixel: PixelMap async aboutToAppear() { // 获取资源管理器 let rm = getContext(this).resourceManager // 读取图片 let file = await rm.getMediaContent($r(\u0026#39;app.media.watchGT4\u0026#39;)) // 创建 PixelMap image.createImageSource(file.buffer).createPixelMap() .then(value =\u0026gt; this.pixel = value) .catch(reason =\u0026gt; console.error(reason)) } build() { Column({ space: 10 }) { Button(`发送normalText通知`) .onClick(() =\u0026gt; this.publishNormalTextNotification()) Button(`发送longText通知`) .onClick(() =\u0026gt; this.publishLongTextNotification()) Button(`发送multiLine通知`) .onClick(() =\u0026gt; this.publishMultiLineNotification()) Button(`发送Picture通知`) .onClick(() =\u0026gt; this.publishPictureNotification()) } .width(\u0026#39;100%\u0026#39;) } publishNormalTextNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39; } }, showDeliveryTime: true, deliveryTime: new Date().getTime(), groupName: \u0026#39;wechat\u0026#39;, slotType: notify.SlotType.SOCIAL_COMMUNICATION } this.publish(request) } publishLongTextNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_LONG_TEXT, longText: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39;, longText: \u0026#39;通知中的长文本，我很长，我很长，我很长，我很长，我很长，我很长，我很长\u0026#39;, briefText: \u0026#39;通知概要和总结\u0026#39;, expandedTitle: \u0026#39;通知展开时的标题\u0026#39; + this.idx } } } this.publish(request) } publishMultiLineNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_MULTILINE, multiLine: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39;, briefText: \u0026#39;通知概要和总结\u0026#39;, longTitle: \u0026#39;展开时的标题，我很宽，我很宽，我很宽\u0026#39;, lines: [ \u0026#39;第一行\u0026#39;, \u0026#39;第二行\u0026#39;, \u0026#39;第三行\u0026#39;, \u0026#39;第四行\u0026#39;, ] } } } this.publish(request) } publishPictureNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_PICTURE, picture: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39;, briefText: \u0026#39;通知概要和总结\u0026#39;, expandedTitle: \u0026#39;展开后标题\u0026#39; + this.idx, picture: this.pixel } } } this.publish(request) } private publish(request: notify.NotificationRequest) { notify.publish(request) .then(() =\u0026gt; console.log(\u0026#39;notify test\u0026#39;, \u0026#39;发送通知成功\u0026#39;)) .then(reason =\u0026gt; console.log(\u0026#39;notify test\u0026#39;, \u0026#39;发送通知失败\u0026#39;, JSON.stringify(reason))) } } 进度条通知 import Notification from \u0026#39;@ohos.notificationManager\u0026#39; import wantAgent, { WantAgent } from \u0026#39;@ohos.app.ability.wantAgent\u0026#39; import promptAction from \u0026#39;@ohos.promptAction\u0026#39; import Prompt from \u0026#39;@system.prompt\u0026#39; enum DownloadState { NOT_BEGIN = \u0026#39;未开始\u0026#39;, DOWNLOADING = \u0026#39;下载中\u0026#39;, PAUSE = \u0026#39;已暂停\u0026#39;, FINISHED = \u0026#39;已完成\u0026#39;, } @Entry @Component struct Index { // 下载进度 @State progressValue: number = 0 progressMaxValue: number = 100 // 任务状态 @State state: DownloadState = DownloadState.NOT_BEGIN // 下载的文件名 filename: string = \u0026#39;圣诞星.mp4\u0026#39; // 模拟下载的任务的id taskId: number = -1 // 通知id notificationId: number = 999 isSupport: boolean = false wantAgentInstance: WantAgent async aboutToAppear() { // 1.判断当前系统是否支持进度条模板 this.isSupport = await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;) // 2.创建拉取当前应用的行为意图 // 2.1.创建wantInfo信息 let wantInfo: wantAgent.WantAgentInfo = { wants: [ { bundleName: \u0026#39;com.example.myapplication\u0026#39;, abilityName: \u0026#39;EntryAbility\u0026#39;, } ], requestCode: 0, operationType: wantAgent.OperationType.START_ABILITY, wantAgentFlags: [wantAgent.WantAgentFlags.CONSTANT_FLAG] } // 2.2.创建wantAgent实例 this.wantAgentInstance = await wantAgent.getWantAgent(wantInfo) } build() { Row({ space: 10 }) { Image($r(\u0026#39;app.media.ic_files_video\u0026#39;)).width(50) Column({ space: 5 }) { Row() { Text(this.filename) Text(`${this.progressValue}%`).fontColor(\u0026#39;#c1c2c1\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .justifyContent(FlexAlign.SpaceBetween) Progress({ value: this.progressValue, total: this.progressMaxValue, }) Row({ space: 5 }) { Text(`${(this.progressValue * 0.43).toFixed(2)}MB`) .fontSize(14).fontColor(\u0026#39;#c1c2c1\u0026#39;) Blank() if (this.state === DownloadState.NOT_BEGIN) { Button(\u0026#39;开始\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.download()) } else if (this.state === DownloadState.DOWNLOADING) { Button(\u0026#39;取消\u0026#39;).downloadButton().backgroundColor(\u0026#39;#d1d2d3\u0026#39;) .onClick(() =\u0026gt; this.cancel()) Button(\u0026#39;暂停\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.pause()) } else if (this.state === DownloadState.PAUSE) { Button(\u0026#39;取消\u0026#39;).downloadButton().backgroundColor(\u0026#39;#d1d2d3\u0026#39;) .onClick(() =\u0026gt; this.cancel()) Button(\u0026#39;继续\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.download()) } else { Button(\u0026#39;打开\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.open()) } }.width(\u0026#39;100%\u0026#39;) } .layoutWeight(1) } .width(\u0026#39;100%\u0026#39;) .borderRadius(20) .padding(15) .backgroundColor(Color.White) } cancel() { // 取消定时任务 if (this.taskId \u0026gt; 0) { clearInterval(this.taskId); this.taskId = -1 } console.log(this.notificationId.toString()) // 清理下载任务进度 this.progressValue = 0 // 标记任务状态：未开始 this.state = DownloadState.NOT_BEGIN // 取消通知 Notification.cancel(this.notificationId).then((response) =\u0026gt; { console.log(\u0026#39;ssssss\u0026#39;, JSON.stringify(response)) }) } download() { // 清理旧任务 if (this.taskId \u0026gt; 0) { clearInterval(this.taskId); } // 开启定时任务，模拟下载 this.taskId = setInterval(() =\u0026gt; { // 判断任务进度是否达到100 if (this.progressValue \u0026gt;= 100) { // 任务完成了，应该取消定时任务 clearInterval(this.taskId) this.taskId = -1 // 并且标记任务状态为已完成 this.state = DownloadState.FINISHED // 发送通知 this.publishProgressNotification() return } // 模拟任务进度变更 this.progressValue += 2 // 发送通知 this.publishProgressNotification() }, 500) // 标记任务状态：下载中 this.state = DownloadState.DOWNLOADING } pause() { // 取消定时任务 if (this.taskId \u0026gt; 0) { clearInterval(this.taskId); this.taskId = -1 } // 标记任务状态：已暂停 this.state = DownloadState.PAUSE // 发送通知 this.publishProgressNotification() } open() { promptAction.showToast({ message: \u0026#39;功能未实现\u0026#39; }) } async publishProgressNotification() { let isSupportTpl: boolean; await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;).then((data) =\u0026gt; { isSupportTpl = data; }).catch((err) =\u0026gt; { Prompt.showToast({ message: `判断是否支持进度条模板时报错,error[${err}]`, duration: 2000 }) }) if (isSupportTpl) { // 构造模板 let template = { name: \u0026#39;downloadTemplate\u0026#39;, data: { progressValue: this.progressValue, // 当前进度值 progressMaxValue: this.progressMaxValue // 最大进度值 } }; let notificationRequest: Notification.NotificationRequest = { id: this.notificationId, content: { contentType: Notification.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: this.filename + \u0026#39;: \u0026#39; + this.state, text: \u0026#39;\u0026#39;, additionalText: this.progressValue + \u0026#39;%\u0026#39; } }, template: template }; // 发布通知 Notification.publish(notificationRequest).then(() =\u0026gt; { Prompt.showToast({ message: `发布通知成功！`, duration: 2000 }) }).catch((err) =\u0026gt; { Prompt.showToast({ message: `发布通知失败,error[${err}]`, duration: 2000 }) }) } else { Prompt.showToast({ message: \u0026#39;不支持downloadTemplate进度条通知模板\u0026#39;, duration: 2000 }) } } publishDownloadNotification() { // 1.判断当前系统是否支持进度条模板 if (!this.isSupport) { // 当前系统不支持进度条模板 console.log(\u0026#34;not support\u0026#34;) return } // 2.准备进度条模板的参数 let template = { name: \u0026#39;downloadTemplate\u0026#39;, data: { progressValue: this.progressValue, progressMaxValue: this.progressMaxValue } } let request: Notification.NotificationRequest = { id: this.notificationId, template: template, wantAgent: this.wantAgentInstance, content: { contentType: Notification.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: this.filename + \u0026#39;: \u0026#39; + this.state, text: \u0026#39;\u0026#39;, additionalText: this.progressValue + \u0026#39;%\u0026#39; } } } // 3.发送通知 Notification.publish(request) .then(() =\u0026gt; console.log(\u0026#39;test\u0026#39;, \u0026#39;通知发送成功\u0026#39;)) .catch(reason =\u0026gt; console.log(\u0026#39;test\u0026#39;, \u0026#39;通知发送失败！\u0026#39;, JSON.stringify(reason))) } } @Extend(Button) function downloadButton() { .width(75).height(28).fontSize(14) } 通知意图 具体参数看官方文档\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/js-apis-app-ability-wantagent-0000001493424324-V2\n​ async aboutToAppear() { // 1.判断当前系统是否支持进度条模板 this.isSupport = await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;) // 2.创建拉取当前应用的行为意图 // 2.1.创建wantInfo信息 let wantInfo: wantAgent.WantAgentInfo = { wants: [ { bundleName: \u0026#39;com.example.learn_2\u0026#39;, abilityName: \u0026#39;EntryAbility\u0026#39;, } ], requestCode: 0, operationType: wantAgent.OperationType.START_ABILITY, wantAgentFlags: [wantAgent.WantAgentFlags.CONSTANT_FLAG] } // 2.2.创建wantAgent实例 this.wantAgentInstance = await wantAgent.getWantAgent(wantInfo) } async publishProgressNotification() { let isSupportTpl: boolean; await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;).then((data) =\u0026gt; { isSupportTpl = data; }).catch((err) =\u0026gt; { Prompt.showToast({ message: `判断是否支持进度条模板时报错,error[${err}]`, duration: 2000 }) }) if (isSupportTpl) { // 构造模板 let template = { name: \u0026#39;downloadTemplate\u0026#39;, data: { progressValue: this.progressValue, // 当前进度值 progressMaxValue: this.progressMaxValue // 最大进度值 } }; let notificationRequest: Notification.NotificationRequest = { id: this.notificationId, wantAgent: this.wantAgentInstance, content: { contentType: Notification.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: this.filename + \u0026#39;: \u0026#39; + this.state, text: \u0026#39;\u0026#39;, additionalText: this.progressValue + \u0026#39;%\u0026#39; } }, template: template }; // 发布通知 Notification.publish(notificationRequest).then(() =\u0026gt; { Prompt.showToast({ message: `发布通知成功！`, duration: 2000 }) }).catch((err) =\u0026gt; { Prompt.showToast({ message: `发布通知失败,error[${err}]`, duration: 2000 }) }) } else { Prompt.showToast({ message: \u0026#39;不支持downloadTemplate进度条通知模板\u0026#39;, duration: 2000 }) } } ","permalink":"https://waite.wang/posts/harmony/learn-harmony-3/","summary":"\u003ch2 id=\"stage-模型\"\u003eStage 模型\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/start-with-ets-stage-0000001477980905-V2\"\u003ehttps://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/start-with-ets-stage-0000001477980905-V2\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202404271535958.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202404271535958.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e一个应用只能有一个 @EntryAbility，但可以有多个 @PageAbility。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"stage模型目录结构\"\u003e（Stage模型）目录结构\u003c/h3\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202404181340550.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202404181340550.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAppScope \u0026gt; app.json5：应用的全局配置信息。\u003c/li\u003e\n\u003cli\u003eentry：HarmonyOS工程模块，编译构建生成一个HAP包。\n\u003cul\u003e\n\u003cli\u003esrc \u0026gt; main \u0026gt; ets：用于存放ArkTS源码。\nsrc \u0026gt; main \u0026gt; ets \u0026gt; entryability：应用/服务的入口。\u003c/li\u003e\n\u003cli\u003esrc \u0026gt; main \u0026gt; ets \u0026gt; pages：应用/服务包含的页面\u003c/li\u003e\n\u003cli\u003esrc \u0026gt; main \u0026gt; resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。\u003c/li\u003e\n\u003cli\u003esrc \u0026gt; main \u0026gt; module.json5：Stage模型模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见\u003ca href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/module-configuration-file-0000001427744540-V2\"\u003emodule.json5配置文件\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003ebuild-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。\u003c/li\u003e\n\u003cli\u003ehvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eoh_modules：用于存放三方库依赖信息。关于原npm工程适配ohpm操作，请参考历史工程迁移。\u003c/li\u003e\n\u003cli\u003ebuild-profile.json5：应用级配置信息，包括签名、产品配置等。\u003c/li\u003e\n\u003cli\u003ehvigorfile.ts：应用级编译构建任务脚本。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"应用配置文件\"\u003e应用配置文件\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/14d_u7f6e_u6587_u4ef6_uff08stage_u6a21_u578b_uff09-0000001427902192-V2\"\u003ehttps://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/14d_u7f6e_u6587_u4ef6_uff08stage_u6a21_u578b_uff09-0000001427902192-V2\u003c/a\u003e\u003c/p\u003e","title":"鸿蒙学习笔记3"},{"content":"页面路由 页面路由指在应用程序中实现不同页面之间的跳转和数据传递。HarmonyOS提供了Router模块，通过不同的url地址，可以方便地进行页面路由，轻松地访问不同的页面。\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-routing-0000001503325125-V2#section6414655195312\n页面跳转 页面跳转是开发过程中的一个重要组成部分。在使用应用程序时，通常需要在不同的页面之间跳转，有时还需要将数据从一个页面传递到另一个页面。\nRouter模块提供了两种跳转模式，分别是router.pushUrl()和router.replaceUrl()。这两种模式决定了目标页是否会替换当前页。\nrouter.pushUrl()：目标页不会替换当前页，而是压入页面栈。这样可以保留当前页的状态，并且可以通过返回键或者调用router.back()方法返回到当前页。 router.replaceUrl()：目标页会替换当前页，并销毁当前页。这样可以释放当前页的资源，并且无法返回到当前页。 页面栈的最大容量为32个页面。如果超过这个限制，可以调用router.clear()方法清空历史页面栈，释放内存空间。\n同时，Router模块提供了两种实例模式，分别是Standard和Single。这两种模式决定了目标url是否会对应多个实例。\nStandard：标准实例模式，也是默认情况下的实例模式。每次调用该方法都会新建一个目标页，并压入栈顶。\nSingle：单实例模式。即如果目标页的url在页面栈中已经存在同url页面，则离栈顶最近的同url页面会被移动到栈顶，并重新加载；如果目标页的url在页面栈中不存在同url页面，则按照标准模式跳转。\n在使用页面路由Router相关功能之前，需要在代码中先导入Router模块。\nimport router from \u0026#39;@ohos.router\u0026#39;; 场景一：有一个主页（Home）和一个详情页（Detail），希望从主页点击一个商品，跳转到详情页。同时，需要保留主页在页面栈中，以便返回时恢复状态。这种场景下，可以使用pushUrl()方法，并且使用Standard实例模式（或者省略）。\n// 在Home页面中 function onJumpClick(): void { router.pushUrl({ url: \u0026#39;pages/Detail\u0026#39; // 目标url }, router.RouterMode.Standard, (err) =\u0026gt; { if (err) { console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`); return; } console.info(\u0026#39;Invoke pushUrl succeeded.\u0026#39;); }); } 标准实例模式下，router.RouterMode.Standard参数可以省略。\n场景二：有一个登录页（Login）和一个个人中心页（Profile），希望从登录页成功登录后，跳转到个人中心页。同时，销毁登录页，在返回时直接退出应用。这种场景下，可以使用replaceUrl()方法，并且使用Standard实例模式（或者省略）。\n// 在Login页面中 function onJumpClick(): void { router.replaceUrl({ url: \u0026#39;pages/Profile\u0026#39; // 目标url }, router.RouterMode.Standard, (err) =\u0026gt; { if (err) { console.error(`Invoke replaceUrl failed, code is ${err.code}, message is ${err.message}`); return; } console.info(\u0026#39;Invoke replaceUrl succeeded.\u0026#39;); }) } 场景三：有一个设置页（Setting）和一个主题切换页（Theme），希望从设置页点击主题选项，跳转到主题切换页。同时，需要保证每次只有一个主题切换页存在于页面栈中，在返回时直接回到设置页。这种场景下，可以使用pushUrl()方法，并且使用Single实例模式。\n// 在Setting页面中 function onJumpClick(): void { router.pushUrl({ url: \u0026#39;pages/Theme\u0026#39; // 目标url }, router.RouterMode.Single, (err) =\u0026gt; { if (err) { console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`); return; } console.info(\u0026#39;Invoke pushUrl succeeded.\u0026#39;); }); } 场景四：有一个搜索结果列表页（SearchResult）和一个搜索结果详情页（SearchDetail），希望从搜索结果列表页点击某一项结果，跳转到搜索结果详情页。同时，如果该结果已经被查看过，则不需要再新建一个详情页，而是直接跳转到已经存在的详情页。这种场景下，可以使用replaceUrl()方法，并且使用Single实例模式。\n// 在SearchResult页面中 function onJumpClick(): void { router.replaceUrl({ url: \u0026#39;pages/SearchDetail\u0026#39; // 目标url }, router.RouterMode.Single, (err) =\u0026gt; { if (err) { console.error(`Invoke replaceUrl failed, code is ${err.code}, message is ${err.message}`); return; } console.info(\u0026#39;Invoke replaceUrl succeeded.\u0026#39;);}) } 传递参数 如果需要在跳转时传递一些数据给目标页，则可以在调用Router模块的方法时，添加一个params属性，并指定一个对象作为参数。例如：\nclass DataModelInfo { age: number; } class DataModel { id: number; info: DataModelInfo; } function onJumpClick(): void { // 在Home页面中 let paramsInfo: DataModel = { id: 123, info: { age: 20 } }; router.pushUrl({ url: \u0026#39;pages/Detail\u0026#39;, // 目标url params: paramsInfo // 添加params属性，传递自定义参数 }, (err) =\u0026gt; { if (err) { console.error(`Invoke pushUrl failed, code is ${err.code}, message is ${err.message}`); return; } console.info(\u0026#39;Invoke pushUrl succeeded.\u0026#39;); }) } 在目标页中，可以通过调用Router模块的getParams()方法来获取传递过来的参数。例如：\nconst params = router.getParams(); // 获取传递过来的参数对象 const id = params[\u0026#39;id\u0026#39;]; // 获取id属性的值 const age = params[\u0026#39;info\u0026#39;].age; // 获取age属性的值 页面返回 当用户在一个页面完成操作后，通常需要返回到上一个页面或者指定页面，这就需要用到页面返回功能。在返回的过程中，可能需要将数据传递给目标页，这就需要用到数据传递功能。\n方式一：返回到上一个页面。\nrouter.back(); 这种方式会返回到上一个页面，即上一个页面在页面栈中的位置。但是，上一个页面必须存在于页面栈中才能够返回，否则该方法将无效。\n方式二：返回到指定页面。\nrouter.back({ url: \u0026#39;pages/Home\u0026#39; }); 这种方式可以返回到指定页面，需要指定目标页的路径。目标页必须存在于页面栈中才能够返回。\n方式三：返回到指定页面，并传递自定义参数信息。\nrouter.back({ url: \u0026#39;pages/Home\u0026#39;, params: { info: \u0026#39;来自Home页\u0026#39; } }); 这种方式不仅可以返回到指定页面，还可以在返回的同时传递自定义参数信息。这些参数信息可以在目标页中通过调用router.getParams()方法进行获取和解析。\n在目标页中，在需要获取参数的位置调用router.getParams()方法即可，例如在onPageShow()生命周期回调中：\nonPageShow() { const params = router.getParams(); // 获取传递过来的参数对象 const info = params[\u0026#39;info\u0026#39;]; // 获取info属性的值 } 自定义询问框 自定义询问框的方式，可以使用弹窗或者自定义弹窗实现。这样可以让应用界面与系统默认询问框有所区别，提高应用的用户体验度。本文以弹窗为例，介绍如何实现自定义询问框。\n在事件回调中，调用弹窗的promptAction.showDialog()方法：\nfunction onBackClick() { // 弹出自定义的询问框 promptAction.showDialog({ message: \u0026#39;您还没有完成支付，确定要返回吗？\u0026#39;, buttons: [ { text: \u0026#39;取消\u0026#39;, color: \u0026#39;#FF0000\u0026#39; }, { text: \u0026#39;确认\u0026#39;, color: \u0026#39;#0099FF\u0026#39; } ] }).then((result) =\u0026gt; { if (result.index === 0) { // 用户点击了“取消”按钮 console.info(\u0026#39;User canceled the operation.\u0026#39;); } else if (result.index === 1) { // 用户点击了“确认”按钮 console.info(\u0026#39;User confirmed the operation.\u0026#39;); // 调用router.back()方法，返回上一个页面 router.back(); } }).catch((err) =\u0026gt; { console.error(`Invoke showDialog failed, code is ${err.code}, message is ${err.message}`); }) } 状态管理 在声明式UI编程框架中，UI是程序状态的运行结果，用户构建了一个UI模型，其中应用的运行时的状态是参数。当参数改变时，UI作为返回结果，也将进行对应的改变。这些运行时的状态变化所带来的UI的重新渲染，在ArkUI中统称为状态管理机制。\n自定义组件拥有变量，变量必须被装饰器装饰才可以成为状态变量，状态变量的改变会引起UI的渲染刷新。如果不使用状态变量，UI只能在初始化时渲染，后续将不会再刷新。 下图展示了State和View（UI）之间的关系。\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-state-management-overview-0000001524537145-V2\nView(UI)：UI渲染，指将build方法内的UI描述和@Builder装饰的方法内的UI描述映射到界面。\nState：状态，指驱动UI更新的数据。用户通过触发组件的事件方法，改变状态数据。状态数据的改变，引起UI的重新渲染。\n基本概念 状态变量：被状态装饰器装饰的变量，状态变量值的改变会引起UI的渲染更新。示例：@State num: number = 1,其中，@State是状态装饰器，num是状态变量。 常规变量：没有被状态装饰器装饰的变量，通常应用于辅助计算。它的改变永远不会引起UI的刷新。以下示例中increaseBy变量为常规变量。 数据源/同步源：状态变量的原始来源，可以同步给不同的状态数据。通常意义为父组件传给子组件的数据。以下示例中数据源为count: 1。 命名参数机制：父组件通过指定参数传递给子组件的状态变量，为父子传递同步参数的主要手段。示例：CompA: ({ aProp: this.aProp })。 从父组件初始化：父组件使用命名参数机制，将指定参数传递给子组件。子组件初始化的默认值在有父组件传值的情况下，会被覆盖。示例： @Component struct MyComponent { @State count: number = 0; private increaseBy: number = 1; build() { } } @Component struct Parent { build() { Column() { // 从父组件初始化，覆盖本地定义的默认值 MyComponent({ count: 1, increaseBy: 2 }) } } } 初始化子节点：父组件中状态变量可以传递给子组件，初始化子组件对应的状态变量。示例同上。\n本地初始化：在变量声明的时候赋值，作为变量的默认值。示例：@State count: number = 0。\n管理组件拥有的状态 @State装饰器：组件内状态 @state 装饰器标记的变量必须初始化, 不能为空值\n@state 支持Object、class、string、number、boolean、enum类型，以及这些类型的数组。不支持any，不支持简单类型和复杂类型的联合类型，不允许使用undefined和null。\n嵌套类型以及数组中的对象属性无法触发视图更新\nclass Person { name: string age: number gf: Person constructor(name: string, age: number, gf?: Person) { this.age = age this.name = name this.gf = gf } } @Entry @Component struct Second { @State p: Person = new Person(\u0026#39;jack\u0026#39;, 21, new Person(\u0026#39;aaa\u0026#39;, 11)) build() { Column() { Text(`${this.p.name}: ${this.p.age}`) .fontSize(50) .onClick(() =\u0026gt; { this.p.age ++ }) Text(`${this.p.gf.name}: ${this.p.gf.age}`) .fontSize(50) .onClick(() =\u0026gt; { console.log(`${this.p.gf.name}: ${this.p.gf.age}`) this.p.gf.age ++ }) } .width(\u0026#34;100%\u0026#34;) } } 当点击下面时，不会触发视图更新, 只有点击上面非嵌套属性时才会触发视图整体更新\n@State装饰的变量，或称为状态变量，一旦变量拥有了状态属性，就和自定义组件的渲染绑定起来。当状态改变时，UI会发生对应的渲染改变。\n在状态变量相关装饰器中，@State是最基础的，使变量拥有状态属性的装饰器，它也是大部分状态变量的数据源。\n@State装饰的变量，与声明式范式中的其他被装饰变量一样，是私有的，只能从组件内部访问，在声明时必须指定其类型和本地初始化。初始化也可选择使用命名参数机制从父组件完成初始化。\n@State装饰的变量拥有以下特点：\n@State装饰的变量与子组件中的@Prop装饰变量之间建立单向数据同步，与@Link、@ObjectLink装饰变量之间建立双向数据同步。 @State装饰的变量生命周期与其所属自定义组件的生命周期相同。 案例 class Task { static id: number = 1 name: string = `Task${Task.id++}` finished: boolean = false } @Styles function card() { .width(\u0026#34;95%\u0026#34;) .padding(20) .backgroundColor(Color.White) .borderRadius(15) .shadow( { radius: 6, color: \u0026#34;#1F000000\u0026#34;, offsetX: 2, offsetY: 4 } ) } @Extend(Text) function finishedTask() { .decoration({ type: TextDecorationType.LineThrough }) .fontSize(\u0026#34;##B1B2B1\u0026#34;) } @Entry @Component struct Second { @State totalTask: number = 0 @State finishTask: number = 0 @State task: Task[] = [] handTaskChange() { this.totalTask = this.task.length this.finishTask = this.task.filter(item =\u0026gt; item.finished).length } build() { Column({ space: 10 }) { // 任务进度卡片 Row() { Text(\u0026#34;任务进度: \u0026#34;) .fontSize(30) .fontWeight(FontWeight.Bold) Stack() { Progress({ value: this.finishTask, total: this.totalTask, type: ProgressType.Ring }) .width(100) Row() { Text(this.finishTask.toString()) .fontSize(24) .fontColor(\u0026#34;#36D\u0026#34;) Text(\u0026#34;/\u0026#34; + this.totalTask.toString()) .fontSize(24) } } } .card() .margin({ top: 20, bottom: 10 }) .justifyContent(FlexAlign.SpaceEvenly) // 新增任务按钮 Button(\u0026#34;添加任务\u0026#34;) .width(200) .onClick(() =\u0026gt; { this.task.push(new Task()) this.handTaskChange() }) // 渲染任务列表 List({ space: 10 }) { ForEach( this.task, (item: Task, index) =\u0026gt; { ListItem() { Row() { Text(item.name) .fontSize(24) Checkbox() .select(item.finished) .onChange(value =\u0026gt; { item.finished = value this.handTaskChange() }) } .card() .justifyContent(FlexAlign.SpaceBetween) } .swipeAction({ end: this.DeleteButton(index) }) } ) } .width(\u0026#34;100%\u0026#34;) .alignListItem(ListItemAlign.Center) .layoutWeight(1) } .width(\u0026#34;100%\u0026#34;) .height(\u0026#34;100%\u0026#34;) .backgroundColor(\u0026#34;#F1F2F3\u0026#34;) } // 构建函数 @Builder DeleteButton(index: number) { Text(\u0026#34;Del\u0026#34;) .fontColor(Color.White) .padding(20) .backgroundColor(Color.Red) .borderRadius(\u0026#34;50%\u0026#34;) .margin(5) .onClick(() =\u0026gt; { this.task.splice(index, 1) this.handTaskChange() }) } } @Prop/ @Link 装饰器 @Prop 父子组件单向同步: @Prop装饰的变量可以和父组件建立单向的同步关系。@Prop装饰的变量是可变的，但是变化不会同步回其父组件。 @Link 父子组件双向同步: 子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。@Link装饰的变量与其父组件中的数据源共享相同的值。\n在最新版本中, @Prop 可以在子组件初始化, 但是编辑器 eslint 会报错\n@Component struct Child { @Prop value: number; build() { Text(`${this.value}`) .fontSize(50) .onClick(() =\u0026gt; { console.log(`${this.value}`) this.value++ }) } } @Entry @Component struct Index { @State arr: number[] = [1, 2, 3]; build() { Row() { Column() { Child({ value: this.arr[0] }) Child({ value: this.arr[1] }) Child({ value: this.arr[2] }) Divider().height(5) ForEach(this.arr, item =\u0026gt; { Child({ \u0026#39;value\u0026#39;: item } as Record\u0026lt;string, number\u0026gt;) }, item =\u0026gt; item.toString() ) Text(\u0026#39;replace entire arr\u0026#39;) .fontSize(50) .onClick(() =\u0026gt; { // 两个数组都包含项“3”。 this.arr = this.arr[0] == 1 ? [3, 4, 5] : [1, 2, 3]; }) } } } } 如果点击界面上的“1”六次、“2”五次、“3”四次，将所有变量的本地取值都变为“7”。\n7 7 7 ---- 7 7 7 单击replace entire arr后，屏幕将显示以下信息，为什么？\n3 4 5 ---- 7 4 5 在子组件Child中做的所有的修改都不会同步回父组件Index组件，所以即使6个组件显示都为7，但在父组件Index中，this.arr保存的值依旧是[1,2,3]。 点击replace entire arr，this.arr[0] == 1成立，将this.arr赋值为[3, 4, 5]； 因为this.arr[0]已更改，Child({value: this.arr[0]})组件将this.arr[0]更新同步到实例@Prop装饰的变量。Child({value: this.arr[1]})和Child({value: this.arr[2]})的情况也类似。 this.arr的更改触发ForEach更新，this.arr更新的前后都有数值为3的数组项：[3, 4, 5] 和[1, 2, 3]。根据diff算法，数组项“3”将被保留，删除“1”和“2”的数组项，添加为“4”和“5”的数组项。这就意味着，数组项“3”的组件不会重新生成，而是将其移动到第一位。所以“3”对应的组件不会更新，此时“3”对应的组件数值为“7”，ForEach最终的渲染结果是“7”，“4”，“5”。 diff算法是一种用于比较两个数据结构（比如两个数组或两个树）之间差异的算法。在前端开发中，diff算法通常用于虚拟DOM的更新和渲染优化。\n在React等前端框架中，当数据发生变化时，diff算法可以帮助确定哪些DOM节点需要被更新，哪些需要被添加或删除，以及哪些可以被保留而不进行重新渲染。这可以提高性能并减少不必要的DOM操作。\ndiff算法通常包括以下步骤：\n比较两个数据结构的差异，找出新增、删除和更新的部分。 标记需要进行更新的部分，并记录其变化。 应用这些变化，更新DOM或其他视图。 @Styles function btn() { .margin(12) .width(312) .height(40) } @Component struct Child { @Link items: number[]; build() { Column() { Button(`Button1: push`) .btn() .onClick(() =\u0026gt; { this.items.push(this.items.length + 1); }) Button(`Button2: replace whole item`) .btn() .onClick(() =\u0026gt; { this.items = [100, 200, 300]; }) } } } @Entry @Component struct Parent { @State arr: number[] = [1, 2, 3]; build() { Column() { Button(\u0026#39;Button Parent push\u0026#39;) .btn() .onClick(() =\u0026gt; { this.arr.push(this.arr.length + 1); }) Child({ items: $arr }) .margin(12) ForEach(this.arr, (item: number) =\u0026gt; { Button(`${item}`) .margin(12) .width(312) .height(40) .backgroundColor(\u0026#39;#11a2a2a2\u0026#39;) .fontColor(\u0026#39;#e6000000\u0026#39;) }, (item: ForEachInterface) =\u0026gt; item.toString() ) } } } @Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化 上文所述的装饰器仅能观察到第一层的变化，但是在实际应用开发中，应用会根据开发需要，封装自己的数据模型。对于多层嵌套的情况，比如二维数组，或者数组项class，或者class的属性是class，他们的第二层的属性变化是无法观察到的。这就引出了@Observed/@ObjectLink装饰器。\n以下是引入@Observed/@ObjectLink装饰器的示例：\n@Observed class Person { name: string age: number gf: Person constructor(name: string, age: number, gf?: Person) { this.name = name this.age = age this.gf = gf } } @Entry @Component struct Child { @State p: Person = new Person(\u0026#34;Waite\u0026#34;, 18, new Person(\u0026#34;www\u0026#34;, 11)) @State gfs: Person[] = [ new Person(\u0026#34;Jack\u0026#34;, 18), new Person(\u0026#34;XiaoMing\u0026#34;, 20) ] build() { Column({ space: 10 }) { PersonChild({ p: this.p.gf }) .onClick(() =\u0026gt; { console.log(`${this.p.gf.age}`) this.p.gf.age++ }) Text(\u0026#34;Girl Friends List\u0026#34;) ForEach( this.gfs, item =\u0026gt; { PersonChild({ p: item }) .onClick(() =\u0026gt; item.age++) } ) } } } @Component struct PersonChild { @ObjectLink p: Person build() { Column() { Text(`${this.p.name}: ${this.p.age}`) } } } 为了给变量加 @ObjectLink 装饰器, 写成组件 -\u0026gt; 因为装饰器没法装饰一个参数\n@Observed class 不管嵌套几个类型, 凡是嵌套的, 都要加上 @Observed 装饰器\n完善案例, 当 Checkbox 选中时, 会触发对应的任务完成状态, 任务完成状态改变时, 会触发任务进度的更新\n@Observed class Task { static id: number = 1 name: string = `Task${Task.id++}` finished: boolean = false } @Styles function card() { .width(\u0026#34;95%\u0026#34;) .padding(20) .backgroundColor(Color.White) .borderRadius(15) .shadow( { radius: 6, color: \u0026#34;#1F000000\u0026#34;, offsetX: 2, offsetY: 4 } ) } @Extend(Text) function finishedTask() { .fontColor(\u0026#34;#B1B2B1\u0026#34;) } @Entry @Component struct Second { @State totalTask: number = 0 @State finishTask: number = 0 @State task: Task[] = [] handTaskChange() { this.totalTask = this.task.length this.finishTask = this.task.filter(item =\u0026gt; item.finished).length } build() { Column({ space: 10 }) { // 任务进度卡片 TaskStatistics({ finishTask: this.finishTask, totalTask: this.totalTask }) // 新增任务按钮 Button(\u0026#34;添加任务\u0026#34;) .width(200) .onClick(() =\u0026gt; { this.task.push(new Task()) this.handTaskChange() }) // 渲染任务列表 List({ space: 10 }) { ForEach( this.task, (item: Task, index) =\u0026gt; { ListItem() { itemChild({item: item, onTaskChanged: () =\u0026gt; this.handTaskChange()}) } .swipeAction({ end: this.DeleteButton(index) }) } ) } .width(\u0026#34;100%\u0026#34;) .height(0) .alignListItem(ListItemAlign.Center) .layoutWeight(1) } .width(\u0026#34;100%\u0026#34;) .height(\u0026#34;100%\u0026#34;) .backgroundColor(\u0026#34;#F1F2F3\u0026#34;) } // 构建函数 @Builder DeleteButton(index: number) { Text(\u0026#34;Del\u0026#34;) .fontColor(Color.White) .padding(20) .backgroundColor(Color.Red) .borderRadius(\u0026#34;50%\u0026#34;) .margin(5) .onClick(() =\u0026gt; { this.task.splice(index, 1) this.handTaskChange() }) } } @Component struct TaskStatistics { @Prop finishTask: number @Prop totalTask: number build() { Row() { Text(\u0026#34;任务进度: \u0026#34;) .fontSize(30) .fontWeight(FontWeight.Bold) Stack() { Progress({ value: this.finishTask, total: this.totalTask, type: ProgressType.Ring }) .width(100) Row() { Text(this.finishTask.toString()) .fontSize(24) .fontColor(\u0026#34;#36D\u0026#34;) Text(\u0026#34;/\u0026#34; + this.totalTask.toString()) .fontSize(24) } } } .card() .margin({ top: 20, bottom: 10 }) .justifyContent(FlexAlign.SpaceEvenly) } } @Component struct itemChild { @ObjectLink item: Task onTaskChanged: () =\u0026gt; void build(){ Row() { if (this.item.finished) { Text(this.item.name) .finishedTask() } else { Text(this.item.name) } Checkbox() .select(this.item.finished) .onChange(value =\u0026gt; { this.item.finished = value this.onTaskChanged() }) } .card() .justifyContent(FlexAlign.SpaceBetween) } } 动画 基础通知 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V3/notification-guidelines-0000001281360946-V3\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-references-V3/js-apis-notification-0000001333321097-V3\n名称 值 说明 NOTIFICATION_CONTENT_BASIC_TEXT ContentType 普通类型通知。 NOTIFICATION_CONTENT_LONG_TEXT ContentType 长文本类型通知。 NOTIFICATION_CONTENT_PICTURE ContentType 图片类型通知。 NOTIFICATION_CONTENT_CONVERSATION ContentType 社交类型通知。 NOTIFICATION_CONTENT_MULTILINE ContentType 多行文本类型通知。 系统能力：以下各项对应的系统能力均为SystemCapability.Notification.Notification\n名称 可读 可写 类型 必填 描述 content 是 是 NotificationContent 是 通知内容。 id 是 是 number 否 通知ID。 slotType 是 是 SlotType 否 通道类型。 isOngoing 是 是 boolean 否 是否进行时通知。 isUnremovable 是 是 boolean 否 是否可移除。 deliveryTime 是 是 number 否 通知发送时间。 tapDismissed 是 是 boolean 否 通知是否自动清除。 autoDeletedTime 是 是 number 否 自动清除的时间。 wantAgent 是 是 WantAgent 否 点击跳转的WantAgent。 extraInfo 是 是 {[key: string]: any} 否 扩展参数。 color 是 是 number 否 通知背景颜色。 colorEnabled 是 是 boolean 否 通知背景颜色是否使能。 isAlertOnce 是 是 boolean 否 设置是否仅有一次此通知警报。 isStopwatch 是 是 boolean 否 是否显示已用时间。 isCountDown 是 是 boolean 否 是否显示倒计时时间。 isFloatingIcon 是 是 boolean 否 是否显示状态栏图标。 label 是 是 string 否 通知标签。 badgeIconStyle 是 是 number 否 通知角标类型。 showDeliveryTime 是 是 boolean 否 是否显示分发时间。 actionButtons 是 是 Array\u0026lt;NotificationActionButton\u0026gt; 否 通知按钮，最多两个按钮。 smallIcon 是 是 PixelMap 否 通知小图标。 largeIcon 是 是 PixelMap 否 通知大图标。 creatorBundleName 是 否 string 否 创建通知的包名。 creatorUid 是 否 number 否 创建通知的UID。 creatorPid 是 否 number 否 创建通知的PID。 creatorUserId8+ 是 否 number 否 创建通知的UserId。 hashCode 是 否 string 否 通知唯一标识。 groupName8+ 是 是 string 否 组通知名称。 template8+ 是 是 NotificationTemplate 否 通知模板。 distributedOption8+ 是 是 DistributedOptions 否 分布式通知的选项。 notificationFlags8+ 是 否 NotificationFlags 否 获取NotificationFlags。 import notify from \u0026#39;@ohos.notificationManager\u0026#39; import image from \u0026#39;@ohos.multimedia.image\u0026#39; @Entry @Component struct Index { // 全局任务 id idx: number = 100 // 图像 pixel: PixelMap async aboutToAppear() { // 获取资源管理器 let rm = getContext(this).resourceManager // 读取图片 let file = await rm.getMediaContent($r(\u0026#39;app.media.watchGT4\u0026#39;)) // 创建 PixelMap image.createImageSource(file.buffer).createPixelMap() .then(value =\u0026gt; this.pixel = value) .catch(reason =\u0026gt; console.error(reason)) } build() { Column({ space: 10 }) { Button(`发送normalText通知`) .onClick(() =\u0026gt; this.publishNormalTextNotification()) Button(`发送longText通知`) .onClick(() =\u0026gt; this.publishLongTextNotification()) Button(`发送multiLine通知`) .onClick(() =\u0026gt; this.publishMultiLineNotification()) Button(`发送Picture通知`) .onClick(() =\u0026gt; this.publishPictureNotification()) } .width(\u0026#39;100%\u0026#39;) } publishNormalTextNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39; } }, showDeliveryTime: true, deliveryTime: new Date().getTime(), groupName: \u0026#39;wechat\u0026#39;, slotType: notify.SlotType.SOCIAL_COMMUNICATION } this.publish(request) } publishLongTextNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_LONG_TEXT, longText: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39;, longText: \u0026#39;通知中的长文本，我很长，我很长，我很长，我很长，我很长，我很长，我很长\u0026#39;, briefText: \u0026#39;通知概要和总结\u0026#39;, expandedTitle: \u0026#39;通知展开时的标题\u0026#39; + this.idx } } } this.publish(request) } publishMultiLineNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_MULTILINE, multiLine: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39;, briefText: \u0026#39;通知概要和总结\u0026#39;, longTitle: \u0026#39;展开时的标题，我很宽，我很宽，我很宽\u0026#39;, lines: [ \u0026#39;第一行\u0026#39;, \u0026#39;第二行\u0026#39;, \u0026#39;第三行\u0026#39;, \u0026#39;第四行\u0026#39;, ] } } } this.publish(request) } publishPictureNotification() { let request: notify.NotificationRequest = { id: this.idx++, content: { contentType: notify.ContentType.NOTIFICATION_CONTENT_PICTURE, picture: { title: \u0026#39;通知标题\u0026#39; + this.idx, text: \u0026#39;通知内容详情\u0026#39;, additionalText: \u0026#39;通知附加内容\u0026#39;, briefText: \u0026#39;通知概要和总结\u0026#39;, expandedTitle: \u0026#39;展开后标题\u0026#39; + this.idx, picture: this.pixel } } } this.publish(request) } private publish(request: notify.NotificationRequest) { notify.publish(request) .then(() =\u0026gt; console.log(\u0026#39;notify test\u0026#39;, \u0026#39;发送通知成功\u0026#39;)) .then(reason =\u0026gt; console.log(\u0026#39;notify test\u0026#39;, \u0026#39;发送通知失败\u0026#39;, JSON.stringify(reason))) } } 进度条通知 import Notification from \u0026#39;@ohos.notificationManager\u0026#39; import wantAgent, { WantAgent } from \u0026#39;@ohos.app.ability.wantAgent\u0026#39; import promptAction from \u0026#39;@ohos.promptAction\u0026#39; import Prompt from \u0026#39;@system.prompt\u0026#39; enum DownloadState { NOT_BEGIN = \u0026#39;未开始\u0026#39;, DOWNLOADING = \u0026#39;下载中\u0026#39;, PAUSE = \u0026#39;已暂停\u0026#39;, FINISHED = \u0026#39;已完成\u0026#39;, } @Entry @Component struct Index { // 下载进度 @State progressValue: number = 0 progressMaxValue: number = 100 // 任务状态 @State state: DownloadState = DownloadState.NOT_BEGIN // 下载的文件名 filename: string = \u0026#39;圣诞星.mp4\u0026#39; // 模拟下载的任务的id taskId: number = -1 // 通知id notificationId: number = 999 isSupport: boolean = false wantAgentInstance: WantAgent async aboutToAppear() { // 1.判断当前系统是否支持进度条模板 this.isSupport = await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;) // 2.创建拉取当前应用的行为意图 // 2.1.创建wantInfo信息 let wantInfo: wantAgent.WantAgentInfo = { wants: [ { bundleName: \u0026#39;com.example.myapplication\u0026#39;, abilityName: \u0026#39;EntryAbility\u0026#39;, } ], requestCode: 0, operationType: wantAgent.OperationType.START_ABILITY, wantAgentFlags: [wantAgent.WantAgentFlags.CONSTANT_FLAG] } // 2.2.创建wantAgent实例 this.wantAgentInstance = await wantAgent.getWantAgent(wantInfo) } build() { Row({ space: 10 }) { Image($r(\u0026#39;app.media.ic_files_video\u0026#39;)).width(50) Column({ space: 5 }) { Row() { Text(this.filename) Text(`${this.progressValue}%`).fontColor(\u0026#39;#c1c2c1\u0026#39;) } .width(\u0026#39;100%\u0026#39;) .justifyContent(FlexAlign.SpaceBetween) Progress({ value: this.progressValue, total: this.progressMaxValue, }) Row({ space: 5 }) { Text(`${(this.progressValue * 0.43).toFixed(2)}MB`) .fontSize(14).fontColor(\u0026#39;#c1c2c1\u0026#39;) Blank() if (this.state === DownloadState.NOT_BEGIN) { Button(\u0026#39;开始\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.download()) } else if (this.state === DownloadState.DOWNLOADING) { Button(\u0026#39;取消\u0026#39;).downloadButton().backgroundColor(\u0026#39;#d1d2d3\u0026#39;) .onClick(() =\u0026gt; this.cancel()) Button(\u0026#39;暂停\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.pause()) } else if (this.state === DownloadState.PAUSE) { Button(\u0026#39;取消\u0026#39;).downloadButton().backgroundColor(\u0026#39;#d1d2d3\u0026#39;) .onClick(() =\u0026gt; this.cancel()) Button(\u0026#39;继续\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.download()) } else { Button(\u0026#39;打开\u0026#39;).downloadButton() .onClick(() =\u0026gt; this.open()) } }.width(\u0026#39;100%\u0026#39;) } .layoutWeight(1) } .width(\u0026#39;100%\u0026#39;) .borderRadius(20) .padding(15) .backgroundColor(Color.White) } cancel() { // 取消定时任务 if (this.taskId \u0026gt; 0) { clearInterval(this.taskId); this.taskId = -1 } console.log(this.notificationId.toString()) // 清理下载任务进度 this.progressValue = 0 // 标记任务状态：未开始 this.state = DownloadState.NOT_BEGIN // 取消通知 Notification.cancel(this.notificationId).then((response) =\u0026gt; { console.log(\u0026#39;ssssss\u0026#39;, JSON.stringify(response)) }) } download() { // 清理旧任务 if (this.taskId \u0026gt; 0) { clearInterval(this.taskId); } // 开启定时任务，模拟下载 this.taskId = setInterval(() =\u0026gt; { // 判断任务进度是否达到100 if (this.progressValue \u0026gt;= 100) { // 任务完成了，应该取消定时任务 clearInterval(this.taskId) this.taskId = -1 // 并且标记任务状态为已完成 this.state = DownloadState.FINISHED // 发送通知 this.publishProgressNotification() return } // 模拟任务进度变更 this.progressValue += 2 // 发送通知 this.publishProgressNotification() }, 500) // 标记任务状态：下载中 this.state = DownloadState.DOWNLOADING } pause() { // 取消定时任务 if (this.taskId \u0026gt; 0) { clearInterval(this.taskId); this.taskId = -1 } // 标记任务状态：已暂停 this.state = DownloadState.PAUSE // 发送通知 this.publishProgressNotification() } open() { promptAction.showToast({ message: \u0026#39;功能未实现\u0026#39; }) } async publishProgressNotification() { let isSupportTpl: boolean; await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;).then((data) =\u0026gt; { isSupportTpl = data; }).catch((err) =\u0026gt; { Prompt.showToast({ message: `判断是否支持进度条模板时报错,error[${err}]`, duration: 2000 }) }) if (isSupportTpl) { // 构造模板 let template = { name: \u0026#39;downloadTemplate\u0026#39;, data: { progressValue: this.progressValue, // 当前进度值 progressMaxValue: this.progressMaxValue // 最大进度值 } }; let notificationRequest: Notification.NotificationRequest = { id: this.notificationId, content: { contentType: Notification.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: this.filename + \u0026#39;: \u0026#39; + this.state, text: \u0026#39;\u0026#39;, additionalText: this.progressValue + \u0026#39;%\u0026#39; } }, template: template }; // 发布通知 Notification.publish(notificationRequest).then(() =\u0026gt; { Prompt.showToast({ message: `发布通知成功！`, duration: 2000 }) }).catch((err) =\u0026gt; { Prompt.showToast({ message: `发布通知失败,error[${err}]`, duration: 2000 }) }) } else { Prompt.showToast({ message: \u0026#39;不支持downloadTemplate进度条通知模板\u0026#39;, duration: 2000 }) } } publishDownloadNotification() { // 1.判断当前系统是否支持进度条模板 if (!this.isSupport) { // 当前系统不支持进度条模板 console.log(\u0026#34;not support\u0026#34;) return } // 2.准备进度条模板的参数 let template = { name: \u0026#39;downloadTemplate\u0026#39;, data: { progressValue: this.progressValue, progressMaxValue: this.progressMaxValue } } let request: Notification.NotificationRequest = { id: this.notificationId, template: template, wantAgent: this.wantAgentInstance, content: { contentType: Notification.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: this.filename + \u0026#39;: \u0026#39; + this.state, text: \u0026#39;\u0026#39;, additionalText: this.progressValue + \u0026#39;%\u0026#39; } } } // 3.发送通知 Notification.publish(request) .then(() =\u0026gt; console.log(\u0026#39;test\u0026#39;, \u0026#39;通知发送成功\u0026#39;)) .catch(reason =\u0026gt; console.log(\u0026#39;test\u0026#39;, \u0026#39;通知发送失败！\u0026#39;, JSON.stringify(reason))) } } @Extend(Button) function downloadButton() { .width(75).height(28).fontSize(14) } 通知意图 具体参数看官方文档\nhttps://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/js-apis-app-ability-wantagent-0000001493424324-V2\n​ async aboutToAppear() { // 1.判断当前系统是否支持进度条模板 this.isSupport = await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;) // 2.创建拉取当前应用的行为意图 // 2.1.创建wantInfo信息 let wantInfo: wantAgent.WantAgentInfo = { wants: [ { bundleName: \u0026#39;com.example.learn_2\u0026#39;, abilityName: \u0026#39;EntryAbility\u0026#39;, } ], requestCode: 0, operationType: wantAgent.OperationType.START_ABILITY, wantAgentFlags: [wantAgent.WantAgentFlags.CONSTANT_FLAG] } // 2.2.创建wantAgent实例 this.wantAgentInstance = await wantAgent.getWantAgent(wantInfo) } async publishProgressNotification() { let isSupportTpl: boolean; await Notification.isSupportTemplate(\u0026#39;downloadTemplate\u0026#39;).then((data) =\u0026gt; { isSupportTpl = data; }).catch((err) =\u0026gt; { Prompt.showToast({ message: `判断是否支持进度条模板时报错,error[${err}]`, duration: 2000 }) }) if (isSupportTpl) { // 构造模板 let template = { name: \u0026#39;downloadTemplate\u0026#39;, data: { progressValue: this.progressValue, // 当前进度值 progressMaxValue: this.progressMaxValue // 最大进度值 } }; let notificationRequest: Notification.NotificationRequest = { id: this.notificationId, wantAgent: this.wantAgentInstance, content: { contentType: Notification.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT, normal: { title: this.filename + \u0026#39;: \u0026#39; + this.state, text: \u0026#39;\u0026#39;, additionalText: this.progressValue + \u0026#39;%\u0026#39; } }, template: template }; // 发布通知 Notification.publish(notificationRequest).then(() =\u0026gt; { Prompt.showToast({ message: `发布通知成功！`, duration: 2000 }) }).catch((err) =\u0026gt; { Prompt.showToast({ message: `发布通知失败,error[${err}]`, duration: 2000 }) }) } else { Prompt.showToast({ message: \u0026#39;不支持downloadTemplate进度条通知模板\u0026#39;, duration: 2000 }) } } ","permalink":"https://waite.wang/posts/harmony/learn-harmony-2/","summary":"\u003ch2 id=\"页面路由\"\u003e页面路由\u003c/h2\u003e\n\u003cp\u003e页面路由指在应用程序中实现不同页面之间的跳转和数据传递。HarmonyOS提供了Router模块，通过不同的url地址，可以方便地进行页面路由，轻松地访问不同的页面。\u003c/p\u003e","title":"鸿蒙学习笔记2"},{"content":"编辑器安装 安装 下载安装包 正常安装包, 下一步安装 配置开发环境 选择 Agree, 进入配置选择页面, 选择不导入配置\n选择要安装的Node.is和hpm位置，其中ohpm是Open Harmony Package Management的缩写，也就是类似npm的包管理工具。这里有几点注意事项:\n如果电脑上已经有Node.js，但是版本不一致，建议选择让工具重新安装 如果电脑上已经有Node.js，并且版本一致，可以选择Local，指定node目录即可 如果电脑上对Node.is做了一些特殊的options配置，建议先移除 配置目录中不要出现中文、特殊字符，建议用默认路径 选择Next后，进入HarmonyOs的SDK安装目录选择页面以及同意协议, 配置目录/ 同意协议后下一步即可\n环境错误处理 在安装的过程中，如果出现类似下面的错误\n一般就是因为你本地原本的Node.is配置异常导致的，建议清理环境变量中对于Node.is的配置之后再重试 重试时无需重新安装，而是再次打开DevEco Studio，点击界面左下方的 ? 按钮: 选择第一个 Diagnose Development Environment 进入诊断页面, 这里会提示安装出现问题的选项，点击异常项后面的set it up now即可重新安装 如果所有问题都已经解决，最终重试后等待所有项都是 √即可\n中文设置 设置-\u0026gt;插件-\u0026gt;已安装-\u0026gt;其他工具-\u0026gt;chinese-\u0026gt;启用即可\n创建项目 Create Project -\u0026gt; Empty Ability -\u0026gt; 按要求填写目录即可\n此时项目内已有 Hello World 基础代码, 点右侧预览器即可预览效果\n模拟器安装 我们也可以利用设备模拟器来查看更真实的效果。不过需要先配置模拟器\n首先，选择主菜单中的Tools，找到其中的Device Manager，即设备管理\n设备可以是 远端设备 ，也可以是 本地设备 ，我们以本地设备为例。\n默认本地没有任何设备，选择install来安装一个\n首次点击时，会弹出一个窗口，下载必要的SDK依赖, 安装完下一步即可\n进入创建模拟器页面，选择New Emulator:\n选择api9版本，不过需要注意，首次进入此页面，需要下载手机设备需要的系统，大概2.2G，需要耐心等待:\n创建完成后，在设备列表中会出现一个本地设备，点击后面的运行按钮即可启动设备模拟器\n启动后如下\n然后，在应用启动位置选择刚刚添加的模拟器, 然后点击启动即可\n效果如下\nStage 与 FA 模型的区别 FA模型：早期的探索 FA模型是HarmonyOS早期版本开始支持的应用模型。它通过PageAbility、ServiceAbility和DataAbility三种组件，为开发者提供了构建应用的基础。FA模型的特点是每个组件运行在自己的进程中，拥有独立的JS VM引擎实例，这使得组件之间相互隔离，但也带来了一定的内存占用。\n随着HarmonyOS的演进，特别是1+8+N的战略被提出，多设备和多窗口形态成为主流，此时FA模型在处理复杂应用时存在一定的局限性， FA模型逐渐不再被主推。\nStage模型：未来的主流 为了更好地适应复杂应用的开发需求，HarmonyOS 3.1 Developer Preview版本引入了Stage模型。Stage模型通过AbilityStage、WindowStage等类，将应用组件和Window窗口作为“舞台”进行管理，从而提供了更加灵活和高效的开发方式。\nStage模型的设计出发点是为了复杂应用而设计，它通过以下几个方面实现了对复杂应用的优化：\n共享ArkTS引擎实例：在Stage模型中，多个应用组件共享同一个ArkTS引擎实例，这使得组件之间可以方便地共享对象和状态，同时减少了内存占用。\n面向对象的开发方式：Stage模型采用面向对象的开发方式，提高了代码的可读性、易维护性和可扩展性。\n支持多设备和多窗口形态：应用组件管理和窗口管理在架构层面解耦，使得应用组件可以在不同设备上使用同一套生命周期，便于系统扩展窗口形态。\n平衡应用能力和系统管控成本：Stage模型重新定义了应用能力的边界，提供了特定场景的应用组件，规范化了后台进程管理，防止了恶意应用行为。\n（Stage模型）目录结构 AppScope \u0026gt; app.json5：应用的全局配置信息。 entry：HarmonyOS工程模块，编译构建生成一个HAP包。 src \u0026gt; main \u0026gt; ets：用于存放ArkTS源码。 src \u0026gt; main \u0026gt; ets \u0026gt; entryability：应用/服务的入口。 src \u0026gt; main \u0026gt; ets \u0026gt; pages：应用/服务包含的页面 src \u0026gt; main \u0026gt; resources：用于存放应用/服务所用到的资源文件，如图形、多媒体、字符串、布局文件等。关于资源文件，详见资源分类与访问。 src \u0026gt; main \u0026gt; module.json5：Stage模型模块配置文件。主要包含HAP包的配置信息、应用/服务在具体设备上的配置信息以及应用/服务的全局配置信息。具体的配置文件说明，详见module.json5配置文件。 build-profile.json5：当前的模块信息、编译信息配置项，包括buildOption、targets配置等。其中targets中可配置当前运行环境，默认为HarmonyOS。 hvigorfile.ts：模块级编译构建任务脚本，开发者可以自定义相关任务和代码实现。 oh_modules：用于存放三方库依赖信息。关于原npm工程适配ohpm操作，请参考历史工程迁移。 build-profile.json5：应用级配置信息，包括签名、产品配置等。 hvigorfile.ts：应用级编译构建任务脚本。 ArkUI 组件 基础组件 Text Text($r(\u0026#34;app.string.module_desc\u0026#34;)) 文本会先在对应国家的资源文件中查找，如果没有找到，会在 base 全局资源文件中查找。\nTextInput Button 方法1： Button(options?: {type?: ButtonType, stateEffect?: boolean})\n方法2： Button(label?: ResourceStr, options?: { type?: ButtonType, stateEffect?: boolean })\n使用文本内容创建相应的按钮组件，此时Button无法包含子组件。\nImage 图片组件，支持本地图片和网络图片的渲染展示。\nImage(src: string | PixelMap | Resource) 图片的数据源，支持本地图片和网络图片。当使用相对路径引用图片资源时，例如Image(\u0026ldquo;common/test.jpg\u0026rdquo;)，不支持该Image组件被跨包/跨模块调用，建议使用$r方式来管理需全局使用的图片资源。\n支持的图片格式包括png、jpg、bmp、svg和gif。 支持Base64字符串。格式data:image/[png|jpeg|bmp|webp];base64,[base64 data], 其中[base64 data]为Base64字符串数据。 支持dataability://路径前缀的字符串，用于访问通过data ability提供的图片路径。 从网络加载图片 使用网络图片时，需要申请权限ohos.permission.INTERNET。具体申请方式请参考权限申请声明。\n// entry/src/main/module.json5 { \u0026#34;module\u0026#34;: { \u0026#34;reqPermissions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ohos.permission.INTERNET\u0026#34;, } ] } } 通过以下代码，可以加载网络图片：\nImage(\u0026#34;https://example.com/image.jpg\u0026#34;) 从本地加载 Image($r(\u0026#34;app.media.icon\u0026#34;)) Image($rawfile(\u0026#34;abstract.png\u0026#34;)) Slider Slider({ min: 0, // 最小值 max: 100, // 最大值 value: 40, // 当前值 step: 10, // 步长 style: SliderStyle.InSet, // Outer Slider direction: Axis.Horizontal, // 方向 reverse: false // 方向滑动 }) .showTips(true) // 展示 value 百分比 .margin({ top: 20 }) 容器组件 https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V3/arkui-ts-container-components-0000001334734185-V3\nColumn 沿垂直方向布局的容器。\n@Entry @Component struct ColumnExample { build() { Column() { Text(\u0026#39;space\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Column({ space: 5 }) { Column().width(\u0026#39;100%\u0026#39;).height(30).backgroundColor(0xAFEEEE) Column().width(\u0026#39;100%\u0026#39;).height(30).backgroundColor(0x00FFFF) }.width(\u0026#39;90%\u0026#39;).height(100).border({ width: 1 }) Text(\u0026#39;alignItems(Start)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Column() { Column().width(\u0026#39;50%\u0026#39;).height(30).backgroundColor(0xAFEEEE) Column().width(\u0026#39;50%\u0026#39;).height(30).backgroundColor(0x00FFFF) }.alignItems(HorizontalAlign.Start).width(\u0026#39;90%\u0026#39;).border({ width: 1 }) Text(\u0026#39;alignItems(End)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Column() { Column().width(\u0026#39;50%\u0026#39;).height(30).backgroundColor(0xAFEEEE) Column().width(\u0026#39;50%\u0026#39;).height(30).backgroundColor(0x00FFFF) }.alignItems(HorizontalAlign.End).width(\u0026#39;90%\u0026#39;).border({ width: 1 }) Text(\u0026#39;justifyContent(Center)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Column() { Column().width(\u0026#39;30%\u0026#39;).height(30).backgroundColor(0xAFEEEE) Column().width(\u0026#39;30%\u0026#39;).height(30).backgroundColor(0x00FFFF) }.height(\u0026#39;15%\u0026#39;).border({ width: 1 }).justifyContent(FlexAlign.Center) Text(\u0026#39;justifyContent(End)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Column() { Column().width(\u0026#39;30%\u0026#39;).height(30).backgroundColor(0xAFEEEE) Column().width(\u0026#39;30%\u0026#39;).height(30).backgroundColor(0x00FFFF) }.height(\u0026#39;15%\u0026#39;).border({ width: 1 }).justifyContent(FlexAlign.End) }.width(\u0026#39;100%\u0026#39;).padding({ top: 5 }) } } Row 沿水平方向布局容器。\n// xxx.ets @Entry @Component struct RowExample { build() { Column({ space: 5 }) { Text(\u0026#39;space\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Row({ space: 5 }) { Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0xAFEEEE) Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0x00FFFF) }.width(\u0026#39;90%\u0026#39;).height(107).border({ width: 1 }) Text(\u0026#39;alignItems(Top)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Row() { Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0xAFEEEE) Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0x00FFFF) }.alignItems(VerticalAlign.Top).height(\u0026#39;15%\u0026#39;).border({ width: 1 }) Text(\u0026#39;alignItems(Center)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Row() { Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0xAFEEEE) Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0x00FFFF) }.alignItems(VerticalAlign.Center).height(\u0026#39;15%\u0026#39;).border({ width: 1 }) Text(\u0026#39;justifyContent(End)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Row() { Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0xAFEEEE) Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0x00FFFF) }.width(\u0026#39;90%\u0026#39;).border({ width: 1 }).justifyContent(FlexAlign.End) Text(\u0026#39;justifyContent(Center)\u0026#39;).fontSize(9).fontColor(0xCCCCCC).width(\u0026#39;90%\u0026#39;) Row() { Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0xAFEEEE) Row().width(\u0026#39;30%\u0026#39;).height(50).backgroundColor(0x00FFFF) }.width(\u0026#39;90%\u0026#39;).border({ width: 1 }).justifyContent(FlexAlign.Center) }.width(\u0026#39;100%\u0026#39;) } } 案例 // xxx.ets @Entry @Component struct Index { @State imgWidth: number = 30 build() { Row() { Column() { Image($r(\u0026#34;app.media.icon\u0026#34;)) .width(this.imgWidth) .interpolation(ImageInterpolation.High) Text(`图片宽度: ${this.imgWidth}`) .margin(20) TextInput({ placeholder: \u0026#34;请输入图片宽度\u0026#34;, text: this.imgWidth.toString() }) .width(200) .type(InputType.Number) .onChange(value =\u0026gt; { this.imgWidth = parseInt(value) }) Row() { Button(\u0026#34;缩小\u0026#34;) .width(80) .onClick(() =\u0026gt; { if (this.imgWidth \u0026gt;= 10) { this.imgWidth -= 10 } }) Button(\u0026#34;放大\u0026#34;) .width(80) .onClick(() =\u0026gt; { if (this.imgWidth \u0026lt;= 300) { this.imgWidth += 10 } }) } .margin({ top: 20 }) Slider({ min: 0, // 最小值 max: 100, // 最大值 value: 40, // 当前值 step: 10, // 步长 style: SliderStyle.InSet, // Outer Slider direction: Axis.Horizontal, // 方向 reverse: false // 方向滑动 }) .showTips(true) // 展示 value 百分比 .margin({ top: 20 }) .width(\u0026#34;80%\u0026#34;) } .width(\u0026#34;100%\u0026#34;) } .height(\u0026#34;100%\u0026#34;) } } 循环控制 https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-rendering-control-foreach-0000001524537153-V2\nForEach( arr: Array, itemGenerator: (item: any, index: number) =\u0026gt; void, keyGenerator?: (item: any, index: number) =\u0026gt; string ) 在ForEach循环渲染过程中，系统会为每个数组元素生成一个唯一且持久的键值，用于标识对应的组件。当这个键值变化时，ArkUI框架将视为该数组元素已被替换或修改，并会基于新的键值创建一个新的组件。\nForEach提供了一个名为keyGenerator的参数，这是一个函数，开发者可以通过它自定义键值的生成规则。如果开发者没有定义keyGenerator函数，则ArkUI框架会使用默认的键值生成函数，即(item: any, index: number) =\u0026gt; { return index + \u0026lsquo;__\u0026rsquo; + JSON.stringify(item); }。\nArkUI框架对于ForEach的键值生成有一套特定的判断规则，这主要与itemGenerator函数的第二个参数index以及keyGenerator函数的第二个参数index有关，具体的键值生成规则判断逻辑如下图所示。\n以下是一个简单例子, 具体可以到官方文档查看\nclass Item { name: string image: string price: number discount: number constructor(name: string, image: string, price: number, discount: number = 0) { this.name = name this.image = image this.price = price this.discount = discount } } @Entry @Component struct Second { private items: Array\u0026lt;Item\u0026gt; = [ new Item(\u0026#34;华为Mate1\u0026#34;, \u0026#34;https://qiniu.waite.wang/202404182317729.png\u0026#34;, 1666, 1000), new Item(\u0026#34;华为Mate2\u0026#34;, \u0026#34;https://qiniu.waite.wang/202404182317729.png\u0026#34;, 1999), new Item(\u0026#34;华为Mate3\u0026#34;, \u0026#34;https://qiniu.waite.wang/202404182317729.png\u0026#34;, 2666), new Item(\u0026#34;华为Mate4\u0026#34;, \u0026#34;https://qiniu.waite.wang/202404182317729.png\u0026#34;, 2999), new Item(\u0026#34;华为Mate5\u0026#34;, \u0026#34;https://qiniu.waite.wang/202404182317729.png\u0026#34;, 3666), new Item(\u0026#34;华为Mate6\u0026#34;, \u0026#34;https://qiniu.waite.wang/202404182317729.png\u0026#34;, 3999), ] @State message: string = \u0026#39;Hi there\u0026#39; build() { Column({ space: 10 }) { Row() { Text(\u0026#34;商品列表\u0026#34;) .fontSize(30) .fontWeight(FontWeight.Bold) } .width(\u0026#34;100%\u0026#34;) ForEach( this.items, (item: Item) =\u0026gt; { Row({ space: 10 }) { Image(item.image) .width(100) Column() { Text(item.name) .fontSize(20) .fontWeight(FontWeight.Bold) if (item.discount) { Text(`原价$ ${item.price}`) .fontColor(\u0026#34;#ccc\u0026#34;) .fontSize(18) .decoration({ type: TextDecorationType.LineThrough }) Text(`折扣价$ ${item.discount}`) .fontColor(\u0026#34;red\u0026#34;) .fontSize(18) } else { Text(`$ ${item.price}`) .fontColor(\u0026#34;red\u0026#34;) .fontSize(18) } } .height(\u0026#34;100%\u0026#34;) .alignItems(HorizontalAlign.Start) } .width(\u0026#34;100%\u0026#34;) .backgroundColor(\u0026#34;#f8f8f8\u0026#34;) .borderRadius(20) .height(120) .padding(10) } ) } .padding(20) } } 注意 当不同数组项按照键值生成规则生成的键值相同时，框架的行为是未定义的。例如，在以下代码中，ForEach渲染相同的数据项two时，只创建了一个ChildItem组件，而没有创建多个具有相同键值的组件。\n@Entry @Component struct Parent { @State simpleList: Array\u0026lt;string\u0026gt; = [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]; build() { Row() { Column() { ForEach(this.simpleList, (item: string) =\u0026gt; { ChildItem({ \u0026#39;item\u0026#39;: item } as Record\u0026lt;string, string\u0026gt;) }, (item: string) =\u0026gt; item) } .width(\u0026#39;100%\u0026#39;) .height(\u0026#39;100%\u0026#39;) } .height(\u0026#39;100%\u0026#39;) .backgroundColor(0xF1F3F5) } } @Component struct ChildItem { @Prop item: string; build() { Text(this.item) .fontSize(50) } } 补充: List/ ListItem 在以上案例中, 超出屏幕的内容无法滚动查看(会隐藏), 可以使用 List/ ListItem 组件来实现\n// xxx.ets @Entry @Component struct ListItemExample { private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] @State editFlag: boolean = false build() { Column() { List({ space: 20, initialIndex: 0 }) { ForEach(this.arr, (item) =\u0026gt; { ListItem() { Text(\u0026#39;\u0026#39; + item) .width(\u0026#39;100%\u0026#39;).height(100).fontSize(16) .textAlign(TextAlign.Center).borderRadius(10).backgroundColor(0xFFFFFF) } }, item =\u0026gt; item) } }.width(\u0026#39;100%\u0026#39;).height(\u0026#39;100%\u0026#39;).backgroundColor(0xDCDCDC).padding({ top: 5 }) } } ArkUI 自定义组件 自定义组件的基本结构 struct：自定义组件基于struct实现，struct + 自定义组件名 + {\u0026hellip;}的组合构成自定义组件，不能有继承关系。对于struct的实例化，可以省略new。\n自定义组件名、类名、函数名不能和系统组件名相同。\n@Component：@Component装饰器仅能装饰struct关键字声明的数据结构。struct被@Component装饰后具备组件化的能力，需要实现build方法描述UI，一个struct只能被一个@Component装饰。\n从API version 9开始，该装饰器支持在ArkTS卡片中使用。\n@Component struct MyComponent { } build()函数：build()函数用于定义自定义组件的声明式UI描述，自定义组件必须定义build()函数。\n@Component struct MyComponent { build() { } } @Entry：@Entry装饰的自定义组件将作为UI页面的入口。在单个UI页面中，最多可以使用@Entry装饰一个自定义组件。@Entry可以接受一个可选的LocalStorage的参数。\n从API version 9开始，该装饰器支持在ArkTS卡片中使用。\n@Entry @Component struct MyComponent { } 自定义组件的基本用法 @Entry @Component struct ParentComponent { build() { Column() { Text(\u0026#39;ArkUI message\u0026#39;) HelloComponent({ message: \u0026#39;Hello, World!\u0026#39; }); HelloComponent({ message: \u0026#39;你好!\u0026#39; }); } } } @Component struct HelloComponent { @State message: string = \u0026#39;Hello, World!\u0026#39;; build() { // HelloComponent自定义组件组合系统组件Row和Text Row() { Text(this.message) .onClick(() =\u0026gt; { // 状态变量message的改变驱动UI刷新，UI从\u0026#39;Hello, World!\u0026#39;刷新为\u0026#39;Hello, ArkUI!\u0026#39; this.message = \u0026#39;Hello, ArkUI!\u0026#39;; }) } } } 如果在另外的文件中引用该自定义组件，需要使用export关键字导出，并在使用的页面import该自定义组件。\n@Component export struct HelloComponent { @State message: string = \u0026#39;Hello, World!\u0026#39;; build() { // HelloComponent自定义组件组合系统组件Row和Text Row() { Text(this.message) .onClick(() =\u0026gt; { // 状态变量message的改变驱动UI刷新，UI从\u0026#39;Hello, World!\u0026#39;刷新为\u0026#39;Hello, ArkUI!\u0026#39; this.message = \u0026#39;Hello, ArkUI!\u0026#39;; }) } } } import { HelloComponent } from \u0026#39;./HelloComponent\u0026#39; @Entry @Component struct ParentComponent { build() { Column() { Text(\u0026#39;ArkUI message\u0026#39;) HelloComponent({ message: \u0026#39;Hello, World!\u0026#39; }); HelloComponent({ message: \u0026#39;你好!\u0026#39; }); } } } 自定义组件的参数规定 从上文的示例中，我们已经了解到，可以在build方法里创建自定义组件，在创建自定义组件的过程中，根据装饰器的规则来初始化自定义组件的参数。\n@Component struct MyComponent { private countDownFrom: number = 0; private color: Color = Color.Blue; build() { } } @Entry @Component struct ParentComponent { private someColor: Color = Color.Pink; build() { Column() { // 创建MyComponent实例，并将创建MyComponent成员变量countDownFrom初始化为10，将成员变量color初始化为this.someColor MyComponent({ countDownFrom: 10, color: this.someColor }) } } } build()函数 所有声明在build()函数的语言，我们统称为UI描述，UI描述需要遵循以下规则：\n@Entry装饰的自定义组件，其build()函数下的根节点唯一且必要，且必须为容器组件，其中ForEach禁止作为根节点。 @Component装饰的自定义组件，其build()函数下的根节点唯一且必要，可以为非容器组件，其中ForEach禁止作为根节点。 @Entry @Component struct MyComponent { build() { // 根节点唯一且必要，必须为容器组件 Row() { ChildComponent() } } } @Component struct ChildComponent { build() { // 根节点唯一且必要，可为非容器组件 Image(\u0026#39;test.jpg\u0026#39;) } } 不允许声明本地变量，反例如下。 build() { // 反例：不允许声明本地变量 let a: number = 1; } 不允许在UI描述里直接使用console.info，但允许在方法或者函数里使用，反例如下。 build() { // 反例：不允许console.info console.info(\u0026#39;print debug log\u0026#39;); } 不允许创建本地的作用域，反例如下。 build() { // 反例：不允许本地作用域 { ... } } 不允许调用没有用@Builder装饰的方法，允许系统组件的参数是TS方法的返回值。 @Component struct ParentComponent { doSomeCalculations() { } calcTextValue(): string { return \u0026#39;Hello World\u0026#39;; } @Builder doSomeRender() { Text(`Hello World`) } build() { Column() { // 反例：不能调用没有用@Builder装饰的方法 this.doSomeCalculations(); // 正例：可以调用 this.doSomeRender(); // 正例：参数可以为调用TS方法的返回值 Text(this.calcTextValue()) } } } 不允许switch语法，如果需要使用条件判断，请使用if。反例如下。 build() { Column() { // 反例：不允许使用switch语法 switch (expression) { case 1: Text(\u0026#39;...\u0026#39;) break; case 2: Image(\u0026#39;...\u0026#39;) break; default: Text(\u0026#39;...\u0026#39;) break; } } } 不允许使用表达式，反例如下。 build() { Column() { // 反例：不允许使用表达式 (this.aVar \u0026gt; 10) ? Text(\u0026#39;...\u0026#39;) : Image(\u0026#39;...\u0026#39;) } } 自定义组件通用样式 自定义组件通过“.”链式调用的形式设置通用样式。\n@Component struct MyComponent2 { build() { Button(`Hello World`) } } @Entry @Component struct MyComponent { build() { Row() { MyComponent2() .width(200) .height(300) .backgroundColor(Color.Red) } } } ArkUI 入门 ArkTS语言 ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。因此，在学习ArkTS语言之前，建议开发者具备TS语言开发能力。\n当前，ArkTS在TS的基础上主要扩展了如下能力：\n基本语法：ArkTS定义了声明式UI描述、自定义组件和动态扩展UI元素的能力，再配合ArkUI开发框架中的系统组件及其相关的事件方法、属性方法等共同构成了UI开发的主体。 状态管理：ArkTS提供了多维度的状态管理机制。在UI开发框架中，与UI相关联的数据可以在组件内使用，也可以在不同组件层级间传递，比如父子组件之间、爷孙组件之间，还可以在应用全局范围内传递或跨设备传递。另外，从数据的传递形式来看，可分为只读的单向传递和可变更的双向传递。开发者可以灵活地利用这些能力来实现数据和UI的联动。 渲染控制：ArkTS提供了渲染控制的能力。条件渲染可根据应用的不同状态，渲染对应状态下的UI内容。循环渲染可从数据源中迭代获取数据，并在每次迭代过程中创建相应的组件。数据懒加载从数据源中按需迭代数据，并在每次迭代过程中创建相应的组件。 未来，ArkTS会结合应用开发/运行的需求持续演进，逐步提供并行和并发能力增强、系统类型增强、分布式开发范式等更多特性。\n基本语法 ArkTS 基本组成 自定义变量不能与基础通用属性/事件名重复。\n装饰器： 用于装饰类、结构、方法以及变量，并赋予其特殊的含义。如上述示例中@Entry、@Component和@State都是装饰器，@Component表示自定义组件，@Entry表示该自定义组件为入口组件，@State表示组件中的状态变量，状态变量变化会触发UI刷新。 UI描述：以声明式的方式来描述UI的结构，例如build()方法中的代码块。 自定义组件：可复用的UI单元，可组合其他组件，如上述被@Component装饰的struct Hello。 系统组件：ArkUI框架中默认内置的基础和容器组件，可直接被开发者调用，比如示例中的Column、Text、Divider、Button。 属性方法：组件可以通过链式调用配置多项属性，如fontSize()、width()、height()、backgroundColor()等。 事件方法：组件可以通过链式调用设置多个事件的响应逻辑，如跟随在Button后面的onClick()。 系统组件、属性方法、事件方法具体使用可参考基于ArkTS的声明式开发范式。 ","permalink":"https://waite.wang/posts/harmony/learn-harmony-1/","summary":"\u003ch2 id=\"编辑器安装\"\u003e编辑器安装\u003c/h2\u003e\n\u003ch3 id=\"安装\"\u003e安装\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://developer.huawei.com/consumer/cn/deveco-studio/#download\"\u003e下载安装包\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e正常安装包, 下一步安装\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202404171217774.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202404171217774.png\" alt=\"image-20240417121723826\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e配置开发环境\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202404171218425.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202404171218425.png\" alt=\"image-20240417121810196\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cp\u003e选择 Agree, 进入配置选择页面, 选择不导入配置\u003c/p\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202404171218109.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202404171218109.png\" alt=\"image-20240417121841096\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cp\u003e选择要安装的Node.is和hpm位置，其中ohpm是Open Harmony Package Management的缩写，也就是类似npm的包管理工具。这里有几点注意事项:\u003c/p\u003e","title":"鸿蒙学习笔记1"},{"content":" https://uniapp.dcloud.net.cn/\nuni 和 原生小程序开发区别 每个页面是一个 .vue 文件，数据绑定及事件处理同 Vue.js 规范：\n属性绑定 src=\u0026quot;{{ url }}\u0026quot; 升级成 :src=\u0026ldquo;url\u0026rdquo; 事件绑定 bindtap=\u0026ldquo;eventName\u0026rdquo; 升级成 @tap=\u0026ldquo;eventName\u0026rdquo;，支持（）传参 支持 Vue 常用指令 v-for、 v-if、v-show、v-model 等 温馨提示：调用接口能力，建议前缀 wx 替换为 uni ，养成好习惯，这样支持多端开发。\n创建项目/ 运行项目 uni-app 支持两种方式创建项目：\n通过 HBuilderX 创建 通过命令行创建 通过 HBuilderX 创建/ 运行 下载安装 HBuilderX https://hx.dcloud.net.cn/Tutorial/install/windows HBuilderX是通用的前端开发工具，但为uni-app做了特别强化。\n在点击工具栏里的文件 -\u0026gt; 新建 -\u0026gt; 项目（快捷键Ctrl+N）： uni-app自带的模板有 默认的空项目模板、Hello uni-app 官方组件和API示例，还有一个重要模板是 uni ui项目模板，日常开发推荐使用该模板，已内置大量常用组件。\n选择模板后，点击下一步，填写项目名称、项目路径、Appid（小程序）、Appname（小程序名称）等信息，点击完成即可创建项目。\n创建完成后，工具 -\u0026gt; 插件安装 -\u0026gt; uni-app编译器\n运行项目：点击工具栏里的运行按钮，选择运行到小程序模拟器或者手机端，即可看到效果。\n在微信开发者工具里运行：进入hello-uniapp项目，点击工具栏的运行 -\u0026gt; 运行到小程序模拟器 -\u0026gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app。\n注意：如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功。如下图，需在输入框输入微信开发者工具的安装路径。\n注意: 在微信小程序运行需要开启 设置 -\u0026gt; 安全设置 -\u0026gt; 服务端口 -\u0026gt; 开启服务端口, 并且关闭 设置 -\u0026gt; 编译器设置 -\u0026gt; 修改文件时自动保存\n这样在 HbuilderX 保存文件后，微信开发者工具会自动刷新。\n通过命令行创建/ 运行 https://uniapp.dcloud.net.cn/quickstart-cli.html\n全局安装 vue-clinpm install -g @vue/cli\n创建uni-app\n使用正式版（对应HBuilderX最新正式版） vue create -p dcloudio/uni-preset-vue my-project 使用alpha版（对应HBuilderX最新alpha版） vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 使用Vue3/Vite版\n创建以 javascript 开发的工程（如命令行创建失败，请直接访问 gitee 下载模板） npx degit dcloudio/uni-preset-vue#vite my-vue3-project npx degit dcloudio/uni-preset-vue#vite-alpha my-vue3-project 创建以 typescript 开发的工程（如命令行创建失败，请直接访问 gitee 下载模板） npx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project 此时，会提示选择项目模板（使用Vue3/Vite版不会提示，目前只支持创建默认模板），初次体验建议选择 hello uni-app 项目模板，如下所示：\n注意\nVue3/Vite版要求 node 版本^14.18.0 || \u0026gt;=16.0.0 如果使用 HBuilderX（3.6.7以下版本）运行 Vue3/Vite 创建的最新的 cli 工程，需要在 HBuilderX 运行配置最底部设置 node路径 为自己本机高版本 node 路径（注意需要重启 HBuilderX 才可以生效）\nHBuilderX Mac 版本菜单栏左上角 HBuilderX-\u0026gt;偏好设置-\u0026gt;运行配置-\u0026gt;node路径 HBuilderX Windows 版本菜单栏 工具-\u0026gt;设置-\u0026gt;运行配置-\u0026gt;node路径 国内特殊情况\n模板项目存放于 Github，由于国内网络环境问题，可能下载失败。针对此问题可以尝试如下措施：\n更换网络重试，比如使用 4g 网络 在设备或路由器的网络设置中增加 DNS（如：8.8.8.8） 在设备中增加固定的 hosts（如：140.82.113.4 github.com） 运行项目 更改项目中 manifest.json 中的 appid 为自己的小程序appid\n进入项目目录，运行命令 npm run dev:%PLATFORM%，其中 %PLATFORM% 为平台名称，如 h5、mp-weixin、mp-alipay、mp-baidu、mp-toutiao、mp-qq、quickapp-webview、quickapp-webview-union、quickapp-webview-huawei、quickapp-webview-oppo、quickapp-webview-vivo、quickapp-webview-xiaomi、quickapp-webview-meizu、quickapp-webview-leshi、quickapp-webview-haier、quickapp-webview-samsung、quickapp-webview-smartisan、quickapp-webview-nubia、quickapp-webview-oneplus、quickapp-webview-360、quickapp-webview-letv、quickapp-webview-coolpad、quickapp-webview-gionee、quickapp-webview-sony、`quickapp-webview-htc\n运行成功后，会在项目目录下生成 dist 目录，里面包含了编译后的代码，在微信小程序开发者工具中导入 dist/dev/mp-weixin 目录即可查看效果。\n用 VS Code 编辑 uni-app 项目 为什么要用 VS Code 编辑 uni-app 项目？\nHBuilderX 是基于 Eclipse 的 IDE，对于一些习惯了 VS Code 的开发者来说，可能不太适应。 HbuilderX 对 TS 支持不够友好，而 VS Code 对 TS 支持非常好。 安装插件 建议勾选以下\n安装 ts 类型校验 https://uni-helper.js.org/uni-app-types\nnpm i -D @types/wechat-miniprogram @uni-helper/uni-app-types { \u0026#34;extends\u0026#34;: \u0026#34;@vue/tsconfig/tsconfig.json\u0026#34;, \u0026#34;compilerOptions\u0026#34;: { \u0026#34;sourceMap\u0026#34;: true, \u0026#34;baseUrl\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;@/*\u0026#34;: [\u0026#34;./src/*\u0026#34;] }, \u0026#34;lib\u0026#34;: [\u0026#34;esnext\u0026#34;, \u0026#34;dom\u0026#34;], \u0026#34;types\u0026#34;: [ \u0026#34;@dcloudio/types\u0026#34;, \u0026#34;@types/wechat-miniprogram\u0026#34;, \u0026#34;@uni-helper/uni-app-types\u0026#34; ] }, \u0026#34;vueCompilerOptions\u0026#34;: { // 原配置 `experimentalRuntimeMode` 现调整为 `nativeTags` \u0026#34;nativeTags\u0026#34;: [\u0026#34;block\u0026#34;, \u0026#34;component\u0026#34;, \u0026#34;template\u0026#34;, \u0026#34;slot\u0026#34;] }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;, \u0026#34;src/**/*.d.ts\u0026#34;, \u0026#34;src/**/*.tsx\u0026#34;, \u0026#34;src/**/*.vue\u0026#34;] } json 注释问题 uni-app 只有在 HBuilderX 中才支持 json 注释，而在 VS Code 中不支持，所以在 VS Code 中编辑 json 文件时，会有报错提示。 只有这两个文件支持 json 注释，其他文件不支持。 ","permalink":"https://waite.wang/posts/mini-program/learn-uniapp-1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://uniapp.dcloud.net.cn/\"\u003ehttps://uniapp.dcloud.net.cn/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202403262157283.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202403262157283.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003ch2 id=\"uni-和-原生小程序开发区别\"\u003euni 和 原生小程序开发区别\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e每个页面是一个 .vue 文件，数据绑定及事件处理同 Vue.js 规范：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e属性绑定 src=\u0026quot;{{ url }}\u0026quot; 升级成 :src=\u0026ldquo;url\u0026rdquo;\u003c/li\u003e\n\u003cli\u003e事件绑定 bindtap=\u0026ldquo;eventName\u0026rdquo; 升级成 @tap=\u0026ldquo;eventName\u0026rdquo;，支持（）传参\u003c/li\u003e\n\u003cli\u003e支持 Vue 常用指令 v-for、 v-if、v-show、v-model 等\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e温馨提示：调用接口能力，建议前缀 wx 替换为 uni ，养成好习惯，这样支持多端开发。\u003c/p\u003e","title":"UniApp 入门"},{"content":"集成editorconfig配置 EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n# http://editorconfig.org root = true [*] # 表示所有文件适用 charset = utf-8 # 设置文件字符集为 utf-8 indent_style = space # 缩进风格（tab | space） indent_size = 2 # 缩进大小 end_of_line = lf # 控制换行类型(lf | cr | crlf) trim_trailing_whitespace = true # 去除行首的任意空白字符 insert_final_newline = true # 始终在文件末尾插入一个新行 [*.md] # 表示仅 md 文件适用以下规则 max_line_length = off trim_trailing_whitespace = false VSCode需要安装一个插件：EditorConfig for VS Code\n语法检查 / 代码格式化 使用prettier工具 Prettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n1.安装prettier\nnpm install prettier -D 2.配置.prettierrc文件：\nuseTabs：使用tab缩进还是空格缩进，选择false； tabWidth：tab是空格的情况下，是几个空格，选择2个； printWidth：当行字符的长度，推荐80，也有人喜欢100或者120； singleQuote：使用单引号还是双引号，选择true，使用单引号； trailingComma：在多行输入的尾逗号是否添加，设置为 none； semi：语句末尾是否要加分号，默认值true，选择false表示不加； { \u0026#34;useTabs\u0026#34;: false, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;printWidth\u0026#34;: 80, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;trailingComma\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;semi\u0026#34;: false } 3.创建.prettierignore忽略文件\n/dist/* .local .output.js /node_modules/** **/*.svg **/*.sh /public/* 4.VSCode需要安装prettier的插件\n5.测试prettier是否生效\n测试一：在代码中保存代码； 测试二：配置一次性修改的命令； 在package.json中配置一个scripts：\n\u0026#34;prettier\u0026#34;: \u0026#34;prettier --write .\u0026#34; 运行 npm run prettier 使用ESLint检测 vue-cli 创建项目，选择 eslint+prettier, 前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。 前面创建项目的时候，我们就选择了ESLint，所以Vue会默认帮助我们配置需要的ESLint环境。 解决eslint和prettier冲突的问题 安装插件：（vue在创建项目时，如果选择prettier，那么这两个插件会自动安装）\nnpm i eslint-plugin-prettier eslint-config-prettier -D 添加prettier插件(最后一行)：\nextends: [ \u0026#34;plugin:vue/vue3-essential\u0026#34;, \u0026#34;eslint:recommended\u0026#34;, \u0026#34;@vue/typescript/recommended\u0026#34;, \u0026#34;@vue/prettier\u0026#34;, \u0026#34;@vue/prettier/@typescript-eslint\u0026#34;, \u0026#39;plugin:prettier/recommended\u0026#39; ], git Husky和eslint 虽然我们已经要求项目使用eslint了，但是不能保证组员提交代码之前都将eslint中的问题解决掉了：\n也就是我们希望保证代码仓库中的代码都是符合eslint规范的；\n那么我们需要在组员执行 git commit 命令的时候对其进行校验，如果不符合eslint规范，那么自动通过规范进行修复；\n那么如何做到这一点呢？可以通过Husky工具：\nhusky是一个git hook工具，可以帮助我们触发git提交的各个阶段：pre-commit、commit-msg、pre-push 如何使用husky呢？\n这里我们可以使用自动配置命令：\nnpx husky-init \u0026amp;\u0026amp; npm install 接下来，我们需要去完成一个操作：在进行commit时，执行lint脚本：\n这个时候我们执行git commit的时候会自动对代码进行lint校验。\ngit commit规范 代码提交风格 通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。\n但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen\nCommitizen 是一个帮助我们编写规范 commit message 的工具； 1.安装Commitizen\nnpm install commitizen -D 2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：\nnpx commitizen init cz-conventional-changelog --save-dev --save-exact 这个命令会帮助我们安装cz-conventional-changelog 并且在package.json中进行配置\n这个时候我们提交代码需要使用 npx cz/ git cz：\nType 作用 feat 新增特性 (feature) fix 修复 Bug(bug fix) docs 修改文档 (documentation) style 代码格式修改(white-space, formatting, missing semi colons, etc) refactor 代码重构(refactor) perf 改善性能(A code change that improves performance) test 测试(when adding missing tests) build 变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等） ci 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等 chore 变更构建流程或辅助工具(比如更改测试环境) revert 代码回退 代码提交验证 如果我们按照cz来规范了提交风格，但是依然有同事通过 git commit 按照不规范的格式提交应该怎么办呢？\n我们可以通过commitlint来限制提交； 1.安装 @commitlint/config-conventional 和 @commitlint/cli\nnpm i @commitlint/config-conventional @commitlint/cli -D 2.在根目录创建commitlint.config.js文件，配置commitlint\nmodule.exports = { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;] } 3.使用husky生成commit-msg文件，验证提交信息：\nnpx husky add .husky/commit-msg \u0026#34;npx --no-install commitlint --edit $1\u0026#34; ","permalink":"https://waite.wang/posts/vue/vue-project-construction-specification/","summary":"\u003ch2 id=\"集成editorconfig配置\"\u003e集成editorconfig配置\u003c/h2\u003e\n\u003cp\u003eEditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e# http://editorconfig.org\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003eroot = true\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"cp\"\u003e*]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 表示所有文件适用\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003echarset = utf-8\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 设置文件字符集为 utf-8\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003eindent_style = space\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 缩进风格（tab | space）\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003eindent_size = 2\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 缩进大小\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003eend_of_line = lf\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 控制换行类型(lf | cr | crlf)\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003etrim_trailing_whitespace = true\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 去除行首的任意空白字符\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003einsert_final_newline = true\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 始终在文件末尾插入一个新行\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"cp\"\u003e*.md]\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"c\"\u003e# 表示仅 md 文件适用以下规则\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003emax_line_length = off\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"l\"\u003etrim_trailing_whitespace = false\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eVSCode需要安装一个插件：EditorConfig for VS Code\u003c/p\u003e","title":"vue 项目规范设置"},{"content":"Options API的弊端 在Vue2中，我们编写组件的方式是Options API：\nOptions API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端：\n当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：\n这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中； 如果我们能将同一个逻辑关注 点相关的代码收集在一起会更 好。 这就是Composition API想 要做的事情，以及可以帮助我 们完成的事情。 也有人把Vue Composition API简称为VCA。 我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。 认识 组合式 API (Composition API) https://cn.vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api\n组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：\n响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。 生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。 依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。 组合式 API 是 Vue 3 及 Vue 2.7 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 @vue/composition-api。在 Vue 3 中，组合式 API 基本上都会配合 `` 语法在单文件组件中使用。下面是一个使用组合式 API 的组件示例：\n\u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39; // 响应式状态 const count = ref(0) // 更改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() =\u0026gt; { console.log(`计数器初始值为 ${count.value}。`) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;点击了：{{ count }} 次\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 虽然这套 API 的风格是基于函数的组合，但组合式 API 并不是函数式编程。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。\nsetup() 以下的代码 均会采用选项式的写法, 组合式 Api 的写法可以参考官方文档, 但基本原理差不多, 而且 Vue3 选项式写法是基于组合式写法产生的!\nsetup() 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n需要在非单文件组件中使用组合式 API 时。 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。 setup函数的参数 主要有两个参数: 第一个参数：props 第二个参数：context setup 函数的第一个参数是组件的 props。和标准的组件一致，一个 setup 函数的 props 是响应式的，并且会在传入新的 props 时同步更新。： 对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义； 并且在template中依然是可以正常去使用props中的属性，比如message； 如果我们在setup函数中想要使用props，那么不可以通过 this 去获取 \u0026lt;!-- 推荐使用以下写法 --\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) // 返回值会暴露给模板和其他的选项式 API 钩子 return { count } }, mounted() { console.log(this.count) // 0 } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 当然也可以使用以下写法 --\u0026gt; \u0026lt;script\u0026gt; export default { props: { message: { type: String, required: true } }, data() { return { counter: 100 } }, setup(props, ....){ ..... } ... } \u0026lt;/script\u0026gt; setup 函数的第一个参数是组件的 props。和标准的组件一致，一个 setup 函数的 props 是响应式的，并且会在传入新的 props 时同步更新。 export default { props: { title: String }, setup(props) { console.log(props.title) } } 请注意如果你解构了 props 对象，解构出的变量将会丢失响应性。因此我们推荐通过 props.xxx 的形式来使用其中的 props。\n如果你确实需要解构 props 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 toRefs() 和 toRef() 这两个工具函数：\nimport { toRefs, toRef } from \u0026#39;vue\u0026#39; export default { setup(props) { // 将 `props` 转为一个其中全是 ref 的对象，然后解构 const { title } = toRefs(props) // `title` 是一个追踪着 `props.title` 的 ref console.log(title.value) // 或者，将 `props` 的单个属性转为一个 ref const title = toRef(props, \u0026#39;title\u0026#39;) } } 另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性： attrs：所有的非prop的attribute； slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）； emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）； export default { setup(props, context) { // 透传 Attributes（非响应式的对象，等价于 $attrs） console.log(context.attrs) // 插槽（非响应式的对象，等价于 $slots） console.log(context.slots) // 触发事件（函数，等价于 $emit） console.log(context.emit) // 暴露公共属性（函数） console.log(context.expose) } // 该上下文对象是非响应式的，可以安全地解构： setup(props, {attrs, slots, emit}) { console.log(props.message); console.log(attrs.id, attrs.class); console.log(slots); console.log(emit); } } attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外还需注意，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。\n代码示例\n\u0026lt;template\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34; class=\u0026#34;app-attr\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 使用接受过来的参数 --\u0026gt; {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, // 组件接受的参数 props: { msg: String }, // 发射的事件这里可以标注一下 emits:[\u0026#39;change\u0026#39;], setup(props, context) { // 这样可以拿到传递过来的msg的值 console.log(props.msg); // attrs console.log(context.attrs); // 发射事件 context.emit(\u0026#39;change\u0026#39;); } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; setup函数的返回值 setup 也可以返回一个渲染函数，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：\nimport { h, ref } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) return () =\u0026gt; h(\u0026#39;div\u0026#39;, count.value) } } 返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。\n我们可以通过调用 expose() 解决这个问题：\nimport { h, ref } from \u0026#39;vue\u0026#39; export default { setup(props, { expose }) { const count = ref(0) const increment = () =\u0026gt; ++count.value expose({ increment }) return () =\u0026gt; h(\u0026#39;div\u0026#39;, count.value) } } 此时父组件可以通过模板引用来访问这个 increment 方法。\nexport default { props: { message: { type: String, required: true } }, setup() { let counter = 100; // 局部函数 const increment = () =\u0026gt; { counter++; console.log(counter); } return { title: \u0026#34;Hello Home\u0026#34;, counter, increment } } } setup的返回值可以在模板template中被使用 也就是说可以通过setup的返回值来替代data选项 最后导出的一定要是个对象\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 使用导出的变量 --\u0026gt; \u0026lt;h1\u0026gt;{{ count }}\u0026lt;/h1\u0026gt; \u0026lt;!-- 使用导出的方法 --\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+ 1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { // 定义普通的变量，可以被正常使用 // 缺点 : 数据不是响应式的 let count = 100; // 定义方法 const increment = () =\u0026gt; { count++; console.log(count); }; // 导出 return { count, increment }; } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 因为只是定义了个变量，然后导出了，并没有使它响应式\n补充: 为什么 setup 不能使用 this 在Vue 3中，setup 函数是用来替代以前的 data, computed, methods 等选项的。setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n定义响应式数据的两种方式 Reactive API 如果想为在setup中定义的数据提供响应式的特性，那么可以使用reactive的函数\nps : 如果传入一个基本数据类型（String、Number、Boolean）会报一个警告\n应用场景 : reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型，最好相互有关联的数据时使用\n比如说想要上面的例子实现响应式, 我们可以做如下操作\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 这样使用即可 --\u0026gt; \u0026lt;h1\u0026gt;{{ state.count }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+ 1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 从vue中导入reactive import { reactive } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { // 使用reactive，会返回一个响应式对象 const state = reactive({ // 在对象中编写自己所需要的属性 count: 100 }); const increment = () =\u0026gt; { // 这样使用 state.count++; console.log(state.count); }; return { // 导出响应式state对象 state, increment }; } }; \u0026lt;/script\u0026gt; Reactive判断的API isProxy : 检查对象是否是由 reactive 或 readonly创建的 proxy isReactive : 检查对象是否是由 reactive创建的响应式代理，如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true isReadonly : 检查对象是否是由 readonly 创建的只读代理 toRaw : 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用） shallowReactive : 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)，只响应第一层 shallowReadonly : 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）只检查第一层 import { reactive, readonly, isProxy, isReactive, isReadonly, toRaw, shallowReactive, shallowReadonly } from \u0026#39;vue\u0026#39;; // 创建一个响应式对象 const original = { count: 0 }; const obj = reactive(original); // 检查对象是否是代理对象 console.log(isProxy(obj)); // true // 检查对象是否是由 reactive 创建的响应式代理 console.log(isReactive(obj)); // true // 检查对象是否是由 readonly 创建的只读代理 const ro = readonly(obj); console.log(isReadonly(ro)); // true // 返回 reactive 或 readonly 代理的原始对象 const rawObj = toRaw(obj); // 创建一个浅层响应式代理 const shallowObj = shallowReactive({ nested: { count: 0 } }); // 创建一个浅层只读代理 const shallowRo = shallowReadonly({ nested: { count: 0 } }); 以下是一些名词解释:\n代理对象：在Vue 3中，代理对象是由 reactive 或 readonly 创建的对象的代理，用于跟踪对象的属性的变化。 readonly：readonly 是一个函数，用于创建一个只读的代理对象，该代理对象只能读取属性值，不能修改属性值。 浅层响应式：浅层响应式是指只有对象的第一层属性会被设置为响应式，而嵌套对象的属性不会被设置为响应式。 浅层只读代理：浅层只读代理是指只有对象的第一层属性会被设置为只读，而嵌套对象的属性不会被设置为只读。 import { reactive, readonly, shallowReactive, shallowReadonly } from \u0026#39;vue\u0026#39;; // 创建一个普通对象 const original = { count: 0, nested: { count: 1 } }; // 创建一个响应式代理对象 const reactiveObj = reactive(original); reactiveObj.count = 1; // 可以修改属性值 reactiveObj.nested.count = 2; // 嵌套对象的属性也会被设置为响应式 // 创建一个只读代理对象 const readonlyObj = readonly(original); // readonlyObj.count = 2; // 试图修改只读属性会报错 // readonlyObj.nested.count = 2; // 嵌套对象的属性也是只读的 // 创建一个浅层响应式代理对象 const shallowReactiveObj = shallowReactive(original); shallowReactiveObj.count = 2; // 可以修改属性值 shallowReactiveObj.nested.count = 2; // 嵌套对象的属性不会被设置为响应式 // 创建一个浅层只读代理对象 const shallowReadonlyObj = shallowReadonly(original); shallowReadonlyObj.count = 2; // 试图修改只读属性会报错 shallowReadonlyObj.nested.count = 2; // 嵌套对象的属性不会被设置为只读 Ref API Ref函数 : 定义简单类型的数据，也可以定义复杂类型的数据\n应用场景 : 定义一些简单的数据，或者从接口中获得的数据\nref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值，这就是ref名称的来源 它内部的值是在ref的 value 属性中被维护的 不管传入的是基本类型还是引用类型，都放在.value中 使用的时候是用 .value，但是有两个注意事项:\n在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以并不需要在模板中通过 ref.value 的方式，直接使用即可 在 setup 函数内部，它依然是一个 ref引用， 所以对其进行操作时，依然需要使用 ref.value的方式 基本使用 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 这样使用即可，不需要使用count.value，会自动解包，取出其中的value --\u0026gt; \u0026lt;h1\u0026gt;{{ count }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+ 1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 从vue中导入ref import { ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { // 使用Ref，会返回一个响应式对象 let count = ref(100); const increment = () =\u0026gt; { // 这样使用,需要使用 .value count.value++; console.log(count.value); }; return { // 直接导出count即可 count, increment }; } }; \u0026lt;/script\u0026gt; Ref自动解包 模板中的解包是浅层的解包，如果我们的代码是下面的方式： 如果我们将ref放到一个reactive的属性当中，那么在模板中使用时，它会自动解包： const count = ref(1) const obj = reactive({ count }) // ref 会被解包 console.log(obj.count === count.value) // true // 会更新 `obj.count` count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // 也会更新 `count` ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3 注意当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包：\nconst books = reactive([ref(\u0026#39;Vue 3 Guide\u0026#39;)]) // 这里需要 .value console.log(books[0].value) const map = reactive(new Map([[\u0026#39;count\u0026#39;, ref(0)]])) // 这里需要 .value console.log(map.get(\u0026#39;count\u0026#39;).value) Ref判断的API isRef : 判断值是否是一个ref对象 unref : 如果我们想要获取一个ref引用中的value，那么也可以通过unref方法 如果参数是一个 ref，则返回内部值，否则返回参数本身 这是 val = isRef(val) ? val.value : val 的语法糖函数 shallowRef：shallowRef 是用来创建一个浅层的 ref 对象的函数。浅层的意思是只有对象的第一层属性会被设置为响应式，而嵌套对象的属性不会被设置为响应式。这意味着对嵌套对象属性的修改不会触发响应。 triggerRef：triggerRef 用于手动触发与 shallowRef 相关联的副作用。当 shallowRef 关联的数据发生变化时，相关的副作用将被触发执行。 import { ref, isRef, unref, shallowRef, triggerRef } from \u0026#39;vue\u0026#39;; // 判断值是否是一个 ref 对象 const count = ref(0); console.log(isRef(count)); // true // 获取 ref 引用中的值 const value = unref(count); // 语法糖函数示例 const val = isRef(count) ? count.value : count; // 创建一个浅层的 ref 对象 const shallowCount = shallowRef({ value: 0 }); shallowCount.value = 1; // 可以直接修改 value 属性 // 手动触发与 shallowRef 相关联的副作用 triggerRef(shallowCount); 自定义Ref =\u0026gt; customRef 创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制： 它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数； 并且应该返回一个带有 get 和 set 的对象； 这里我们使用一个的案例： 对双向绑定的属性进行debounce(节流)的操作 import { customRef } from \u0026#39;vue\u0026#39;; // 自定义ref export default function(value, delay = 300) { let timer = null; return customRef((track, trigger) =\u0026gt; { return { get() { track(); return value; }, set(newValue) { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { value = newValue; trigger(); }, delay); } } }) } \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input v-model=\u0026#34;message\u0026#34;/\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import debounceRef from \u0026#39;./hook/useDebounceRef\u0026#39;; export default { setup() { const message = debounceRef(\u0026#34;Hello World\u0026#34;); return { message } } } \u0026lt;/script\u0026gt; readonly 概念 在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用 readonly了；\n只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 reactive() 相同，但解包得到的值是只读的。 要避免深层级的转换行为，请使用 shallowReadonly() 作替代。 在开发中常见的readonly方法会传入三个类型的参数： 类型一：普通对象 类型二：reactive返回的对象 类型三：ref的对象 在readonly的使用过程中，有如下规则 : readonly返回的对象都是不允许修改的 但是经过readonly处理的原来的对象是允许被修改的 比如 const info = readonly(obj)，info对象是不允许被修改的 当obj被修改时，readonly返回的info对象也会被修改 但是不能去修改readonly返回的对象info \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { reactive, readonly, watchEffect } from \u0026#39;vue\u0026#39; const original = reactive({ count: 0 }) const copy = readonly(original) const btnClick = () =\u0026gt; { original.count++ } watchEffect(() =\u0026gt; { // 用来做响应性追踪 console.log(copy.count) }) // 更改源属性会触发其依赖的侦听器 original.count++ // 更改该只读副本将会失败，并会得到一个警告 copy.count++ // warning! \u0026lt;/script\u0026gt; toRefs \u0026amp;\u0026amp; toRef toRefs 如果使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改reactive 返回的state对象，数据都不再是响应式的\n如何改成响应式呢，Vue提供了一个toRefs的函数 可以将reactive返回的对象中的属性都转成ref，这样解构出来的就是响应式的了 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ age }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 从vue中导入ref import { reactive, ref, readonly, toRefs } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { const info = reactive({ name: \u0026#39;star\u0026#39;, age: 18 }); // 使用toRefs包裹需要结构的reactive对象，这样解构出来的值也是响应式的 let { name, age } = toRefs(info); const increment = () =\u0026gt; { info.age++; // 👆这样都可以修改age，都是响应式的👇 // 相当于已经建立了链接，任何一个修改都会引起另外一个变化 age.value++; console.log(age, info.age); }; return { name, age, increment }; } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; toRef 如果只希望转换reactive对象中的其中某个属性为ref, 那么可以使用toRef的方法\nps : 这个效率会更高点, 这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化\nlet age = toRef(info, \u0026#34;age\u0026#34;); const changeAge = () =\u0026gt; { age.value++; } computed 在前面的Options API中，我们是使用computed选项来完成的； 在Composition API中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性； 如何使用computed呢？ 方式一：接收一个getter函数，并为 getter 函数返回的值，返回一个不变的 ref 对象； 方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象； 方式一 \u0026lt;template\u0026gt; \u0026lt;!-- coderstar --\u0026gt; {{ fullName }} \u0026lt;!-- 一般 --\u0026gt; {{ scoreState }} \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { computed, reactive, ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, setup() { const names = reactive({ firstName: \u0026#39;coder\u0026#39;, lastName: \u0026#39;star\u0026#39; }); // 直接使用getter函数，正常来说都这么使用 const fullName = computed(() =\u0026gt; names.firstName + names.lastName); const score = ref(88); const scoreState = computed(() =\u0026gt; (score.value \u0026gt; 90 ? \u0026#39;优秀\u0026#39; : \u0026#39;一般\u0026#39;)); return { fullName, scoreState }; } }; \u0026lt;/script\u0026gt; 方式二 \u0026lt;template\u0026gt; {{ fullName }} \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { computed, reactive } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, setup() { const names = reactive({ firstName: \u0026#39;冲啊\u0026#39;, lastName: \u0026#39;迪迦奥特曼\u0026#39; }); // 会返回一个ref对象 const fullName = computed({ set(newValue) { const tempNames = newValue.split(\u0026#39; \u0026#39;); names.firstName = tempNames[0]; names.lastName = tempNames[1]; }, get() { return names.firstName + names.lastName; } }); // 设置值 const changeName = () =\u0026gt; { fullName.value = fullName.value === \u0026#39;冲啊迪迦奥特曼\u0026#39; ? \u0026#39;神秘的 宇宙人\u0026#39; : \u0026#39;冲啊 迪迦奥特曼\u0026#39;; }; return { fullName, changeName }; } }; \u0026lt;/script\u0026gt; 生命周期钩子 https://cn.vuejs.org/api/composition-api-lifecycle.html\nsetup中可以直接使用导入的onX函数注册生命周期，并且同一个生命周期可以使用多次\n所有罗列在本页的 API 都应该在组件的 setup() 阶段被同步调用。相关细节请看指南 - 生命周期钩子。\n可以使用直接导入的 onX 函数注册生命周期钩子； beforeCreate和create在setup中没有相对应的onX的函数 如果想要在beforeCreate和create中进行操作 可以把代码直接写入到setup中 setup的执行时序比beforeCreate和create还要早 import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from \u0026#39;vue\u0026#39;; // 注册生命周期钩子 export default { setup() { onBeforeMount(() =\u0026gt; { console.log(\u0026#39;Before Mount\u0026#39;); // 组件挂载前 }); onMounted(() =\u0026gt; { console.log(\u0026#39;Mounted\u0026#39;); // 组件挂载后 }); onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;Before Update\u0026#39;); // 组件更新前 }); onUpdated(() =\u0026gt; { console.log(\u0026#39;Updated\u0026#39;); // 组件更新后 }); onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;Before Unmount\u0026#39;); // 组件卸载前 }); onUnmounted(() =\u0026gt; { console.log(\u0026#39;Unmounted\u0026#39;); // 组件卸载后 }); // 同一个生命周期可以使用多次 onMounted(() =\u0026gt; { console.log(\u0026#39;Another Mounted\u0026#39;); // 另一个组件挂载后 }); return {}; } }; setup中使用ref获取元素或组件 要定义一个ref对象，绑定到元素或者组件的ref属性上即可\n只有在挂载完成后才能拿到值, 所以需要在生命周期中调用拿值\n获取元素 \u0026lt;template\u0026gt; \u0026lt;!-- 1. 指定ref --\u0026gt; \u0026lt;h2 ref=\u0026#34;titleRef\u0026#34;\u0026gt;我是迪迦\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, setup() { // 2. 生成ref对象 const titleRef = ref(); // 4. 可以在生命周期中获取到值 onMounted(() =\u0026gt; { console.log(titleRef.value); // \u0026lt;h2\u0026gt;我是迪迦\u0026lt;/h2\u0026gt; }); return { // 3. 返回出去，会自动匹配到对应的ref的 titleRef }; } }; \u0026lt;/script\u0026gt; 获取组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;我是子组件\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;home-layout\u0026#39;, setup() { const showMessage = () =\u0026gt; { console.log(\u0026#39;home-layout function exection\u0026#39;); }; return { showMessage }; } }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 1. 指定ref --\u0026gt; \u0026lt;home ref=\u0026#34;homeCompRef\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; import home from \u0026#39;./home.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { home }, setup() { // 2. 生成ref对象 const homeCompRef = ref(); // 4. 可以在生命周期中获取到值 onMounted(() =\u0026gt; { console.log(homeCompRef.value); // proxy对象 console.log(homeCompRef.value.$el); // \u0026lt;div\u0026gt;我是子组件\u0026lt;/div\u0026gt; homeCompRef.value.showMessage(); // 调用子组件方法 }); return { // 3. 返回出去，会自动匹配到对应的ref的 homeCompRef }; } }; \u0026lt;/script\u0026gt; 侦听数据的变化 在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些 操作。\n在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听；\nwatchEffect用于自动收集响应式数据的依赖； watch需要手动指定侦听的数据源； watchEffect 基本使用 自动收集响应式数据的依赖 watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖 只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ name }} - {{ age }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;changeName\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;changeAge\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { let name = ref(\u0026#39;star\u0026#39;); let age = ref(18); const changeName = () =\u0026gt; (name.value === \u0026#39;star\u0026#39; ? (name.value = \u0026#39;xuanyu\u0026#39;) : (name.value = \u0026#39;star\u0026#39;)); const changeAge = () =\u0026gt; age.value++; watchEffect(() =\u0026gt; { // 因为这里只使用了name，所以只会监听name，如果把age也写进来，那么两个都会监听 console.log(\u0026#39;name:\u0026#39;, name.value); }); return { name, age, changeName, changeAge }; } }; \u0026lt;/script\u0026gt; 停止监听 如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可。 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ name }} - {{ age }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;changeName\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;changeAge\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { let name = ref(\u0026#39;star\u0026#39;); let age = ref(18); const changeName = () =\u0026gt; (name.value === \u0026#39;star\u0026#39; ? (name.value = \u0026#39;xuanyu\u0026#39;) : (name.value = \u0026#39;star\u0026#39;)); // 获取返回值 const stopWatchEffect = watchEffect(() =\u0026gt; { // 自动监听age console.log(\u0026#39;age:\u0026#39;, age.value); }); const changeAge = () =\u0026gt; { age.value++; if (age.value \u0026gt; 22) { // 停止监听 stopWatchEffect(); } }; return { name, age, changeName, changeAge }; } }; \u0026lt;/script\u0026gt; 清除副作用 什么是清除副作用呢？ 比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了 那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用； 在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate 当副作用即将重新执行 或者 侦听器被停止 时会执行该函数传入的回调函数； 我们可以在传入的回调函数中，执行一些清除工作； \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{ name }}-{{ age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改name\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { // watchEffect: 自动收集响应式的依赖 const name = ref(\u0026#34;why\u0026#34;); const age = ref(18); const stop = watchEffect((onInvalidate) =\u0026gt; { const timer = setTimeout(() =\u0026gt; { console.log(\u0026#34;网络请求成功~\u0026#34;); }, 2000) // 根据name和age两个变量发送网络请求 onInvalidate(() =\u0026gt; { // 在这个函数中清除额外的副作用 // request.cancel() clearTimeout(timer); console.log(\u0026#34;onInvalidate\u0026#34;); }) console.log(\u0026#34;name:\u0026#34;, name.value, \u0026#34;age:\u0026#34;, age.value); }); const changeName = () =\u0026gt; name.value = name.value === \u0026#34;why\u0026#34; ? \u0026#34;kobe\u0026#34; : \u0026#34;why\u0026#34;; const changeAge = () =\u0026gt; age.value++; return { name, age, changeName, changeAge } } } \u0026lt;/script\u0026gt; watchEffect的执行时机 默认情况下，组件的更新会在副作用函数执行之前： 如果我们希望在副作用函数中获取到元素，是否可行呢？ \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { const title = ref(null); watchEffect(() =\u0026gt; { console.log(title.value); }) return { title } } } \u0026lt;/script\u0026gt; 我们会发现打印结果打印了两次： 这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null； 而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素； 这个时候我们需要改变副作用函数的执行时机； 它的默认值是pre，它会在元素 挂载 或者 更新 之前执行； 所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素； 我们可以设置副作用函数的执行时机： pre : 默认值,它会在元素 挂载 或者 更新 之前执行 post : 元素 挂载 或者 更新 之后执行 sync : 强制同步一起执行，效率很低，不推荐 \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { const title = ref(null); watchEffect(() =\u0026gt; { console.log(title.value); }, { flush: \u0026#34;post\u0026#34; }) return { title } } } \u0026lt;/script\u0026gt; Watch watch的API完全等同于组件watch选项的Property： watch需要侦听特定的数据源，并在回调函数中执行副作用； 默认情况下它是惰性的，只有当被侦听的源发 生变化时才会执行回调； 与watchEffect的比较，watch允许我们： 懒执行副作用（第一次不会直接执行）； 更具体的说明当哪些状态发生变化时，触发侦听器的执行； 访问侦听状态变化前后的值； 侦听单个数据源 watch侦听函数的数据源有两种类型：\n一个getter函数：但是该getter函数必须引用可响应式的对象（比如reactive或者ref）； 直接写入一个可响应式的对象，ref（如果是一个 reactive 的对象的侦听, 需要进行某些转换 ）； import { watch, reactive, ref, toRefs } from \u0026#39;vue\u0026#39;; // 一个getter函数引用可响应式的对象 const state = reactive({ count: 0 }); watch( () =\u0026gt; state.count, (newValue, oldValue) =\u0026gt; { console.log(`Count changed from ${oldValue} to ${newValue}`); }); // 直接写入一个可响应式的对象 const count = ref(0); watch(count, (newValue, oldValue) =\u0026gt; { console.log(`Count changed from ${oldValue} to ${newValue}`); }); // 直接写入一个可响应式的对象，需要进行某些转换 const reactiveState = reactive({ count: 0 }); const { count } = toRefs(reactiveState); watch(count, (newValue, oldValue) =\u0026gt; { console.log(`Count changed from ${oldValue} to ${newValue}`); }); 注意: reactive 对象获取到的 newValue 以及 oldValue 本身都是 reactive 对象\nwatch( info, (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) 如果希望两者都是一个普通对象, 可以使用以下写法(JavaScript中的展开运算符):\nwatch( () =\u0026gt; ({ ...info }), (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) 以下是完整代码:\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;{{ info.name }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeData\u0026#34;\u0026gt;修改数据\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, watch } from \u0026#39;vue\u0026#39;; export default { setup() { const info = reactive({ name: \u0026#34;why\u0026#34;, age: 18 }); watch( () =\u0026gt; ({ ...info }), (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) watch( info, (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) const changeData = () =\u0026gt; info.name = info.name === \u0026#34;why\u0026#34; ? \u0026#34;kobe\u0026#34; : \u0026#34;why\u0026#34;; return { changeData, info } } } \u0026lt;/script\u0026gt; 侦听多个数据源 当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\nwatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =\u0026gt; { /* ... */ }) \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;{{ info.name }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeData\u0026#34;\u0026gt;修改数据\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive, watch } from \u0026#39;vue\u0026#39;; export default { setup() { const info = reactive({ name: \u0026#34;why\u0026#34;, age: 18 }); const name = ref(\u0026#34;why\u0026#34;); watch([() =\u0026gt; ({ ...info }), name], ([newInfo, newName], [oldInfo, oldName]) =\u0026gt; { console.log(newInfo, newName, oldInfo, oldName); }) const changeData = () =\u0026gt; { info.name = \u0026#34;kobe\u0026#34;; } return { changeData, info } } } \u0026lt;/script\u0026gt; watch的选项 deep : 是否深度监听 immediate ： 是否立即执行 watch 侦听 reactive时默认是深度侦听的, 但是在使用 {...info}展开运算符时, 是不会深度监听的, 所以我们要设置 deep: True\nimmediate: 第一次会执行\nwatch( () =\u0026gt; { const obj = { ...info } obj.friend = { ...obj.friend } return obj }, (newValue, oldValue) =\u0026gt; { console.log(newValue, oldValue) }, { // 如果有多层，需要加上deep deep: true, // 立即执行 immediate: true } ) 停止侦听 const stop = watch(source, callback) // 当已不再需要该侦听器时： stop() 副作用清理 watch(id, async (newId, oldId, onCleanup) =\u0026gt; { const { response, cancel } = doAsyncWork(newId) // 当 `id` 变化时，`cancel` 将被调用， // 取消之前的未完成的请求 onCleanup(cancel) data.value = await response }) provide \u0026amp;\u0026amp; inject provide 和 inject 通常成对一起使用，使一个祖先组件作为其后代组件的依赖注入方，无论这个组件的层级有多深都可以注入成功，只要他们处于同一条组件链上。\nprovide可以传入两个参数 :\nname：提供的属性名称 value：提供的属性值 inject可以传入两个参数 :\n对应provide传过来的name值 默认值 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;APP count: {{ count }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;change\u0026#34;\u0026gt;APP button\u0026lt;/button\u0026gt; \u0026lt;demo /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, provide, readonly } from \u0026#39;vue\u0026#39; import demo from \u0026#39;./components/demo.vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, components: { demo }, setup() { let count = ref(100) // 第一个参数key 第二个参数值，不让子组件随便修改，用readonly包裹一下 provide(\u0026#39;count\u0026#39;, readonly(count)) const change = () =\u0026gt; count.value++ return { count, change } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;demo count:{{ count }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;change\u0026#34;\u0026gt;demo change\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, inject } from \u0026#39;vue\u0026#39; export default { setup() { // 接收 第二个参数可以给一个默认值 let count = inject(\u0026#39;count\u0026#39;, \u0026#39;\u0026#39;) // 因为设置了readOnly 所以更改不了 const change = () =\u0026gt; count.value++ return { count, change } } } \u0026lt;/script\u0026gt; h函数 Vue在生成真实的DOM之前，会将节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM ( VDOM ) 事实上，编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode 那么，如果想充分的利用JavaScript的编程能力，可以自己来编写 createVNode 函数，生成对应的VNode h() 函数是一个用于创建 vnode 的一个函数 其实更准备的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数 参数 // 完整参数签名 function h( type: string | Component, props?: object | null, children?: Children | Slot | Slots ): VNode // 省略 props function h(type: string | Component, children?: Children | Slot): VNode type Children = string | number | boolean | VNode | null | Children[] type Slot = () =\u0026gt; Children type Slots = { [name: string]: Slot } 第一个参数既可以是一个字符串 (用于原生元素) 也可以是一个 Vue 组件定义。第二个参数是要传递的 prop，第三个参数是子节点。 当创建一个组件的 vnode 时，子节点必须以插槽函数进行传递。如果组件只有默认槽，可以使用单个插槽函数进行传递。否则，必须以插槽函数的对象形式来传递。 为了方便阅读，当子节点不是插槽对象时，可以省略 prop 参数。 基本使用 h函数可以在两个地方使用：\nrender函数选项中； setup函数选项中（setup本身需要是一个函数类型，函数再返回h函数创建的VNode）； 在render函数选项中 \u0026lt;script\u0026gt; // 1. 引入h函数 import { h } from \u0026#39;vue\u0026#39;; export default { data() { return { counter: 0 }; }, // 2. 定义render选项 render() { // 3. 返回自定义的h函数 return h(\u0026#39;div\u0026#39;, { class: \u0026#39;app-view\u0026#39;, name: \u0026#39;abc\u0026#39; }, [ // 4. 定义h2 h(\u0026#39;h2\u0026#39;, { className: \u0026#39;title\u0026#39; }, this.counter), // 5. 定义增加按钮 h( \u0026#39;button\u0026#39;, { className: \u0026#39;add-btn\u0026#39;, onClick: () =\u0026gt; { this.counter++; } }, \u0026#39;加一\u0026#39; ), // 6. 定义减少按钮 h( \u0026#39;button\u0026#39;, { className: \u0026#39;remove-btn\u0026#39;, onClick: () =\u0026gt; { this.counter--; } }, \u0026#39;减一\u0026#39; ) ]); } } \u0026lt;/script\u0026gt; 在setup函数选项中 \u0026lt;script\u0026gt; import { h, ref } from \u0026#39;vue\u0026#39;; export default { setup() { const counter = ref(0); const increment = () =\u0026gt; { counter.value++; }; const decrement = () =\u0026gt; { counter.value--; }; // 返回render函数 return () =\u0026gt; h(\u0026#39;div\u0026#39;, { class: \u0026#39;app-view\u0026#39;, name: \u0026#39;abc\u0026#39; }, [ h(\u0026#39;h2\u0026#39;, { className: \u0026#39;title\u0026#39; }, counter.value), h( \u0026#39;button\u0026#39;, { onClick: increment }, \u0026#39;+1\u0026#39; ), h( \u0026#39;button\u0026#39;, { onClick: decrement }, \u0026#39;-1\u0026#39; ) ]); } }; \u0026lt;/script\u0026gt; 在setup语法糖中 \u0026lt;template\u0026gt; \u0026lt;!-- 2. 使用一下 --\u0026gt; \u0026lt;star-render /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { h, ref } from \u0026#39;vue\u0026#39;; const counter = ref(0); const increment = () =\u0026gt; { counter.value++; }; const decrement = () =\u0026gt; { counter.value--; }; // 1. 拿到render函数 const starRender = () =\u0026gt; h(\u0026#39;div\u0026#39;, { class: \u0026#39;app-view\u0026#39;, name: \u0026#39;abc\u0026#39; }, [ h(\u0026#39;h2\u0026#39;, { className: \u0026#39;title\u0026#39; }, counter.value), h( \u0026#39;button\u0026#39;, { onClick: increment }, \u0026#39;+1\u0026#39; ), h( \u0026#39;button\u0026#39;, { onClick: decrement }, \u0026#39;-1\u0026#39; ) ]); \u0026lt;/script\u0026gt; 其他写法 创建原生元素：\nimport { h } from \u0026#39;vue\u0026#39; // 除了 type 外，其他参数都是可选的 h(\u0026#39;div\u0026#39;) h(\u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }) // attribute 和 property 都可以用于 prop // Vue 会自动选择正确的方式来分配它 h(\u0026#39;div\u0026#39;, { class: \u0026#39;bar\u0026#39;, innerHTML: \u0026#39;hello\u0026#39; }) // class 与 style 可以像在模板中一样 // 用数组或对象的形式书写 h(\u0026#39;div\u0026#39;, { class: [foo, { bar }], style: { color: \u0026#39;red\u0026#39; } }) // 事件监听器应以 onXxx 的形式书写 h(\u0026#39;div\u0026#39;, { onClick: () =\u0026gt; {} }) // children 可以是一个字符串 h(\u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }, \u0026#39;hello\u0026#39;) // 没有 prop 时可以省略不写 h(\u0026#39;div\u0026#39;, \u0026#39;hello\u0026#39;) h(\u0026#39;div\u0026#39;, [h(\u0026#39;span\u0026#39;, \u0026#39;hello\u0026#39;)]) // children 数组可以同时包含 vnode 和字符串 h(\u0026#39;div\u0026#39;, [\u0026#39;hello\u0026#39;, h(\u0026#39;span\u0026#39;, \u0026#39;hello\u0026#39;)]) 创建组件：\nimport Foo from \u0026#39;./Foo.vue\u0026#39; // 传递 prop h(Foo, { // 等价于 some-prop=\u0026#34;hello\u0026#34; someProp: \u0026#39;hello\u0026#39;, // 等价于 @update=\u0026#34;() =\u0026gt; {}\u0026#34; onUpdate: () =\u0026gt; {} }) // 传递单个默认插槽 h(Foo, () =\u0026gt; \u0026#39;default slot\u0026#39;) // 传递具名插槽 // 注意，需要使用 `null` 来避免 // 插槽对象被当作是 prop h(MyComponent, null, { default: () =\u0026gt; \u0026#39;default slot\u0026#39;, foo: () =\u0026gt; h(\u0026#39;div\u0026#39;, \u0026#39;foo\u0026#39;), bar: () =\u0026gt; [h(\u0026#39;span\u0026#39;, \u0026#39;one\u0026#39;), h(\u0026#39;span\u0026#39;, \u0026#39;two\u0026#39;)] }) 函数组件和插槽的使用 \u0026lt;script\u0026gt; import { h } from \u0026#34;vue\u0026#34;; export default { render() { return h(\u0026#34;div\u0026#34;, null, [ h(\u0026#34;h2\u0026#34;, null, \u0026#34;Hello World\u0026#34;), this.$slots.default ? this.$slots.default({name: \u0026#34;coderwhy\u0026#34;}): h(\u0026#34;span\u0026#34;, null, \u0026#34;我是HelloWorld的插槽默认值\u0026#34;) ]) } } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34; scoped\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;template\u0026gt; \u0026lt;starRender /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { h } from \u0026#39;vue\u0026#39;; import HelloWorld from \u0026#39;./HelloWorld.vue\u0026#39;; const starRender = () =\u0026gt; h(\u0026#34;div\u0026#34;, null, [ h(HelloWorld, null, { default: props =\u0026gt; h(\u0026#34;span\u0026#34;, null, `app传入到HelloWorld中的内容: ${props.name}`) }) ]) \u0026lt;/script\u0026gt; Jsx JSX 是 JavaScript 的一个类似 XML 的扩展，有了它，我们可以用以下的方式来书写代码：\nconst vnode = \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt; 在 JSX 表达式中，使用大括号来嵌入动态值：\nconst vnode = \u0026lt;div id={dynamicId}\u0026gt;hello, {userName}\u0026lt;/div\u0026gt; 配置 vue-cli环境 npm install @vue/babel-plugin-jsx -D babel.config.js 中配置 vite环境 npm install @vitejs/plugin-vue-jsx -D vite.config.js 中配置 import { fileURLToPath, URL } from \u0026#39;node:url\u0026#39;; import { defineConfig } from \u0026#39;vite\u0026#39;; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; import jsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39;; export default defineConfig({ plugins: [vue(), jsx()], resolve: { alias: { \u0026#39;@\u0026#39;: fileURLToPath(new URL(\u0026#39;./src\u0026#39;, import.meta.url)) } } }); 基本使用 在render函数中 \u0026lt;!-- 1. 这里加上注明语言使用jsx --\u0026gt; \u0026lt;script lang=\u0026#34;jsx\u0026#34;\u0026gt; import Home from \u0026#39;./pages/home.vue\u0026#39;; export default { data() { return { counter: 0 }; }, render() { // 2. 返回jsx写法 return ( \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数:{this.counter}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.decrement}\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }, methods: { increment() { this.counter++; }, decrement() { this.counter--; } } }; \u0026lt;/script\u0026gt; 在setup函数中 \u0026lt;!-- 1. 这里加上注明语言使用jsx --\u0026gt; \u0026lt;script lang=\u0026#34;jsx\u0026#34;\u0026gt; export default { data() { return { counter: 0 }; }, render() { // 2. 返回jsx写法 return ( \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数:{this.counter}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.decrement}\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }, methods: { increment() { this.counter++; }, decrement() { this.counter--; } } }; \u0026lt;/script\u0026gt; 在setup语法糖中 \u0026lt;template\u0026gt; \u0026lt;!-- 3. 使用 --\u0026gt; \u0026lt;star-render /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 1. 这里加上注明语言使用jsx --\u0026gt; \u0026lt;script setup lang=\u0026#34;jsx\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; const counter = ref(0); const increment = () =\u0026gt; counter.value++; const decrement = () =\u0026gt; counter.value--; // 2. 拿到render函数 const starRender = () =\u0026gt; ( \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数:{counter.value}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={increment}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button onClick={decrement}\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); \u0026lt;/script\u0026gt; script setup语法糖 \u0026lt;script setup\u0026gt;是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，当同时使用 SFC 与组合式 API 时则推荐该语法\n更少的样板内容，更简洁的代码 能够使用纯 Typescript 声明 prop 和抛出事件 更好的运行时性能 更好的 IDE 类型推断性能 顶层的绑定会被暴露给模板 当使用 \u0026lt;script setup\u0026gt; 的时候，任何在\u0026lt;script setup\u0026gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 能在模板中直接使用, 导入的组件也可以直接使用\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ mes }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 1. 这里加上setup属性 --\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; // 定义数据后，template中可以直接使用，无需返回 const mes = ref(0); // 定义的方法也是，直接可被使用 const addClick = () =\u0026gt; { console.log(\u0026#39;hahah\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 2. 直接使用，不用通过compoents注册 --\u0026gt; \u0026lt;my-home\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // 1. 这是导入的组件 import myHome from \u0026#39;./myHome.vue\u0026#39;; \u0026lt;/script\u0026gt; defineProps() defineProps =\u0026gt; 用来接收从父组件传递过来的数据\n\u0026lt;template\u0026gt; \u0026lt;my-home name=\u0026#34;hello\u0026#34; :age=\u0026#34;18\u0026#34;\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import myHome from \u0026#39;./myHome.vue\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ name }} - {{ age }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // defineProps是内置组件，可以直接使用，不用导入 // 可以接收一下返回的props对象，也可以不用 const props = defineProps({ name: { type: String, default: \u0026#39;\u0026#39; }, age: { type: Number, default: 0 } }); console.log(props); // Proxy {name: \u0026#39;hello\u0026#39;, age: 18} \u0026lt;/script\u0026gt; defineEmits() defineProps =\u0026gt; 用来发射事件给父组件\n\u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;发送\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // 1. 注册一下发射的事件 const emits = defineEmits([\u0026#39;btnClick\u0026#39;]); // 2. 监听按钮的点击 const btnClick = () =\u0026gt; { // 3. 发射 emits(\u0026#39;btnClick\u0026#39;, \u0026#39;我发射了\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 1. 监听子组件发射来的事件 --\u0026gt; \u0026lt;my-home @btnClick=\u0026#34;handleClick\u0026#34;\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import myHome from \u0026#39;./myHome.vue\u0026#39;; // 2. 获取子组件传递过来的值 const handleClick = (message) =\u0026gt; { console.log(message); // 我发射了 }; \u0026lt;/script\u0026gt; defineExpose() defineExpose =\u0026gt; 用来暴露数据\nps : 使用 \u0026lt;script setup\u0026gt; 的组件是默认关闭的\n\u0026lt;script setup\u0026gt; const foo = () =\u0026gt; { console.log(\u0026#39;foo\u0026#39;); }; // 暴露出去，才可以被访问到 defineExpose({ foo }); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 1. 定义ref --\u0026gt; \u0026lt;my-home ref=\u0026#34;myHomeRef\u0026#34;\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; import myHome from \u0026#39;../../../Vue3/06_阶段六-Vue3全家桶实战/code/04_learn_composition/src/11_script_setup语法/myHome.vue\u0026#39;; // 2. 定义名称一样 const myHomeRef = ref(); onMounted(() =\u0026gt; { // 3. 在生命周期中访问 console.log(myHomeRef.value); }); \u0026lt;/script\u0026gt; 自定义组件 指令的生命周期 一个指令定义的对象，Vue提供了如下的几个钩子函数： created：在绑定元素的 attribute 或事件监听器被应用之前调用； beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用； mounted：在绑定元素的父组件被挂载后调用； beforeUpdate：在更新包含组件的 VNode 之前调用； updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用； beforeUnmount：在卸载绑定元素的父组件之前调用； unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次； 指令钩子 一个指令的定义对象可以提供几种钩子函数 (都是可选的)：\nconst myDirective = { // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode, prevVnode) { // 下面会介绍各个参数的细节 }, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode, prevVnode) {} } 指令的钩子会传递以下几种参数：\nel：指令绑定到的元素。这可以用于直接操作 DOM。 binding：一个对象，包含以下属性。 value：传递给指令的值。例如在 v-my-directive=\u0026quot;1 + 1\u0026quot; 中，值是 2。 oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。 arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 \u0026quot;foo\u0026quot;。 modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。 instance：使用该指令的组件实例。 dir：指令的定义对象。 vnode：代表绑定元素的底层 VNode。 prevNode：代表之前的渲染中指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。 举例来说，像下面这样使用指令：\n\u0026lt;div v-example:foo.bar=\u0026#34;baz\u0026#34;\u0026gt; binding 参数会是一个这样的对象：\n{ arg: \u0026#39;foo\u0026#39;, modifiers: { bar: true }, value: /* `baz` 的值 */, oldValue: /* 上一次更新时 `baz` 的值 */ } 和内置指令类似，自定义指令的参数也可以是动态的。举例来说：\n\u0026lt;div v-example:[arg]=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 这里指令的参数会基于组件的 arg 数据属性响应式地更新。\n除了 el 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 dataset attribute 实现。\n简单使用 Vue中自带的指令例如v-show、v-for、v-model等等，除了使用这些指令之外，Vue 也允许我们来自定义自己的指令\nps : 一般需要对dom元素进行底层操作时使用\n自定义指令分为两种： 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用； 自定义全局指令：app的 directive 方法，可以在任意组件中被使用； 默认实现方式 一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：\n\u0026lt;script setup\u0026gt; // 在模板中启用 v-focus const vFocus = { mounted: (el) =\u0026gt; el.focus() } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input v-focus /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inputRef\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; const inputRef = ref(null); onMounted(() =\u0026gt; { inputRef.value.focus(); }); \u0026lt;/script\u0026gt; 使用局部指令 在 \u0026lt;script setup\u0026gt; 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，vFocus 即可以在模板中以 v-focus 的形式使用。\n在没有使用 \u0026lt;script setup\u0026gt; 的情况下，自定义指令需要通过 directives 选项注册：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-focus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { // 局部指令 directives: { focus: { mounted(el, bindings, vnode, preVnode) { console.log(\u0026#34;focus mounted\u0026#34;); el.focus(); } } } } \u0026lt;/script\u0026gt; 自定义全局指令 main.js中注册 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) // 指令名称 app.directive(\u0026#39;focus\u0026#39;, { // 使用自定义指令的生命周期，挂载后访问 mounted(el, bindings, vnode, preVnode) { el?.focus() } }) app.mount(\u0026#39;#app\u0026#39;) 进行抽取 注册directives文件夹 /directives/format-time.js import dayjs from \u0026#39;dayjs\u0026#39;; export default function(app) { app.directive(\u0026#34;format-time\u0026#34;, { created(el, bindings) { bindings.formatString = \u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;; if (bindings.value) { bindings.formatString = bindings.value; } }, mounted(el, bindings) { const textContent = el.textContent; let timestamp = parseInt(textContent); if (textContent.length === 10) { timestamp = timestamp * 1000 } el.textContent = dayjs(timestamp).format(bindings.formatString); } }) } /directives/index.js import registerFormatTime from \u0026#39;./format-time\u0026#39;; export default function registerDirectives(app) { registerFormatTime(app); } mian.js import registerDirectives from \u0026#39;./directives\u0026#39; registerDirectives(app); setup 函数 \u0026lt;template\u0026gt; \u0026lt;h1 v-fomat-time=\u0026#34;timeFormatType\u0026#34;\u0026gt;{{ timeStamp }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import dayJs from \u0026#39;dayjs\u0026#39; export default { directives: { \u0026#39;fomat-time\u0026#39;: { mounted(el, bindings) { // 默认显示时间类型 let formatType = bindings.value console.log(formatType) // 转换成number类型 let time = el.textContent.length === 10 ? el.textContent * 1000 : el.textContent * 1; // 格式化 el.textContent = dayJs(time).format(formatType) setInterval(() =\u0026gt; { // 定时器 time = dayJs(new Date().valueOf()).format(formatType) el.textContent = time }, 1000) } } }, setup() { // 设置初始时间戳 const timeStamp = ref(new Date().valueOf()) const timeFormatType = ref(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return { timeStamp, timeFormatType } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-image: linear-gradient(to right, red, blue); } \u0026lt;/style\u0026gt; 语法糖 \u0026lt;template\u0026gt; \u0026lt;h1 v-fomat-time=\u0026#34;timeFormatType\u0026#34;\u0026gt;{{ timeStamp }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; import dayJs from \u0026#39;dayjs\u0026#39;; // 设置初始时间戳 const timeStamp = ref(new Date().valueOf()); // 设置初始时间格式 const timeFormatType = ref(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;); // 自定义时间格式化指令 const vFomatTime = { mounted(el, bindings) { // 获取定义的时间格式 const { value: timeFormatType } = bindings; // 转换成number类型 let time = el.textContent.length === 10 ? el.textContent * 1000 : el.textContent * 1; // 使用dayJs，根据时间格式来格式化时间,并赋值给el el.textContent = dayJs(time).format(timeFormatType); // 定时器，每隔一秒，重新赋值给el setInterval(() =\u0026gt; { time = dayJs(new Date().valueOf()).format(timeFormatType); el.textContent = time; }, 1000); } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, blue); } \u0026lt;/style\u0026gt; 内置组件 Teleport \u0026lt;Teleport\u0026gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。\n在某些情况下，希望组件不是挂载在当前组件树上的，可能是移动到Vue app之外的其他位置 比如移动到body元素上，或者我们有其他的div#app之外的元素上 可以通过teleport来完成 teleport 翻译过来是心灵传输、远距离运输的意思，有两个属性 to : 指定将其中的内容移动到的目标元素，可以使用选择器 disabled : 是否禁用 teleport 的功能 基本使用 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;!-- 把该组件挂载到body元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, green, pink, yellow, blue); } \u0026lt;/style\u0026gt; 挂载到#app之外的指定元素上 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;star\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 把该组件挂载到#star元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;#star\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;!-- 把该组件挂载到.b元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;.b\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport123\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;!-- 文档上说是挂载到#app之外的元素，可是我发现自己内部的也可以指定，emmmm，优先是从内部一层层往外找的 --\u0026gt; \u0026lt;!-- 把该组件挂载到.c元素上... --\u0026gt; \u0026lt;teleport to=\u0026#34;.c\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport123\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, green, pink, yellow, blue); } \u0026lt;/style\u0026gt; 多个Teleport 会合并，谁先谁在前面\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;star\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;!-- 把该组件挂载到#star元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;#star\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 把该组件挂载到#star元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;#star\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport123\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, green, pink, yellow, blue); } \u0026lt;/style\u0026gt; 其他 异步组件 defineAsyncComponent/ Suspense : 实验特性 动态组件 : component\nVue插件 https://cn.vuejs.org/guide/reusability/plugins.html#plugins\n通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式： 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行； 函数类型：一个function，这个函数会在安装插件时自动执行； 插件可以完成的功能没有限制，比如下面的几种都是可以的： 添加全局方法或者property，通过把它们添加到 config.globalProperties 上实现； 添加全局资源：指令/过滤器/过渡等； 通过全局 mixin 来添加一些组件选项； 一个库，提供自己的 API，同时提供上面提到的一个或多个功能； 对象类型 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行\napp.use({ install(app) { console.log(\u0026#39;对象方式，插件被调用了\u0026#39;, app); } }); 函数类型 函数类型：一个function，这个函数会在安装插件时自动执行\napp.use(function(app){ console.log(\u0026#39;函数方式，插件被调用了\u0026#39;, app); }) 改写自定义指令 import { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; // 1. 导入指令方法 import installDirectives from \u0026#39;./directives\u0026#39;; // 2。 注册所有指令 // installDirectives(app); // 这样使用use方法注册指令，因为传入的是一个函数，所以会自动执行 // 并且会把app实例传入，这样就可以在函数内部注册指令了 createApp(App).use(installDirectives).mount(\u0026#39;#app\u0026#39;); ","permalink":"https://waite.wang/posts/vue/vue3-compositionapi/","summary":"\u003ch2 id=\"options-api的弊端\"\u003eOptions API的弊端\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在Vue2中，我们编写组件的方式是Options API：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOptions API的一大特点就是在对应的属性中编写对应的功能模块；\u003c/li\u003e\n\u003cli\u003e比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e但是这种代码有一个很大的弊端：\u003c/p\u003e","title":"Vue3 CompositionAPI"},{"content":" Typora 免费版本: https://cloud.waite.wang/Cloud/%E5%B7%A5%E5%85%B7/typora-setup-x64.exe\n七牛云 七牛云: https://www.qiniu.com/\n注册实名 2. 对象存储, 新建空间 选择离你最近的存储区域(建议服务器哪的就选哪个区) 访问控制选择公有 个人中心 \u0026gt; 密钥管理 \u0026gt; 复制待用 PicGo https://github.com/Molunerfinn/PicGo\n图床设置 - 七牛云 AccessKey和SecretKey是AK和SK\nBucket是空间名称 + 访问网址是http://后面加上七牛云给的临时域名\n确定 设置为默认图床 Typora 文件 \u0026gt; 偏好设置 \u0026gt; 图像 验证图片上传选项 ","permalink":"https://waite.wang/posts/tools/qiniucloud-typora-picgo/","summary":"\u003cblockquote\u003e\n\u003cp\u003eTypora 免费版本: \u003ca href=\"https://cloud.waite.wang/Cloud/%E5%B7%A5%E5%85%B7/typora-setup-x64.exe\"\u003ehttps://cloud.waite.wang/Cloud/%E5%B7%A5%E5%85%B7/typora-setup-x64.exe\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"七牛云\"\u003e七牛云\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e七牛云: \u003ca href=\"https://www.qiniu.com/\"\u003ehttps://www.qiniu.com/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e注册实名 2. 对象存储, 新建空间\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"http://qiniu.waite.wang/1.png\"\u003e\n    \u003cimg src=\"http://qiniu.waite.wang/1.png\" alt=\"1\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e选择离你最近的存储区域(建议服务器哪的就选哪个区) 访问控制选择公有\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"http://qiniu.waite.wang/image-20230529224621032.png\"\u003e\n    \u003cimg src=\"http://qiniu.waite.wang/image-20230529224621032.png\" alt=\"image-20230529224621032\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e个人中心 \u0026gt; 密钥管理 \u0026gt; 复制待用\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"http://qiniu.waite.wang/image-20230529224726314.png\"\u003e\n    \u003cimg src=\"http://qiniu.waite.wang/image-20230529224726314.png\" alt=\"image-20230529224726314\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e","title":"七牛云 + Typora + PicGo"},{"content":"pinia需要使用pinia-plugin-persistedstate插件来进行数据的存储 插件官网地址： https://prazdevs.github.io/pinia-plugin-persistedstate/guide/config.html\n安装以及使用 pnpm i pinia-plugin-persistedstate npm i pinia-plugin-persistedstate yarn add pinia-plugin-persistedstate import { createPinia } from \u0026#39;pinia\u0026#39; import piniaPluginPersistedstate from \u0026#39;pinia-plugin-persistedstate\u0026#39; const pinia = createPinia() pinia.use(piniaPluginPersistedstate) 关于全部缓存及部分缓存的说明 （1）将store的state中的全部数据进行缓存，直接在state同级下面添加persist对象\n此时，默认将数据存放在浏览器的SessionStorage中，key为store的名称，value为该store中所有的数据\n（2）将store的state中的数据进行部分缓存 此时需要在persist中添加strategies数组，\n每个元素的key是想要储存的数据变量名（在state中定义的），storage可以写sessionStorage或者localStorage，此时，sessionStorage中的key就是变量名，value就是该变量的值\n","permalink":"https://waite.wang/posts/web/pinia-plugin-persistedstate/","summary":"\u003cp\u003epinia需要使用pinia-plugin-persistedstate插件来进行数据的存储\n插件官网地址：\n\u003ca href=\"https://prazdevs.github.io/pinia-plugin-persistedstate/guide/config.html\"\u003ehttps://prazdevs.github.io/pinia-plugin-persistedstate/guide/config.html\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"安装以及使用\"\u003e安装以及使用\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epnpm i pinia-plugin-persistedstate\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enpm i pinia-plugin-persistedstate\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eyarn add pinia-plugin-persistedstate\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eimport\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nx\"\u003ecreatePinia\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"kr\"\u003efrom\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;pinia\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003eimport\u003c/span\u003e \u003cspan class=\"nx\"\u003epiniaPluginPersistedstate\u003c/span\u003e \u003cspan class=\"kr\"\u003efrom\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;pinia-plugin-persistedstate\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003epinia\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecreatePinia\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nx\"\u003epinia\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003euse\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003epiniaPluginPersistedstate\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"关于全部缓存及部分缓存的说明\"\u003e关于全部缓存及部分缓存的说明\u003c/h2\u003e\n\u003cp\u003e（1）将store的state中的全部数据进行缓存，直接在state同级下面添加persist对象\u003c/p\u003e","title":"Pinia 数据持久化储存（pinia-plugin-persistedstate）"},{"content":"为什么使用 Pinia? https://pinia.vuejs.org/zh/\nPinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 export const state = reactive({}) 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能：\nDevtools 支持 追踪 actions、mutations 的时间线 在组件中展示它们所用到的 Store 让调试更容易的 Time travel 热更新 不必重载页面即可修改 Store 开发时可保持当前的 State 插件：可通过插件扩展 Pinia 功能 为 JS 开发者提供适当的 TypeScript 支持以及自动补全功能。 支持服务端渲染 简单使用 安装 yarn add pinia npm install pinia 在mian.js中，创建根存储\nimport { createPinia } from \u0026#39;pinia\u0026#39; app.use(createPinia() 创建store store实例相当于一个容器，里面存放的有类似于data，计算属性，方法之类的东西。通过defineStore()方法定义\n在src下面创建一个store文件夹，再创建与之对应的js文件，比如``counter.js`\n// option store import { defineStore } from \u0026#34;pinia\u0026#34; export const useCouterStore = defineStore(\u0026#39;counter\u0026#39;, { state: () =\u0026gt; ({ count: 0, }), getters: { doubleCount: (state) =\u0026gt; state.count * 2, }, actions: { increment() { this.count++ } } } ) import { defineStore } from \u0026#34;pinia\u0026#34; import { ref, computed } from \u0026#39;vue\u0026#39; export const useCouterStore = defineStore(\u0026#39;counter\u0026#39;, () =\u0026gt; { // 定义数据 const count = ref(0) // 定义修改数据的方法 (actions 同步加异步) const increment = () =\u0026gt; count.value++ // getters 计算属性 const double = computed(() =\u0026gt; count.value * 2) // 以对象的方式返回以供组件使用 return { count, increment } }) 使用store \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;counterStore.increment\u0026#34;\u0026gt;{{ counterStore.count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useCouterStore } from \u0026#39;./store/counter\u0026#39;; const counterStore = useCouterStore(); console.log(counterStore); \u0026lt;/script\u0026gt; State 读取state import { storeToRefs } from \u0026#39;pinia\u0026#39; const userStore = useUser() // 如果直接解构出数据，这个数据不是响应式的。如果想要变成响应式的，需要调用storeToRefs方法 const { userName, avatar } = storeToRefs(userStore) 修改state userStore.userName = \u0026#39;张三\u0026#39; 重置 state 使用选项式 API 时，你可以通过调用 store 的 $reset() 方法将 state 重置为初始值。\n在 $reset() 内部，会调用 state() 函数来创建一个新的状态对象，并用它替换当前状态。\nconst store = useStore() store.$reset() 变更 state 除了用 store.count++ 直接改变 store，你还可以调用 $patch 方法。它允许你用一个 state 的补丁对象在同一时间更改多个属性：\nstore.$patch({ count: store.count + 1, age: 120, name: \u0026#39;DIO\u0026#39;, }) 不过，用这种语法的话，有些变更真的很难实现或者很耗时：任何集合的修改（例如，向数组中添加、移除一个元素或是做 splice 操作）都需要你创建一个新的集合。因此，$patch 方法也接受一个函数来组合这种难以用补丁对象实现的变更。\nstore.$patch((state) =\u0026gt; { state.items.push({ name: \u0026#39;shoes\u0026#39;, quantity: 1 }) state.hasChanged = true }) 两种变更 store 方法的主要区别是，$patch() 允许你将多个变更归入 devtools 的同一个条目中\n你可以在 pinia 实例上使用 watch() 函数侦听整个 state。\nwatch( pinia.state, (state) =\u0026gt; { // 每当状态发生变化时，将整个 state 持久化到本地存储。 localStorage.setItem(\u0026#39;piniaState\u0026#39;, JSON.stringify(state)) }, { deep: true } ) getters 基础使用 类似计算属性。推荐里面传递一个形参的写法，不容易出错。\ngetters: { isAdult: (state) =\u0026gt; { return state.age \u0026gt;= 18 ? \u0026#39;成年人\u0026#39; : \u0026#39;未成年\u0026#39; } } // 直接获取 \u0026lt;div\u0026gt;{{userStore.isAdult}}\u0026lt;/div\u0026gt; 调用本模块其他 getters getters: { isAdult: (state) =\u0026gt; { return state.age \u0026gt;= 18 ? \u0026#39;成年人\u0026#39; : \u0026#39;未成年\u0026#39; }, msg: (state) =\u0026gt; { // msg这个getter访问了自身的getter（isAdult） return state.userName + state.isAdult } } getters传参 getters: { isAdmin: (state) =\u0026gt; { // 如果getter里面是返回的函数，那么它就可以传参数了 return (name) =\u0026gt; name === \u0026#39;admin\u0026#39; ? \u0026#39;是管理员\u0026#39; : \u0026#39;不是管理员\u0026#39; } } {{userStore.isAdmin}} 调用其他store里面的getter // goods.js import { defineStore } from \u0026#39;pinia\u0026#39; // 第一个参数是应用程序中 store 的唯一 id // 第二个参数是配置对象 export const useGoods = defineStore(\u0026#39;goods\u0026#39;, { // state是一个函数，返回一个对象 state: () =\u0026gt; { return { goodsName: \u0026#39;iphone\u0026#39; } }, getters: { newIphone: (state) =\u0026gt; { return state.goodsName + \u0026#39; 14 pro\u0026#39; } } }) import { useGoods } from \u0026#39;./goods.js\u0026#39; // .......... getters: { info: (state) =\u0026gt; { // 获取goods模块的store const goodsStore = useGoods() return state.userName + \u0026#39;买了\u0026#39; + goodsStore.newIphone } } actions Action 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义，并且它们也是定义业务逻辑的完美选择。\nexport const useCounterStore = defineStore(\u0026#39;main\u0026#39;, { state: () =\u0026gt; ({ count: 0, }), actions: { increment() { this.count++ }, randomizeCounter() { this.count = Math.round(100 * Math.random()) }, }, }) 类似 getter，action 也可通过 this 访问整个 store 实例，并支持完整的类型标注(以及自动补全✨)。不同的是，action 可以是异步的，你可以在它们里面 await 调用任何 API，以及其他 action！下面是一个使用 Mande 的例子。请注意，你使用什么库并不重要，只要你得到的是一个Promise，你甚至可以 (在浏览器中) 使用原生 fetch 函数：\nimport { mande } from \u0026#39;mande\u0026#39; const api = mande(\u0026#39;/api/users\u0026#39;) export const useUsers = defineStore(\u0026#39;users\u0026#39;, { state: () =\u0026gt; ({ userData: null, // ... }), actions: { async registerUser(login, password) { try { this.userData = await api.post({ login, password }) showTooltip(`Welcome back ${this.userData.name}!`) } catch (error) { showTooltip(error) // 让表单组件显示错误 return error } }, }, }) 你也完全可以自由地设置任何你想要的参数以及返回任何结果。当调用 action 时，一切类型也都是可以被自动推断出来的。\nAction 可以像函数或者通常意义上的方法一样被调用：\n\u0026lt;script setup\u0026gt; const store = useCounterStore() // 将 action 作为 store 的方法进行调用 store.randomizeCounter() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 即使在模板中也可以 --\u0026gt; \u0026lt;button @click=\u0026#34;store.randomizeCounter()\u0026#34;\u0026gt;Randomize\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 想要使用另一个 store 的话，那你直接在 action 中调用就好了：\nimport { useAuthStore } from \u0026#39;./auth-store\u0026#39; export const useSettingsStore = defineStore(\u0026#39;settings\u0026#39;, { state: () =\u0026gt; ({ preferences: null, // ... }), actions: { async fetchUserPreferences() { const auth = useAuthStore() if (auth.isAuthenticated) { this.preferences = await fetchPreferences() } else { throw new Error(\u0026#39;User must be authenticated\u0026#39;) } }, }, }) 模块化 在实际开发中，不可能把多个模块的数据都定义到一个store中，而是一个模块对应一个store，最后通过一个根store进行整合\n1.随便建立两个store，并导出\n// 模块一 import { defineStore } from \u0026#39;pinia\u0026#39; const useUserStore = defineStore(\u0026#39;user\u0026#39;, { state: () =\u0026gt; { return { name: \u0026#39;haha\u0026#39;, age: 18, } }, }) export default useUserStore // 模块二 import { defineStore } from \u0026#39;pinia\u0026#39; const useCounterStore = defineStore(\u0026#39;user\u0026#39;, { state: () =\u0026gt; { return { count: 1 } }, }) export default useUserStore 新建store/index.js import useUserStore from \u0026#39;./user\u0026#39; import useCounterStore from \u0026#39;./counter\u0026#39; // 统一导出useStore方法 export default function useStore() { return { user: useUserStore(), counter: useCounterStore(), } } 组件中使用 \u0026lt;script setup\u0026gt; import { storeToRefs } from \u0026#39;pinia\u0026#39; import useStore from \u0026#39;./store\u0026#39; const { counter } = useStore() // 使用storeToRefs可以保证解构出来的数据也是响应式的 const { count } = storeToRefs(counter) \u0026lt;/script\u0026gt; ","permalink":"https://waite.wang/posts/vue/system-learn-pinia-1/","summary":"\u003ch2 id=\"为什么使用-pinia\"\u003e为什么使用 Pinia?\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://pinia.vuejs.org/zh/\"\u003ehttps://pinia.vuejs.org/zh/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 \u003ccode\u003eexport const state = reactive({})\u003c/code\u003e 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能：\u003c/p\u003e","title":"系统学习 Pinia"},{"content":"Vue2-VueX 1.vuex介绍 目标 什么是vuex 为什么学习vuex 通信方案 组件关系 数据通信 父子关系 父传子：props ； 子传父：$emit 非父子关系 vuex (一种组件通信方案) vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理数据，以相应的规则保证状态以一种可预测的方式发生变化\nvuex为何学 程序页面多, 数据变量多\n不同组件数据保持同步 数据的修改都是可追踪 一个户外商店有两名员工，张三和李四\n一天的早上，他们分别对帐篷的数量做了一次盘点，发现一共有三个帐篷\n张三卖出去俩个，他以为库存里还有一个\n李四卖出去一个，他以为库存里还有两个\n而事实上是，库存现在已经为零\n如果他们再接受客户的预订，就会出现库存不足的情况\n张三和李四因为没有保持库存的数量的同步导致了尴尬，这个就是所谓的数据保持同步\n店长需要知道, 谁卖出了多少个帐篷，这个行为我们称之为数据修改是可追踪的\n图示:\nvuex中存什么 多个组件共享状态，才存储在vuex中\n某个组件中的私有数据，依旧存储在data中\n例如：\n登陆的用户名需要在首页, 个人中心, 结算页面使用, 用户名存在vuex中\n文章详情数据, 只有在文章详情页查看, 在自身data中声明\n小结 什么是vuex vuex是Vue官方推荐的集中式状态管理机制 为何学vuex 数据同步, 集中管理 vuex中存什么 多个组件共享的值 2.vuex学习内容 目标 知道vuex要学习什么 核心概念 官网地址: https://vuex.vuejs.org/zh/\n安装(固定)\n配置项(固定)\n配置项 含义 注意 state 单一状态树 类似data mutations 数据管家(同步) 唯一修改state地方 actions 异步请求 要改state需要提交给mutations getters vuex计算属性 类似computed modules 模块拆分 图示关系 单一定义store对象, 里面5个配置项, 在任意组件可以使用\n小结 vuex五个核心概念是? state / mutations / actions / getters / modules 3.vuex例子准备 目标 创建项目, 为学习准备 需求1: App.vue(作为根组件)\n需求2: 子组件Add和子组件Sub, 嵌入在App.vue里\n需求3: 三个组件共享库存数据(保持同步)\n工程准备 初始化新的工程 vuex-demo\nvue create vuex-demo 清空欢迎界面\n并设置如下三个组件, 目录如下：\n|-components |---AddItem.vue |---SubItem.vue |-App.vue App.vue 复制标签和样式, 引入AddItem和SubItem2个子组件显示\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;根组件\u0026lt;/h1\u0026gt; \u0026lt;span\u0026gt;库存总数:\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;border:1px solid black; width: 300px;\u0026#34;\u0026gt; \u0026lt;AddItem\u0026gt;\u0026lt;/AddItem\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div style=\u0026#34;border:1px solid black; width: 300px;\u0026#34;\u0026gt; \u0026lt;SubItem\u0026gt;\u0026lt;/SubItem\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import AddItem from \u0026#39;@/components/AddItem\u0026#39; import SubItem from \u0026#39;@/components/SubItem\u0026#39; export default { components: { AddItem, SubItem } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #app { width: 300px; margin: 20px auto; border:1px solid #ccc; padding:4px; } \u0026lt;/style\u0026gt; AddItem.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;AddItem组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;已知库存数: 0\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;库存+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; SubItem.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;SubItem组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;已知库存数: 0\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;库存-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; 小结 App下套用了AddItem和SubItem, 要在3个组件共享一个数据 4.vuex-store准备 目标 创建store仓库 注入到Vue项目中 store概念 每个 Vuex 应用的核心 store（仓库）, 包含5个核心概念\nvuex目录 和路由模块router/index.js - 类似, 维护项目目录的整洁，新建src/store/index.js文件\n当然， 这个步骤并不是必需的\n使用步骤 工程中 - 下载vuex\nyarn add vuex store/index.js - 创建定义导出store对象\n// 目标: 创建store仓库对象 // 1. 下载vuex: 终端命令(yarn add vuex) // 2. 引入vuex import Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;vuex\u0026#39; // 3. 注册 Vue.use(Vuex) // 4. 实例化store对象 const store = new Vuex.Store({}) // 5. 导出store对象 export default store main.js - 导入注入到Vue中\nimport Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import store from \u0026#39;@/store\u0026#39; // 导入store对象 Vue.config.productionTip = false new Vue({ // 6. 注入到Vue实例中(确保组件this.$store使用) // this.$store = store store, render: h =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;) 请再次回忆一下vue-router的用法，是不是很像？\n小结 vuex的核心是什么?\nstore对象(包含5个核心属性) 如何创建store对象?\n工程下载vuex模块 store/index.js 引入注册 生成store对象导出 main.js - 导入注入 5.vuex-state数据源 目标 定义state 直接使用state 辅助函数mapState state是唯一的公共数据源，统一存储\n定义state 在store/index.js定义state\n语法:\n/* const store = new Vuex.Store({ state: { 变量名: 初始值 } }) */ 具体代码:\nconst store = new Vuex.Store({ state: { count: 100 // 库存 } }) 使用state2种方式 方式1: 组件内 - 直接使用\n语法:\nthis.$store.state.变量名 方式2: 组件内 - 映射使用 (推荐)\n语法:\n// 1. 拿到mapState辅助函数 import { mapState } from \u0026#39;vuex\u0026#39; export default { computed: { // 2. 把state里变量映射到计算属性中 ...mapState([\u0026#39;state里的变量名\u0026#39;]) } } AddItem直接用 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;AddItem组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;已知库存数: {{ $store.state.count }}\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;库存+1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; App.vue直接用 计算属性count, 和输入框的v-model双向绑定\n\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;count\u0026#34;\u0026gt; \u0026lt;script\u0026gt; export default { computed: { count: { set(){}, get(){ return this.$store.state.count } } } } \u0026lt;/script\u0026gt; SubItem映射用 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;SubItem组件\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;已知库存数: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button\u0026gt;库存-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 需求1: 映射state到计算属性 // 1. 拿到辅助函数 mapState // 2. 在computed内, ...mapState([\u0026#39;state变量名\u0026#39;]) // 3. 当计算属性使用 import { mapState } from \u0026#39;vuex\u0026#39; // let r = mapState([\u0026#39;count\u0026#39;]) // 提取store里的state叫count的变量 // console.log(r); // 返回值: {count: 函数体(return state里count的值)} export default { computed: { // 映射count, 得到对象展开, 合并到计算属性中 ...mapState([\u0026#39;count\u0026#39;]) }, } \u0026lt;/script\u0026gt; 整个过程的示意图如下\n注意 state是响应式的, 只要state值变化, 页面上使用的地方会自动更新同步\n小结 state作用?\n定义全局状态数据源\nstate如何定义?\n在store内, state: {变量名: 初始值}\nstate的值如何用到具体vue组件内?\n直接使用 this.$store.state.变量名 映射使用 \u0026hellip;mapState([\u0026lsquo;state的变量名\u0026rsquo;]) 6.vuex-mutations定义-同步修改 目标 定义mutations 定义mutations mutations类似数据管家, 操作state里的数据\n在store/index.js定义mutations\n语法:\n/* const store = new Vuex.Store({ mutations: { 函数名 (state, 可选值) { // 同步修改state值代码 } } }) */ 具体代码\nconst store = new Vuex.Store({ state: { count: 100 // 库存 }, mutations: { addCount (state, value) { // 负责增加库存的管家 state.count += value }, subCount (state, value) { // 负责减少库存的管家 state.count -= value }, setCount (state, value) { // 负责直接修改库存的管家 state.count = value; } } }) 注意 mutations是唯一能修改state的地方, 确保调试工具可以追踪变化 mutations函数内, 只能写同步代码, 调试工具可追踪变化过程 因为调试工具要立刻产生一次记录, 所以必须是同步的 小结 mutations里函数作用?\n负责修改state里的数据 mutations只能写什么样的代码?\n同步流程的代码 7.vuex-mutations使用 目标 使用mutations2种方式 mutations注意事项 使用mutations的2种方式 方式1: 组件内 - 直接使用\n语法:\nthis.$store.commit(\u0026#34;mutations里的函数名\u0026#34;, 具体值) 方式2: 组件内 - 映射使用\n语法:\n// 1. 拿到mapMutations辅助函数 import { mapMutations } from \u0026#39;vuex\u0026#39; export default { methods: { // 2. 把mutations里方法映射到原地 ...mapMutations([\u0026#39;mutations里的函数名\u0026#39;]) } } AddItem直接用 点击事件绑定 提交mutations传入值 \u0026lt;button @click=\u0026#34;addFn\u0026#34;\u0026gt;库存+1\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; export default { methods: { addFn(){ this.$store.commit(\u0026#39;addCount\u0026#39;, 1) } } } \u0026lt;/script\u0026gt; App.vue直接用 触发计算属性的set方法 提交mutations传入值 \u0026lt;span\u0026gt;库存总数: \u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;count\u0026#34;\u0026gt; \u0026lt;script\u0026gt; export default { computed: { count: { set(val){ this.$store.commit(\u0026#39;setCount\u0026#39;, val) // 把表单值提交给store下的mutations }, get(){ return this.$store.state.count } } } } \u0026lt;/script\u0026gt; SubItem映射用 点击事件 映射mutations的方法 调用mutations方法传值 \u0026lt;button @click=\u0026#34;subFn\u0026#34;\u0026gt;库存-1\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 需求2: 映射mutations到方法里 // 1. 拿到辅助函数 mapMutations // 2. 在methods内, ...mapMutations([\u0026#39;mutations函数名\u0026#39;]) // 3. 当普通方法使用 import { mapMutations } from \u0026#39;vuex\u0026#39; export default { methods: { ...mapMutations([\u0026#39;subCount\u0026#39;]), subFn(){ this.subCount(1) } } } \u0026lt;/script\u0026gt; 注意 mutations函数上, 只能接收一个参数值, 如果传对个, 请传一个对象\n小结 mutations有哪2种使用方式?\n直接使用 this.$store.commit()\n映射使用 mapMutations把方法映射到组件内直接调用\nstate, mutations, 视图组件, 3个关系是什么?\n8.vuex-actions定义-异步修改 目标 定义actions 定义actions 在store/index.js定义actions\n语法:\n/* const store = new Vuex.Store({ actions: { 函数名 (store, 可选值) { // 异步代码, 把结果commit给mutations给state赋值 } } }) */ 具体代码:\nconst store = new Vuex.Store({ // ...省略state和mutations此处 actions: { asyncAddCount(store, num){ setTimeout(() =\u0026gt; { // 1秒后, 异步提交给add的mutations store.commit(\u0026#39;addCount\u0026#39;, num) }, 1000) }, asyncSubCount(store, num) { setTimeout(() =\u0026gt; { // 1秒后, 异步提交给sub的mutations store.commit(\u0026#39;subCount\u0026#39;, num) }, 1000) } } }) 小结 actions和mutations区别?\nmutations里同步修改state\nactions里放入异步操作\nactions是否能操作state?\n不建议, 要commit给mutations(为调试工具可追踪)\nactions和mutations里函数, 第一个形参分别是什么?\nmutations的是state\nactions的是store\n9.vuex-actions使用 目标 使用actions 使用actions的2种方式 方式1: 组件内 - 直接使用\n语法:\nthis.$store.dispatch(\u0026#39;actions函数名\u0026#39;, 具体值) 方式2: 组件内 - 映射使用\n语法:\n// 1. 拿到mapActions辅助函数 import { mapActions } from \u0026#39;vuex\u0026#39; export default { methods: { // 2. 把actions里方法映射到原地 ...mapActions([\u0026#39;actions里的函数名\u0026#39;]) } } AddItem直接用 点击事件 dispatch触发action \u0026lt;button @click=\u0026#34;asyncAddFn\u0026#34;\u0026gt;延迟1秒, 库存+5\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; export default { methods: { asyncAddFn(){ this.$store.dispatch(\u0026#39;asyncAddCount\u0026#39;, 5) } } } \u0026lt;/script\u0026gt; SubItem映射用 点击事件 映射actions的方法 调用actions的方法传值 \u0026lt;button @click=\u0026#34;asyncSubFn\u0026#34;\u0026gt;延迟1秒, 库存-5\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 需求3: 映射actions到方法里 // 1. 拿到辅助函数 mapActions // 2. 在methods内, ...mapActions([\u0026#39;actions函数名\u0026#39;]) // 3. 当普通方法使用 import { mapActions } from \u0026#39;vuex\u0026#39; export default { methods: { ...mapActions([\u0026#39;asyncSubCount\u0026#39;]), asyncSubFn(){ this.asyncSubCount(5) } } } \u0026lt;/script\u0026gt; 小结 actions使用方式?\n方式1: this.$store.dispatch(\u0026lsquo;actions方法名字\u0026rsquo;, 值)\n方式2: \u0026hellip;mapActions([\u0026lsquo;actions里的方法名\u0026rsquo;]) 映射到原地使用\n视图组件, state, mutations, actions的关系是?\n10.vuex-重构购物车-准备Store 目标 在现有项目如何集成vuex store准备 复制预习资料\u0026lt;shopcar-模板\u0026gt;到自己今天文件夹下 下载vuex store/index.js创建导出store对象 main.js把store引入, 然后注入到Vue实例 小结 现有项目如何集成vuex\n下载vuex\n创建store对象并注入到Vue实例中\n11.vuex-重构购物车-配置项(上午结束) 目标 准备state和mutations还有actions 配置项准备 定义state - 保存商品列表数组 state: { goodsList: [] // 列表 } 定义mutations - 给state里变量赋值 mutations: { setGoodsList(state, newList) { state.goodsList = newList } } 定义actions - 异步请求数据提交给mutations actions: { async asyncGetGoodsList(store) { const url = `https://www.escook.cn/api/cart` // 发送异步请求 const res = await axios({ url: url }); store.commit(\u0026#39;setGoodsList\u0026#39;, res.data.list) // 提交mutation修改state中的数据 } } App.vue使用vuex 把vuex商品数组映射回来使用 网络请求调用actions方法 \u0026lt;script\u0026gt; import { mapState, mapActions } from \u0026#39;vuex\u0026#39; export default { computed: { ...mapState({list: \u0026#39;goodsList\u0026#39;}) // 自定义原地属性名list, 映射vuex里的goodsList变量值 }, created(){ this.asyncGetGoodsList() }, methods: { ...mapActions([\u0026#39;asyncGetGoodsList\u0026#39;]), allFn(bool){ this.list.forEach(obj =\u0026gt; obj.goods_state = bool) } } } \u0026lt;/script\u0026gt; 小结 mapState可以改变映射到原地的计算属性名吗?\n可以的, 格式\u0026hellip;mapState({\u0026lsquo;\u0026lsquo;计算属性名\u0026rsquo;, \u0026lsquo;state里要映射的变量名\u0026rsquo;})\n12.vuex-getters定义-计算属性 目标 getters概念 定义getters getters概念 vuex身上的全局状态-计算属性, 类似于computed\ngetters 依赖于 state中原始数据的变化，并返回计算后的新数据\n定义getters 在store/index.js定义getters\n语法:\n/* const store = new Vuex.Store({ getters: { 计算属性名 (state) { return 值给计算属性 } } }) */ 具体代码\nconst store = new Vuex.Store({ // ...省略其他 getters: { allCount(state) { return state.goodsList.reduce((sum, obj) =\u0026gt; { if (obj.goods_state === true) { // 选中商品才累加数量 sum += obj.goods_count; } return sum; }, 0) }, allPrice(state) { return state.goodsList.reduce((sum, obj) =\u0026gt; { if (obj.goods_state) { sum += obj.goods_count * obj.goods_price } return sum; }, 0) } } }) 小结 getters有什么用?\nvuex里的计算属性, 属于全局计算属性, 类似computed\n13.vuex-getters使用 目标 组件内使用getters 使用getters的2种方式 方式1: 组件内 - 直接使用\n语法:\nthis.$store.getters.计算属性名 方式2: 组件内 - 映射使用\n语法:\n// 1. 拿到mapGetters辅助函数 import { mapGetters } from \u0026#39;vuex\u0026#39; export default { computed: { // 2. 把getters里属性映射到原地 ...mapGetters([\u0026#39;getters里的计算属性名\u0026#39;]) } } MyFooter.vue里使用 使用2种方式给计算属性值 \u0026lt;script\u0026gt; import { mapGetters } from \u0026#39;vuex\u0026#39; export default { computed: { allCount(){ return this.$store.getters.allCount; }, ...mapGetters([\u0026#39;allPrice\u0026#39;]) } } \u0026lt;/script\u0026gt; 小结 getters如何使用?\n方式1: this.$store.getters.计算属性名\n方式2: \u0026hellip;mapGetters([\u0026lsquo;getters里计算属性名\u0026rsquo;])\n14.vuex-modules定义-分模块 目标 为何要分模块 modules定义 为何分模块 代码上的对比 创建modules模块对象 新建store/modules/user.js 新建store/modules/cart.js 语法: 对象里包含5个核心概念, 只有state变成函数形式\nuser.js - 用户模块对象\n// 用户模块对象 const userModule = { state(){ return { name: \u0026#34;\u0026#34;, age: 0, sex: \u0026#39;\u0026#39; } }, mutations: {}, actions: {}, getters: {} } export default userModule cart.js - 购物车模块对象\n// 购物车模块对象 import axios from \u0026#39;axios\u0026#39; const cartModule = { state() { return { goodsList: [] } }, mutations: { setGoodsList(state, newList) { state.goodsList = newList } }, actions: { async asyncGetGoodsList(store) { const url = `https://www.escook.cn/api/cart` // 发送异步请求 const res = await axios({ url: url }); store.commit(\u0026#39;setGoodsList\u0026#39;, res.data.list) // 提交mutation修改state中的数据 } }, getters: { allCount(state) { return state.goodsList.reduce((sum, obj) =\u0026gt; { if (obj.goods_state === true) { // 选中商品才累加数量 sum += obj.goods_count; } return sum; }, 0) }, allPrice(state) { return state.goodsList.reduce((sum, obj) =\u0026gt; { if (obj.goods_state) { sum += obj.goods_count * obj.goods_price } return sum; }, 0) } } } export default cartModule 定义modules 语法:\nmodules: { 模块名: 模块对象 } 把2个模块对象, 引回到store里注册 import Vue from \u0026#39;vue\u0026#39; import Vuex from \u0026#39;vuex\u0026#39; import cartModule from \u0026#39;./modules/cart\u0026#39; import userModule from \u0026#39;./modules/user\u0026#39; Vue.use(Vuex) const store = new Vuex.Store({ modules: { user: userModule, cart: cartModule } }) export default store 小结 为什么分模块?\n集中式管理项目过大, 变量过多, 会导致state臃肿, 难以维护\n如何分模块?\n定义模块对象, state变成函数返回对象形式, 每个模块都有state/mutations/actions/getters/modules\n根store如何注册?\nmodules里 { 模块名: 模块对象 }\n15.分模块-影响state取值方式 目的 只要分模块, state取值方式改变, 其他暂时不变 state使用方式修改 方式1: 组件内 - 直接使用\n原语法:\nthis.$store.state.变量名 分模块后语法:\nthis.$store.state.模块名.变量名 方式2: 组件内 - 映射使用\n原语法:\n...mapState([\u0026#39;state里变量名\u0026#39;]) ...mapState({\u0026#39;变量名\u0026#39;: \u0026#34;state里变量名\u0026#34;}) // 给映射过来的state起别的名字 分模块后语法:\n...mapState({ \u0026#39;变量名\u0026#39;: state =\u0026gt; state.模块名.变量名 }) App.vue-修改 computed: { // ...mapState({list: \u0026#39;goodsList\u0026#39;}) // 本地属性名list, 映射vuex里的goodsList变量值 // 方式1: 直接用 // list(){ // 这个list就是组件内普通的计算属性名 // return this.$store.state.cart.goodsList // }. // 方式2: 映射方式改变 ...mapState({\u0026#39;list\u0026#39;: state =\u0026gt; state.cart.goodsList}) }, 小结 分模块对什么有影响?\n对state的取值方式有影响, 对其他暂无影响\nstate如何取值?\n在组件使用的时候, 要state.模块名.变量名\n16.分模块-命名空间 目标 防止多个模块之间, mutations/actions/getters的名字冲突 开启命名空间 在模块对象内设置namespaced: true\nconst moduleShopCar = { namespaced: true, state () {}, mutations: {}, actions: {}, getters: {}, modules: {} } state使用方式修改 直接使用无变化: this.$store.state.模块名.变量名\n辅助函数需要遵守格式\n...mapState(\u0026#34;模块名\u0026#34;, [\u0026#39;state变量名\u0026#39;]) mutations使用方式修改 方式1: 组件内 - 直接使用\n原语法:\nthis.$store.commit(\u0026#34;mutations里的函数名\u0026#34;, 具体值) 开命名空间后语法:\nthis.$store.commit(\u0026#34;模块名/mutations里的函数名\u0026#34;, 具体值) 方式2: 组件内 - 映射使用\n原语法:\n...mapMutations([\u0026#39;mutations里方法名\u0026#39;]) 开命名空间后语法:\n...mapMutations(\u0026#34;模块名\u0026#34;, [\u0026#39;mutations里方法名\u0026#39;]) actions使用方式修改 方式1: 组件内 - 直接使用\n原语法:\nthis.$store.dispatch(\u0026#34;actions里的函数名\u0026#34;, 具体值) 开命名空间后语法:\nthis.$store.dispatch(\u0026#34;模块名/actions里的函数名\u0026#34;, 具体值) 方式2: 组件内 - 映射使用\n原语法:\n...mapActions([\u0026#39;actions里方法名\u0026#39;]) 开命名空间后语法:\n...mapActions(\u0026#34;模块名\u0026#34;, [\u0026#39;actions里方法名\u0026#39;]) getters使用方式修改 方式1: 组件内 - 直接使用\n原语法:\nthis.$store.getters.计算属性名 开命名空间后语法:\nthis.$store.getters[\u0026#39;模块名/计算属性名\u0026#39;] 方式2: 组件内 - 映射使用\n原语法:\n...mapGetters([\u0026#39;getters里计算属性名\u0026#39;]) 开命名空间后语法:\n...mapGetters(\u0026#34;模块名\u0026#34;, [\u0026#39;getters里计算属性名\u0026#39;]) 小结 state和mutations, 在根store和开启命名空间里的区别? 整个vuex的体系是? 扩展: 使用Devtools调试vuex数据 优秀的调试工具可以使我们写程序事半功倍，最后我们再学习一下如果使用dev-tools来调试vuex中的数据，这也是数据可预测特性里不可缺少的一环\n目标 掌握dev-tools调试vuex 理解什么是数据状态是可追踪的 Vue3-Vuex Vuex介绍 Vuex是什么 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理数据，以相应的规则保证状态以一种可预测的方式发生变化 优点：\n能够在Vuex中集中管理共享的数居，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步 vuex为何学 程序页面多, 数据变量多\n不同组件数据保持同步 数据的修改都是可追踪 一个户外商店有两名员工，张三和李四\n一天的早上，他们分别对帐篷的数量做了一次盘点，发现一共有三个帐篷\n张三卖出去俩个，他以为库存里还有一个\n李四卖出去一个，他以为库存里还有两个\n而事实上是，库存现在已经为零\n如果他们再接受客户的预订，就会出现库存不足的情况\n张三和李四因为没有保持库存的数量的同步导致了尴尬，这个就是所谓的数据保持同步\n店长需要知道, 谁卖出了多少个帐篷，这个行为我们称之为数据修改是可追踪的\nvuex中存什么 多个组件共享状态，才存储在vuex中\n某个组件中的私有数据，依旧存储在data中\n例如：\n登陆的用户名需要在首页, 个人中心, 结算页面使用, 用户名存在vuex中 文章详情数据, 只有在文章详情页查看, 在自身data中声明 基本使用 安装 vuex 依赖包 npm install vuex --save 导入 import Vuex from \u0026#39;vuex\u0026#39; app.use(Vuex) 创建 store 对象 const store = new Vuex.Store({ // state 中存放的就是全局共享的数据 state: { count: 0 } }) 将 store 对象挂载到 vue 实例中 new Vue({ el: \u0026#39;#app\u0026#39;, render: h =\u0026gt; h(App), router // 将创建的共享数据对象挂载到 Vue 实例中 // 所有的组件, 就可以直接从 store 中获取全局的数据 }).$mount(\u0026#39;#app\u0026#39;) // Vue3 import { createApp } from \u0026#39;vue\u0026#39; import { createStore } from \u0026#39;vuex\u0026#39; // 创建一个新的 store 实例 const store = createStore({ state () { return { count: 0 } }, mutations: { increment (state) { state.count++ } } }) const app = createApp({ /* 根组件 */ }) // 将 store 实例作为插件安装 app.use(store) state state是唯一的公共数据源，统一存储\n// store/index.js import { createStore } from \u0026#39;vuex\u0026#39; // 配置 Vuex const store = createStore({ state() { return { text: \u0026#39;我的博客 www.misterma.com\u0026#39;, num: 12 } }, mutations: { changeText(state) { state.text = \u0026#39;github https://github.com/changbin1997\u0026#39;; }, changeNum(state) { state.num ++; } } }); export default store 使用 方式1: 组件内 - 直接使用 this.$store.state.变量名 import {useStore} from \u0026#39;vuex\u0026#39;; const store = useStore(); console.log(store.state.变量名); 方式2: 组件内 - 映射使用 (推荐) import {computed} from \u0026#39;vue\u0026#39;; const text = computed(() =\u0026gt; store.state.text); const num = computed(() =\u0026gt; store.state.num); state是响应式的, 只要state值变化, 页面上使用的地方会自动更新同步\nmutations Vuex Mutations 则是用于修改状态的函数。在 Vuex 中，状态是通过 store 对象进行管理的，而 Mutations 则是通过提交（commit）来执行的。每个 Mutation 都是一个纯函数，它接收 state 对象作为第一个参数，并且可以接收额外的参数作为载荷（payload）。Mutation 函数用于同步地改变状态，它们在开发过程中可以帮助我们跟踪状态的变化。\n在 Vue 3 中，Mutations 并不是唯一能修改 state 的地方。实际上，在 Vue 3 中，可以通过使用 Mutations、Actions 或直接操作 state 来修改状态。这是与 Vue 2 中的 Vuex 不同的地方。\n在 Vue 3 中，可以使用 Mutations 来同步地改变状态，Actions 用于处理异步操作并提交 Mutations，而直接操作 state 则是为了简单的状态变化。这种方式使得状态管理更加灵活，并且能够更好地处理异步操作。\n因此，在 Vue 3 中，Mutations 并不是唯一能修改 state 的地方，而是状态管理中的一部分，开发者可以根据具体情况选择合适的方式来修改状态。\n以下是一个 mutations 与 store 结合的例子\n\u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--输出 store 配置的 text 和 num--\u0026gt; \u0026lt;p\u0026gt;{{ store.state.text }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ store.state.num }}\u0026lt;/p\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; @click=\u0026#34;buttonClick\u0026#34;\u0026gt;更改 text 和 num\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {useStore} from \u0026#39;vuex\u0026#39;; const store = useStore(); function buttonClick() { // 更改 text 和 num store.commit(\u0026#39;changeText\u0026#39;); store.commit(\u0026#39;changeNum\u0026#39;); } \u0026lt;/script\u0026gt; // store/index.js import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; const routes = [ { path: \u0026#39;/login\u0026#39;, name: \u0026#39;login\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/components/login.vue\u0026#39;) }, { path: \u0026#39;/main\u0026#39;, name: \u0026#39;main\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/components/main.vue\u0026#39;) } ] const router = createRouter({ history: createWebHistory(), routes }) export default router actions 在 Vue 3 中，使用 Vuex 的 Actions 是一种处理异步操作并提交 Mutations 的方式。Actions 允许您在应用程序中执行异步操作，例如从服务器获取数据，然后再提交 Mutations 来修改状态。以下是在 Vue 3 中使用 Vuex Actions 的基本方法：\nconst store = new Vuex.Store({ // ...省略state和mutations此处 actions: { asyncAddCount(store, num){ setTimeout(() =\u0026gt; { // 1秒后, 异步提交给add的mutations store.commit(\u0026#39;addCount\u0026#39;, num) }, 1000) }, asyncSubCount(store, num) { setTimeout(() =\u0026gt; { // 1秒后, 异步提交给sub的mutations store.commit(\u0026#39;subCount\u0026#39;, num) }, 1000) } } }) getters Vuex Getters 是用于从 store 中获取状态的函数。Getters 允许您在 store 中计算状态或过滤数据，并且可以在组件中像计算属性一样使用。以下是在 Vue 3 中定义和使用 Vuex Getters 的基本方法：\nconst store = new Vuex.Store({ // ...省略其他 getters: { allCount(state) { return state.goodsList.reduce((sum, obj) =\u0026gt; { if (obj.goods_state === true) { // 选中商品才累加数量 sum += obj.goods_count; } return sum; }, 0) }, allPrice(state) { return state.goodsList.reduce((sum, obj) =\u0026gt; { if (obj.goods_state) { sum += obj.goods_count * obj.goods_price } return sum; }, 0) } } }) 用getters的2种方式 方式1: 组件内 - 直接使用\n语法:\nthis.$store.getters.计算属性名 方式2: 组件内 - 映射使用\n语法:\n// 1. 拿到mapGetters辅助函数 import { mapGetters } from \u0026#39;vuex\u0026#39; export default { computed: { // 2. 把getters里属性映射到原地 ...mapGetters([\u0026#39;getters里的计算属性名\u0026#39;]) } } MyFooter.vue里使用 使用2种方式给计算属性值 \u0026lt;script\u0026gt; import { mapGetters } from \u0026#39;vuex\u0026#39; export default { computed: { allCount(){ return this.$store.getters.allCount; }, ...mapGetters([\u0026#39;allPrice\u0026#39;]) } } \u0026lt;/script\u0026gt; ","permalink":"https://waite.wang/posts/vue/system-learn-vuex-1/","summary":"\u003ch2 id=\"vue2-vuex\"\u003eVue2-VueX\u003c/h2\u003e\n\u003ch3 id=\"1vuex介绍\"\u003e1.vuex介绍\u003c/h3\u003e\n\u003ch4 id=\"目标\"\u003e目标\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e什么是vuex\u003c/li\u003e\n\u003cli\u003e为什么学习vuex\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"通信方案\"\u003e通信方案\u003c/h4\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202312242346950.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202312242346950.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e组件关系\u003c/th\u003e\n          \u003cth\u003e数据通信\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e父子关系\u003c/td\u003e\n          \u003ctd\u003e父传子：props ； 子传父：$emit\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e非父子关系\u003c/td\u003e\n          \u003ctd\u003evuex (一种组件通信方案)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"vuex是什么\"\u003evuex是什么\u003c/h4\u003e\n\u003cp\u003eVuex 是一个专为 Vue.js 应用程序开发的\u003cstrong\u003e状态管理模式\u003c/strong\u003e。它采用\u003cstrong\u003e集中式\u003c/strong\u003e存储管理数据，以相应的规则保证状态以一种可预测的方式发生变化\u003c/p\u003e","title":"系统学习 VueX 1"},{"content":" 本文章来源于王红元老师（coderwhy）的 Vue3 + Ts 课程第二章节 - Vue3 基本指令附上链接：https//ke.qq.com/course/3453141 permalink: /archives/vue3-ji-ben-zhi-ling-er\nVue3 基本指令 VSCode 代码片段 我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方 便我们快速生成。 VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。 具体的步骤如下： 第一步，复制自己需要生成代码片段的代码； 第二步，https://snippet-generator.app/在该网站中生成代码片段； 第三步，在VSCode中配置代码片段； 直接 Tab trigger 即可自动填充 模板语法 React的开发模式[了解] React使用的jsx,所以对应的代码都是编写的类似于js的一种语法 之后通过Babe将js编译成 React. create Element函数调用 function () { return \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } vue也支持 jsx 的开发模式: 但是大多数情况下,使用基于HTML的模板语法 在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数 \u0026lt;template\u0026gt; \u0026lt;div @click v-bind v-once\u0026gt; {{}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Mustache 语法 双大括号语法 如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。 并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中； 当data中的数据发生改变时，对应的内容也会发生更新。 当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。 mustache的使用 1. 基本使用 2. 表达式 3. 函数 4. 三元运算符 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.mustache的基本使用 --\u0026gt; \u0026lt;h2\u0026gt;{{message}} - {{message}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 2.是一个表达式 --\u0026gt; \u0026lt;h2\u0026gt;{{counter * 10}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ message.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;) }}\u0026lt;/h2\u0026gt; \u0026lt;!-- 3.也可以调用函数 --\u0026gt; \u0026lt;!-- 可以使用computed(计算属性) --\u0026gt; \u0026lt;h2\u0026gt;{{getReverseMessage()}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 4.三元运算符 --\u0026gt; \u0026lt;h2\u0026gt;{{ isShow ? \u0026#34;哈哈哈\u0026#34;: \u0026#34;\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, counter: 100, isShow: true } }, methods: { getReverseMessage() { return this.message.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;); }, toggle() { this.isShow = !this.isShow; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 以下为错误写法\n\u0026lt;!-- 错误用法 --\u0026gt; var name = \u0026#34;abc\u0026#34; ; \u0026lt;h2\u0026gt;{{var name = \u0026#34;abc\u0026#34;}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ if(isShow) { return \u0026#34;哈哈哈\u0026#34; } }}\u0026lt;/h2\u0026gt; 不常用指令 v-once指令 v-once用于指定元素或者组件只渲染一次\n当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;\n该指令可以用于性能优化;\n\u0026lt;h2 v-once\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; 如果是子节点的化，也只能渲染一次\n\u0026lt;div v-once\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; 完整代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;div v-once\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { counter: 100, message: \u0026#34;abc\u0026#34; } }, methods: { increment() { this.counter++; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; v-html 默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。 如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{{msg}}\u0026lt;/div\u0026gt; \u0026lt;div v-html=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { msg: \u0026#39;\u0026lt;span style=\u0026#34;color:red; background: blue;\u0026#34;\u0026gt;哈哈哈\u0026lt;/span\u0026gt;\u0026#39; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; v-text 用于更新元素的 textContent \u0026lt;h2 v-text=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;!-- 等价于 --\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; v-pre v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签： 跳过不需要编译的节点，加快编译的速度 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2 v-pre\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- {{message}} --\u0026gt; v-cloak 用于隐藏尚未完成编译的 DOM 模板。 无需传入 详细信息 该指令只在没有构建步骤的环境下需要使用。 当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。 v-cloak 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 [v-cloak] { display: none } 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。 [v-cloak] { display: none; } \u0026lt;div v-cloak\u0026gt; {{ message }} \u0026lt;/div\u0026gt; 直到编译完成前，\u0026lt;div\u0026gt; 将不可见。\nv-bind 动态的绑定一个或多个 attribute，也可以是组件的 prop。\n缩写：: 或者 . (当使用 .prop 修饰符)\n期望：any (带参数) | Object (不带参数)\n参数：attrOrProp (可选的)\n修饰符\n.camel - 将短横线命名的 attribute 转变为驼峰式命名。 .prop - 强制绑定为 DOM property。3.2+ .attr - 强制绑定为 DOM attribute。3.2+ 用途\n当用于绑定 class 或 style attribute，v-bind 支持额外的值类型如数组或对象。详见下方的指南链接。\n在处理绑定时，Vue 默认会利用 in 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 .prop 和 .attr 修饰符来强制绑定方式。有时这是必要的，特别是在和自定义元素打交道时。\n当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。\n当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。\n用法\n动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。 小知识: vue3 是允许template中有多个根元素\n\u0026lt;!-- vue2 template模板中只能有一个根元素 --\u0026gt; \u0026lt;!-- vue3 是允许template中有多个根元素 --\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.v-bind的基本使用 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a v-bind:href=\u0026#34;link\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; \u0026lt;!-- 2.v-bind提供一个语法糖 : --\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; 基本使用 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.v-bind的基本使用 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a v-bind:href=\u0026#34;link\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; \u0026lt;!-- 2.v-bind提供一个语法糖 : --\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- 以下报错 --\u0026gt; \u0026lt;img src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { imgUrl: \u0026#34;https://avatars.githubusercontent.com/u/10335230?s=60\u0026amp;v=4\u0026#34;, link: \u0026#34;https://www.baidu.com\u0026#34; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 绑定 class 在开发中,有时候我们的元素 class也是动态的,比如 当数据为某个状态时,字体显示红色。 当数据另一个状态时,字体显示黑色 绑定class有两种方式： 对象语法 数组语法 对象语法 对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;className\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- 对象语法: {\u0026#39;active\u0026#39;: boolean} --\u0026gt; \u0026lt;div :class=\u0026#34;{\u0026#39;active\u0026#39;: isActive}\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;!-- 也可以有多个键值对 --\u0026gt; \u0026lt;div :class=\u0026#34;{active: isActive, title: true}\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;!-- 默认的class和动态的class结合 --\u0026gt; \u0026lt;div class=\u0026#34;abc cba\u0026#34; :class=\u0026#34;{active: isActive, title: true}\u0026#34;\u0026gt; 呵呵呵呵 \u0026lt;/div\u0026gt; \u0026lt;!-- 将对象放到一个单独的属性中 --\u0026gt; \u0026lt;div class=\u0026#34;abc cba\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;!-- 将返回的对象放到一个methods(computed)方法中 --\u0026gt; \u0026lt;div class=\u0026#34;abc cba\u0026#34; :class=\u0026#34;getClassObj()\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#34;#my-app\u0026#34;, data() { return { className: \u0026#34;why\u0026#34;, isActive: true, title: \u0026#34;abc\u0026#34;, classObj: { active: true, title: true }, }; }, methods: { toggle() { this.isActive = !this.isActive; this.classObj.active = !this.classObj.active; }, getClassObj() { return this.classObj; } }, }; Vue.createApp(App).mount(\u0026#34;#app\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .active { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/body\u0026gt; 数组语法 绑定class – 数组语法 数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;abc\u0026#39;, title]\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- class=\u0026#34;abc cba active\u0026#34; --\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;abc\u0026#39;, title, isActive ? \u0026#39;active\u0026#39;: \u0026#39;\u0026#39;]\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- 可以嵌套对象语法 --\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;abc\u0026#39;, title, {active: isActive}]\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, title: \u0026#34;cba\u0026#34;, isActive: true } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 绑定 style 我们可以利用 v-bind:style 来绑定一些CSS内联样式 这次因为某些样式我们需要根据数据动态来决定 比如某段文字的颜色，大小等等 CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名 绑定class有两种方式 对象语法 数组语法 CSS property 名短横线分隔 (kebab-case，记得用引号括起来)\n对象语法 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- :style=\u0026#34;{cssPropertyName: cssPropertyValue}\u0026#34; --\u0026gt; \u0026lt;div :style=\u0026#34;{color: finalColor, \u0026#39;font-size\u0026#39;: \u0026#39;30px\u0026#39;}\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div :style=\u0026#34;{color: finalColor, fontSize: \u0026#39;30px\u0026#39;}\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div :style=\u0026#34;{color: finalColor, fontSize: finalFontSize + \u0026#39;px\u0026#39;}\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- 绑定一个data中的属性值, 并且是一个对象 --\u0026gt; \u0026lt;div :style=\u0026#34;finalStyleObj\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;!-- 调用一个方法 --\u0026gt; \u0026lt;div :style=\u0026#34;getFinalStyleObj()\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, finalColor: \u0026#39;red\u0026#39;, finalFontSize: 50, finalStyleObj: { \u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;, fontWeight: 700, backgroundColor: \u0026#39;red\u0026#39; } } }, methods: { getFinalStyleObj() { return { \u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;, fontWeight: 700, backgroundColor: \u0026#39;red\u0026#39; } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 数组语法 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div :style=\u0026#34;[style1Obj, style2Obj]\u0026#34;\u0026gt;哈哈哈\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, style1Obj: { color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;30px\u0026#39; }, style2Obj: { textDecoration: \u0026#34;underline\u0026#34; } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body 动态绑定属性 在某些情况下，我们属性的名称可能也不是固定的 前端我们无论绑定src、href、class、style，属性名称都是固定的 如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义 这种绑定的方式，我们称之为 动态绑定属性；如下: \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div cba=\u0026#34;kobe\u0026#34;\u0026gt;哈哈哈\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div :[name]=\u0026#34;value\u0026#34;\u0026gt;哈哈哈\u0026lt;/div\u0026gt; \u0026lt;img :src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a :href=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;div :class\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { name: \u0026#34;cba\u0026#34;, value: \u0026#34;kobe\u0026#34; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 属性直接绑定一个对象 如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？ 非常简单，我们可以直接使用 v-bind 绑定一个 对象 案例：info对象会被拆解成div的各个属性 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div name=\u0026#34;why\u0026#34; age=\u0026#34;18\u0026#34; height=\u0026#34;1.88\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div v-bind=\u0026#34;info\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div :=\u0026#34;info\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { info: { name: \u0026#34;why\u0026#34;, age: 18, height: 1.88 } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-on v-on绑定事件\n前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。 在前端开发中，我们需要经常和用户进行各种各样的交互 这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等 在Vue中如何监听事件呢？使用v-on指令。 v-on的用法\n缩写：@ 预期：Function | Inline Statement | Object 参数：event p 修饰符： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyAlias} - 仅当事件是从特定键触发时才触发回调。 .once - 只触发一次回调。 .left - 只当点击鼠标左键时触发。 .right - 只当点击鼠标右键时触发。 .middle - 只当点击鼠标中键时触发。 .passive - { passive: true } 模式添加侦听器 用法：绑定事件监听 event 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events\n基本使用 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 完整写法: v-on:监听的事件=\u0026#34;methods中方法\u0026#34; --\u0026gt; \u0026lt;button v-on:click=\u0026#34;btn1Click\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;area\u0026#34; v-on:mousemove=\u0026#34;mouseMove\u0026#34;\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;!-- 语法糖 --\u0026gt; \u0026lt;button @click=\u0026#34;btn1Click\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;!-- 绑定一个表达式: inline statement --\u0026gt; \u0026lt;button @click=\u0026#34;counter++\u0026#34;\u0026gt;{{counter}}\u0026lt;/button\u0026gt; \u0026lt;!-- 绑定一个对象 --\u0026gt; \u0026lt;div class=\u0026#34;area\u0026#34; v-on=\u0026#34;{click: btn1Click, mousemove: mouseMove}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;area\u0026#34; @=\u0026#34;{click: btn1Click, mousemove: mouseMove}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, counter: 100 } }, methods: { btn1Click() { console.log(\u0026#34;按钮1发生了点击\u0026#34;); }, mouseMove() { console.log(\u0026#34;鼠标移动\u0026#34;); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 参数传递 当通过methods中定义方法，以供 @click调用时，需要注意参数问题： 情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。 但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 情况二：如果需要同时传入某个参数，同时需要 event 时，可以通过 $event 传入事件。 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 默认传入event对象, 可以在方法中获取 --\u0026gt; \u0026lt;button @click=\u0026#34;btn1Click\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;!-- $event可以获取到事件发生时的事件对象 --\u0026gt; \u0026lt;button @click=\u0026#34;btn2Click($event, \u0026#39;coderwhy\u0026#39;, 18)\u0026#34;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34; } }, methods: { btn1Click(event) { console.log(event); }, btn2Click(event, name, age) { console.log(name, age, event); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-on 的修饰符 v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyAlias} - 仅当事件是从特定键触发时才触发回调。 .once - 只触发一次回调。 .left - 只当点击鼠标左键时触发。 .right - 只当点击鼠标右键时触发。 .middle - 只当点击鼠标中键时触发。 .passive - { passive: true } 模式添加侦听器 stopPropagation 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 stopPropagation 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 @click.stop 来阻止 click 事件冒泡到父元素。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div @click=\u0026#34;divClick\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;button @click.stop=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;enterKeyup\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34; } }, methods: { divClick() { console.log(\u0026#34;divClick\u0026#34;); }, btnClick() { console.log(\u0026#39;btnClick\u0026#39;); }, enterKeyup(event) { console.log(\u0026#34;keyup\u0026#34;, event.target.value); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 条件渲染 在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。 Vue提供了下面的指令来进行条件判断： v-if v-else v-else-if v-show 基本使用 v-if、v-else、v-else-if用于根据条件来渲染某一块的内容： 这些内容只有在条件为true时，才会被渲染出来； 这三个指令与JavaScript的条件语句if、else、else if类似； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;score\u0026#34;\u0026gt; \u0026lt;h2 v-if=\u0026#34;score \u0026gt; 90\u0026#34;\u0026gt;优秀\u0026lt;/h2\u0026gt; \u0026lt;h2 v-else-if=\u0026#34;score \u0026gt; 60\u0026#34;\u0026gt;良好\u0026lt;/h2\u0026gt; \u0026lt;h2 v-else\u0026gt;不及格\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { score: 95 } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; template 和 v-if 结合使用 v-if的渲染原理： v-if是惰性的； 当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉； 当条件为true时，才会真正渲染条件块中的内容; template元素 因为v-if是一个指令，所以必须将其添加到一个元素上： 但是如果我们希望切换的是多个元素呢？ 此时我们渲染div，但是我们并不希望div这种元素被渲染； 这个时候，我们可以选择使用template； template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来： 有点类似于小程序中的block \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;template v-if=\u0026#34;isShowHa\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;h2\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;button @click=\u0026#34;isShowHa = !isShowHa\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { isShowHa: true } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-show v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2 v-show=\u0026#34;isShow\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; v-show和v-if的区别 首先，在用法上的区别： v-show是不支持template； v-show不可以和v-else一起使用； 其次，本质的区别： v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换； v-if当条件为false时，其对应的元素压根不会被渲染到DOM中； 开发中如何进行选择呢？ 如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show； 如果不会频繁的发生切换，那么使用v-if； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2 v-if=\u0026#34;isShow\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2 v-show=\u0026#34;isShow\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; 列表渲染 在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。 这个时候我们可以使用v-for来完成； v-for类似于JavaScript的for循环，可以用于遍历一组数据； 基本使用 n v-for的基本格式是 \u0026ldquo;item in 数组\u0026rdquo;：\n数组通常是来自data或者prop，也可以是其他方式； item是我们给每项元素起的一个别名，这个别名可以自定来定义； 我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：\n如果我们需要索引，可以使用格式： \u0026ldquo;(item, index) in 数组\u0026rdquo;； 注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的； v-for支持的类型\nv-for也支持遍历对象，并且支持有一二三个参数： 一个参数： \u0026ldquo;value in object\u0026rdquo;; 二个参数： \u0026ldquo;(value, key) in object\u0026rdquo;; 三个参数： \u0026ldquo;(value, key, index) in object\u0026rdquo;; v-for同时也支持数字的遍历： 每一个item都是一个数字； \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;电影列表\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 遍历数组 --\u0026gt; \u0026lt;li v-for=\u0026#34;(movie, index) in movies\u0026#34;\u0026gt;{{index+1}}.{{movie}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;个人信息\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 遍历对象 --\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key, index) in info\u0026#34;\u0026gt;{{value}}-{{key}}-{{index}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;遍历数字\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(num, index) in 10\u0026#34;\u0026gt;{{num}}-{{index}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { movies: [ \u0026#34;星际穿越\u0026#34;, \u0026#34;盗梦空间\u0026#34;, \u0026#34;大话西游\u0026#34;, \u0026#34;教父\u0026#34;, \u0026#34;少年派\u0026#34; ], info: { name: \u0026#34;why\u0026#34;, age: 18, height: 1.88 } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; template元素使用 类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容： 我们使用template来对多个元素进行包裹，而不是使用div来完成； \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;template v-for=\u0026#34;(value, key) in info\u0026#34;\u0026gt; \u0026lt;li\u0026gt;{{key}}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{value}}\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;divider\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { info: { name: \u0026#34;why\u0026#34;, age: 18, height: 1.88 } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 数组更新检测 Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push() pop() shift() unshift() splice() sort() reverse() 替换数组的方法 上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;电影列表\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(movie, index) in movies\u0026#34;\u0026gt;{{index+1}}.{{movie}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;newMovie\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;addMovie\u0026#34;\u0026gt;添加电影\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { newMovie: \u0026#34;\u0026#34;, movies: [ \u0026#34;星际穿越\u0026#34;, \u0026#34;盗梦空间\u0026#34;, \u0026#34;大话西游\u0026#34;, \u0026#34;教父\u0026#34;, \u0026#34;少年派\u0026#34; ] } }, methods: { addMovie() { this.movies.push(this.newMovie); this.newMovie = \u0026#34;\u0026#34;; // filter 是过滤的意思, 下文中的代码的意思是: 过滤掉长度小于等于2的电影 // this.movies = this.movies.filter(item =\u0026gt; item.length \u0026gt; 2); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-for 中的 key 是什么作用？ https://cn.vuejs.org/api/built-in-special-attributes.html#key\n在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。\n这个key属性有什么作用呢？我们先来看一下官方的解释：\nkey属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；\n如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；\n而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；\n官方的解释对于初学者来说并不好理解，比如下面的问题：\n什么是新旧nodes，什么是VNode？ 没有key的时候，如何尝试修改和复用的？ 有key的时候，如何基于key重新排列的？ 认识 VNode 我们先来解释一下VNode的概念： 因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode； VNode的全称是Virtual Node，也就是虚拟节点； 事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode； VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子 好处: 多平台的渲染, 跨平台(主要好处) 虚拟 DOM 如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree 虚拟 DOM 与 真实 DOM 不一定一一对应 插入 F 的案例 我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；\n我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：\n在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；\n因为对于列表中 a、b、c、d它们都是没有变化的；\n在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in letters\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button @click=\u0026#34;insertF\u0026#34;\u0026gt;插入F元素\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { letters: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] } }, methods: { insertF() { this.letters.splice(2, 0, \u0026#39;f\u0026#39;) } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 那么Vue中对于列表的更新究竟是如何操作的呢？ Vue事实上会对于有key和没有key会调用两个不同的方法； Vue源码对于key的判断 有key，那么就使用 patchKeyedChildren方法； 没有key，那么久使用 patchUnkeyedChildren方法； diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。\n没有key的操作过程 我们会发现上面的diff算法效率并不高： c和d来说它们事实上并不需要有任何的改动； 但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增； 有key的操作过程-diff算法 第一步的操作是从头开始进行遍历、比较： a和b是一致的会继续进行比较； c和f因为key不一致，所以就会break跳出循环 第二步的操作是从尾部开始进行遍历、比较 第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点： 第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点： 第五步是最特色的情况，中间还有很多未知的或者乱序的节点： 有无key的结论 有无key的结论 所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作： 在没有key的时候我们的效率是非常低效的； 在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效； ","permalink":"https://waite.wang/posts/vue/vue3-learn-2/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文章来源于王红元老师（coderwhy）的 Vue3 + Ts 课程第二章节 - Vue3 基本指令附上链接：https//ke.qq.com/course/3453141\npermalink: /archives/vue3-ji-ben-zhi-ling-er\u003c/p\u003e","title":"Vue3 基本指令(二)"},{"content":" 本文章来源于王红元老师（coderwhy）的 Vue3 + Ts 课程第二章节 - Vue3 基本指令附上链接：https//ke.qq.com/course/3453141 permalink: /archives/vue3-ji-ben-zhi-ling-er\n邂逅Vue3开发 认识 Vue 什么是 Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 全程是Vue.js或者Vuejs； 什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目； Vue3带来的变化 源码通过monorepo的形式来管理源代码： Mono：单个 Repo：repository仓库 主要是将许多项目的代码存储在同一个 repository 中； 这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理； 而且模块划分的更加清晰，可维护性、可扩展性更强； 源码使用TypeScript来进行重写： 在Vue2.x的时候，Vue使用 Flow 来进行类型检测； 在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了； 性能方面 使用Proxy进行数据劫持 在 Vue2.x 的时候，Vue2 是使用 Object.defineProperty 来劫持数据的 getter 和 setter 方法的； 这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的； 所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 $set 或 $delete ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本； 而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持 删除了一些不必要的API： 移除了实例上的 $on , $off 和 $once； 移除了一些特性：如filter、内联模板等； 包括编译方面的优化： 生成Block Tree、Slot编译优化、diff算法优化； 新的API 由Options API 到 Composition API： 在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象； Options API 包括data、props、methods、computed、生命周期等等这些选项； 存在比较大的问题是多个逻辑可能是在不同的地方： 比如created中会使用某一个method来修改data的数据，代码的内聚性非常差； Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找； Hooks函数增加代码的复用性： 在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题； 在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的； 如何使用 Vue 方式一：在页面中通过CDN的方式来引入； 方式二：下载Vue的JavaScript文件，并且自己手动引入； 方式三：通过npm包管理工具安装使用它； 方式四：直接通过Vue CLI创建项目，并且使用它； CDN 引入 \u0026lt;script src=\u0026#34;https://unpkg.com/vue@next\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 下载和引入 下载Vue的源码，可以直接打开CDN的链接： 打开链接，复制其中所有的代码； 创建一个新的文件，比如vue.js，将代码复制到其中； \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 声明式编程和命令式编程 原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程 命令式编程关注的是“ how to do”,声明式编程关注的是\u0026quot; what to do\u0026quot;,由框架(机器)完成\u0026quot;how\u0026quot;的过程 MVVM模型 MVC和MVVM都是一种软件的体系结构 MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端 MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式 通常情况下,我们也经常称vue是一个MVVM的框架 vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的 template属性 在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。 template属性:表示的是Vue需要帮助我们渲染的模板信息 目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML 模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法 但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率 vue提供了两种方式: 方式一:使用 script标签,并且标记它的类型为 X-template; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;hhhh\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;x-template\u0026#34; id=\u0026#34;why\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#39;increment\u0026#39;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#39;decrement\u0026#39;\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;../js//Vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ template: \u0026#39;#why\u0026#39;, data: function(){ return{ message:\u0026#34;Hello World\u0026#34;, counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\u0026#34;#app\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;why\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#39;increment\u0026#39;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#39;decrement\u0026#39;\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js//Vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ template: \u0026#39;#why\u0026#39;, data: function(){ return{ message:\u0026#34;Hello World\u0026#34;, counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\u0026#34;#app\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; data属性 data属性是传入一个函数,并且该函数需要返回一个对象\n在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数); 在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错 data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理\n所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据 所以我们修改 counter的值时, template中的{ counter)也会发生改变; methods属性（重点） methods属性是一个对象,通常我们会在这个对象中定义很多的方法\n这些方法可以被绑定到 template模板中; 在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性; 问题：官方文档有这个描述，即不能使用箭头函数\n为什么不能使用箭头函数(VUE3.0)？\n我们在methods中要使用data返回对象中的数据：\n那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。 那么我们这个this能不能是window呢？\n不可以是window，因为window中我们无法获取到data返回对象中的数据； 但是如果我们使用箭头函数，那么这个this就会是window了； 为什么是window呢？\n这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this； 最终刚好找到的是script作用于中的this，所以就是window； this到底是如何查找和绑定的呢？\n前端面试之彻底搞懂this指向 不使用箭头函数的情况下，this到底指向什么\n事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this 具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA\n// window 隐式绑定 foo(); const obj = { bar: foo }; obj.bar(); /* Window{} {bar: f()} */ const foo2 = () =\u0026gt; { console.log(this); } const obj2 = { bar: foo2 }; obj2.bar(); /* Window{} Window{} */ 如何阅读Vue源码 需要的环境 npm，yarn 操作步骤 安装yarn npm install yarn -g 在项目中配置yarn yarn install 在package.json中的dev后加上\u0026ndash;sourcemap 打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map） 在vue/examplex新建自己的文件夹以及测试demo 在demo中打下断点—debugger 在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码 ","permalink":"https://waite.wang/posts/vue/vue3-learn-1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文章来源于王红元老师（coderwhy）的 Vue3 + Ts 课程第二章节 - Vue3 基本指令附上链接：https//ke.qq.com/course/3453141\npermalink: /archives/vue3-ji-ben-zhi-ling-er\u003c/p\u003e","title":"邂逅 Vue3 开发(一)"},{"content":" title: Windows11家庭中文版系统安装Docker id: a293d46a-9b4e-4e42-8bbc-0bcec5c21662 date: 2023-09-24 22:29:15 auther: admin cover:\n安装到 D 盘(软链接) docker 默认安装路劲为 C:\\Program Files\\Docker docker 虚拟磁盘默认安装路劲为 C:\\Users\\\u0026lt;YourName\u0026gt;\\AppData\\Local\\Docker 用 管理员身份打开cmd窗口 执行如下命令 mklink /j \u0026#34;C:\\Program Files\\Docker\u0026#34; \u0026#34;D:\\Program Files\\Docker\u0026#34; 已经安装Docker，需要重新再安装一次。 安装后C盘下的Docker文件就只是一个软链接了，映射的真实路径在D盘Docker文件夹下(注意: 软链接后需要在相应目录创建文件夹, 不然后续安装会报错) Hyper-Vr 查看自己的系统, 如果你的系统跟我一样是window11家庭中文版，则会找不到Hyper-Vr，这时则需要自己创建，讲下述代码复制在txt文本里，并重命名为Hyper.cmd，右键以管理员方式运行，最后输入“Y”重启电脑后即可。\npushd \u0026#34;%~dp0\u0026#34; dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum \u0026gt;hyper-v.txt for /f %%i in (\u0026#39;findstr /i . hyper-v.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /add-package:\u0026#34;%SystemRoot%\\servicing\\Packages\\%%i\u0026#34; del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 找到控制面板\u0026ndash;程序\u0026ndash;程序和功能\u0026ndash;启用或关闭windows功能（或者电脑直接搜索启用或关闭windows功能） ，勾选Hyper-V。（如果找不到 Hyper-V，请尝试以上步骤） 也可以输入下述命令在Windows 操作系统中启用 Microsoft Hyper-V 虚拟化技术。 dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All 然后输入下述命令，设置 Windows 操作系统中的 Hyper-V 启动类型。具体来说，它会将 Hypervisor 的启动类型设置为 \u0026ldquo;auto\u0026rdquo;，这意味着在系统启动时自动启动 Hyper-V。(非强制) bcdedit /set hypervisorlaunchtype auto 安装 Docker 官网下载docker文件Get Started | Docker，选择download for windows下载。\n双击打开下载好的文件Docker Desktop Installer.exe，add shortcut to desktop选择√代表同意添加快捷键到桌面，如果不勾选就说明不创建快捷键，大家根据自己需求选择就行。之后点击🆗\n等待一会后会出现下图所示，1说明安装成功，2说明必须重启电脑才能成功安装，3代表关闭这个界面重启电脑\n如果重启电脑后又出现下图报错： 说明系统的WSL版本太旧，需要更新，按照提示在终端中输入下述代码等待更新即可。（终端最好以右键点击以管理员身份运行打开） wsl --update 接着继续输入docker \u0026ndash;version检测docker安装的版本，出现如下图说明已经安装docker。 继续输入docker run hello-world，出现下图说明docker安装成功，且可以执行docker命令。 这里有可能报错，当你在终端输入 docker run hello-world，出现的结果反而是下面错误的结果：\nerror during connect: In the default daemon configuration on Windows, the docker client must be run with elevated privileges to connect. 这里是说权限不够，解决方法也很简单，退出 Docker 后，右键点击桌面 docker 图标，选择以管理员身份运行程序，这时候再重新打开终端输入 docker run hello-world，就会出现 正确的结果了。\n这时在打开桌面docker快捷键就不会报错了，见下图，此时还能看到hello-world的镜像。 一些报错. 参考 https://forums.docker.com/t/solved-docker-failed-to-start-docker-desktop-for-windows/106976/16\nDocker: Error response from daemon: Ports are not available 端口没被占用，却显示被占用\ndocker: Error response from daemon: Ports are not available: exposing port TCP 0.0.0.0:10911 -\u0026gt; 0.0.0.0:0: listen tcp 0.0.0.0:10911: bind: An attempt was made to access a socket in a way forbidden by its access permissions.\n看错误信息说是端口被占用了，那咱就用 netstat -aon | findstr, 结果发现Docker报错所指向的端口并没有被占用，又遇到了奇怪问题。 解决: 其实这是Windows中的一个小问题，只需要重启NAT网络就可以解决了，执行如下两条命令： net stop winnat net start winnat ","permalink":"https://waite.wang/posts/win/win11-install-docker/","summary":"\u003chr\u003e\n\u003cp\u003etitle: Windows11家庭中文版系统安装Docker\nid: a293d46a-9b4e-4e42-8bbc-0bcec5c21662\ndate: 2023-09-24 22:29:15\nauther: admin\ncover:\u003c/p\u003e\n\u003ch2 id=\"安装到-d-盘软链接\"\u003e安装到 D 盘(软链接)\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker 默认安装路劲为 C:\u003cspan class=\"se\"\u003e\\P\u003c/span\u003erogram Files\u003cspan class=\"se\"\u003e\\D\u003c/span\u003eocker\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker 虚拟磁盘默认安装路劲为 C:\u003cspan class=\"se\"\u003e\\U\u003c/span\u003esers\u003cspan class=\"se\"\u003e\\\u0026lt;\u003c/span\u003eYourName\u0026gt;\u003cspan class=\"se\"\u003e\\A\u003c/span\u003eppData\u003cspan class=\"se\"\u003e\\L\u003c/span\u003eocal\u003cspan class=\"se\"\u003e\\D\u003c/span\u003eocker\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col\u003e\n\u003cli\u003e用 \u003cstrong\u003e管理员身份打开cmd窗口\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e执行如下命令\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emklink /j \u003cspan class=\"s2\"\u003e\u0026#34;C:\\Program Files\\Docker\u0026#34;\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;D:\\Program Files\\Docker\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003col start=\"3\"\u003e\n\u003cli\u003e已经安装Docker，需要重新再安装一次。\u003c/li\u003e\n\u003cli\u003e安装后C盘下的Docker文件就只是一个软链接了，映射的真实路径在D盘Docker文件夹下(注意: 软链接后需要在相应目录创建文件夹, 不然后续安装会报错)\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"hyper-vr\"\u003eHyper-Vr\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e查看自己的系统, 如果你的系统跟我一样是window11家庭\u003ca href=\"https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%87%E7%89%88\u0026amp;spm=1001.2101.3001.7020\"\u003e中文版\u003c/a\u003e，则会找不到Hyper-Vr，这时则需要自己创建，讲下述代码复制在txt文本里，并重命名为Hyper.cmd，右键以管理员方式运行，最后输入“Y”重启电脑后即可。\u003c/p\u003e","title":"Windows11家庭中文版系统安装Docker"},{"content":"概念的理解 webstorage本地存储 webstorage是本地存储，存储在客户端，包括localStorage和sessionStorage localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信 sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 WebStorage的目标 提供一种在cookie之外存储会话数据的路径 提供一种存储大量可以跨会话存在的数据的机制 HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储） 作用域的不同： 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的 存储大小： localStorage和sessionStorage的存储数据大小一般都是：5MB 存储位置： localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信 存储内容类型： localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理 获取方式： localStorage：window.localStorage;；sessionStorage：window.sessionStorage; 应用场景： localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据，而sessionStorage：敏感账号一次性登录 WebStorage的优点： 存储空间更大：cookie为4KB，而WebStorage是5MB 节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量 对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便 快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题 WebStorage提供了一些方法，数据操作比cookie方便 setItem (key, value) —— 保存数据，以键值对的方式储存信息。 getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。 removeItem (key) —— 删除单个数据，根据键值移除对应的信息。 clear () —— 删除所有的数据 key (index) —— 获取某个索引的key cookie HTTP Cookie简称cookie,在HTTP请求发送Set-Cookie HTTP头作为响应的一部分。通过name=value的形式存储 cookie的构成： 名称：name(不区分大小写,但最好认为它是区分的) 值:value(通过URL编码:encodeURIComponent) 域 路径 失效时间:一般默认是浏览器关闭失效,可以自己设置失效时间 安全标志:设置安全标志后只有SSL连接的时候才发送到服务器 cookie的作用:主要用于保存登录信息 生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 cookie的优点：具有极高的扩展性和可用性 通过良好的编程，控制保存在cookie中的session对象的大小 通过加密和安全传输技术，减少cookie被破解的可能性 只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失 控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie cookie的缺点： cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉 安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用 sessionStorage sessionStorage是Storage类型的一个对象，拥有clear(),getItem(name),key(index),removeItem(name),setItem(name,value)方法 sessionStorage对象存储特定于某个会话的数据,也就是该数据只保持到浏览器关闭 将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据 sessionStorage为临时保存 localStorage localStorage也是Storage类型的一个对象 在HTML5中localStorage作为持久保存在客户端数据的方案取代了globalStorage(globalStorage必须指定域名) localStorage会永久存储会话数据，除非removeItem,否则会话数据一直存在 将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用 5. localStorage为永久保存 区别的比较 本地储存localStorage与cookie的区别 cookie在浏览器与服务器之间来回传递 sessionStorage和localStorage不会把数据发给服务器，仅在本地保存 数据有效期不同 cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 sessionStorage：仅在当前浏览器窗口关闭前有效 localStorage 始终有效，长期保存 cookie数据还有路径的概念，可以限制cookie只属于某个路径下 存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 作用域不用 sessionStorage不在不同的浏览器窗口中共享 localStorage在所有同源窗口中都是共享的 cookie也是在所有同源窗口中都是共享的 WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便 cookie、session和localStorage的区别 cookie的内容主要包括：名字、值、过期时间、路径和域，路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种生命期为浏览器会话期的cookie被称为会话cookie 会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。 cookie和session的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上 cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie 单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie 建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中 session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息 session中保存的是对象，cookie中保存的是字符串 8. session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的 web Storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用 web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生 sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的 Web Storage的好处 减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递 快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便 浏览器本地存储与服务器端存储的区别 数据既可以在浏览器本地存储，也可以在服务器端存储 浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据 服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据 服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端 ，服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上 服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期 服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据 sessionStorage、localStorage和cookie的区别 相同点是都是保存在浏览器端、且同源的 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 web Storage的api接口使用更方便 sessionStorage与页面js数据对象的区别 页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了 sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在 ","permalink":"https://waite.wang/posts/web/difference-between-cookie-session-localstorage/","summary":"\u003ch2 id=\"概念的理解\"\u003e概念的理解\u003c/h2\u003e\n\u003ch3 id=\"webstorage本地存储\"\u003ewebstorage本地存储\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003ewebstorage是本地存储，存储在客户端，包括localStorage和sessionStorage\u003c/li\u003e\n\u003cli\u003elocalStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信\u003c/li\u003e\n\u003cli\u003esessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\u003c/li\u003e\n\u003cli\u003eWebStorage的目标 提供一种在cookie之外存储会话数据的路径 提供一种存储大量可以跨会话存在的数据的机制 HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）\u003c/li\u003e\n\u003cli\u003e作用域的不同： 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的\u003c/li\u003e\n\u003cli\u003e存储大小： localStorage和sessionStorage的存储数据大小一般都是：5MB\u003c/li\u003e\n\u003cli\u003e存储位置： localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信\u003c/li\u003e\n\u003cli\u003e存储内容类型： localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理\u003c/li\u003e\n\u003cli\u003e获取方式： localStorage：window.localStorage;；sessionStorage：window.sessionStorage;\u003c/li\u003e\n\u003cli\u003e应用场景： localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据，而sessionStorage：敏感账号一次性登录\u003c/li\u003e\n\u003cli\u003eWebStorage的优点： 存储空间更大：cookie为4KB，而WebStorage是5MB 节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量 对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便 快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快 安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题 WebStorage提供了一些方法，数据操作比cookie方便 setItem (key, value) —— 保存数据，以键值对的方式储存信息。 getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。 removeItem (key) —— 删除单个数据，根据键值移除对应的信息。 clear () —— 删除所有的数据 key (index) —— 获取某个索引的key\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"cookie\"\u003ecookie\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eHTTP Cookie简称cookie,在HTTP请求发送Set-Cookie HTTP头作为响应的一部分。通过name=value的形式存储\u003c/li\u003e\n\u003cli\u003ecookie的构成： 名称：name(不区分大小写,但最好认为它是区分的) 值:value(通过URL编码:encodeURIComponent) 域 路径 失效时间:一般默认是浏览器关闭失效,可以自己设置失效时间 安全标志:设置安全标志后只有SSL连接的时候才发送到服务器\u003c/li\u003e\n\u003cli\u003ecookie的作用:主要用于保存登录信息\u003c/li\u003e\n\u003cli\u003e生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\u003c/li\u003e\n\u003cli\u003ecookie的优点：具有极高的扩展性和可用性 通过良好的编程，控制保存在cookie中的session对象的大小 通过加密和安全传输技术，减少cookie被破解的可能性 只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失 控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就 是一个过期的cookie\u003c/li\u003e\n\u003cli\u003ecookie的缺点： cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉 安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若吧计数器保存在客户端，则起不到什么作用\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"sessionstorage\"\u003esessionStorage\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003esessionStorage是Storage类型的一个对象，拥有clear(),getItem(name),key(index),removeItem(name),setItem(name,value)方法\u003c/li\u003e\n\u003cli\u003esessionStorage对象存储特定于某个会话的数据,也就是该数据只保持到浏览器关闭\u003c/li\u003e\n\u003cli\u003e将数据保存在session对象中。所谓session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据\u003c/li\u003e\n\u003cli\u003esessionStorage为临时保存\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"localstorage\"\u003elocalStorage\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003elocalStorage也是Storage类型的一个对象\u003c/li\u003e\n\u003cli\u003e在HTML5中localStorage作为持久保存在客户端数据的方案取代了globalStorage(globalStorage必须指定域名)\u003c/li\u003e\n\u003cli\u003elocalStorage会永久存储会话数据，除非removeItem,否则会话数据一直存在\u003c/li\u003e\n\u003cli\u003e将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用 5. localStorage为永久保存\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"区别的比较\"\u003e区别的比较\u003c/h2\u003e\n\u003ch3 id=\"本地储存localstorage与cookie的区别\"\u003e本地储存localStorage与cookie的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003ecookie在浏览器与服务器之间来回传递 sessionStorage和localStorage不会把数据发给服务器，仅在本地保存\u003c/li\u003e\n\u003cli\u003e数据有效期不同 cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 sessionStorage：仅在当前浏览器窗口关闭前有效 localStorage 始终有效，长期保存\u003c/li\u003e\n\u003cli\u003ecookie数据还有路径的概念，可以限制cookie只属于某个路径下 存储大小也不同，cookie数据不能超过4k，sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\u003c/li\u003e\n\u003cli\u003e作用域不用 sessionStorage不在不同的浏览器窗口中共享 localStorage在所有同源窗口中都是共享的 cookie也是在所有同源窗口中都是共享的 WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"cookiesession和localstorage的区别\"\u003ecookie、session和localStorage的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003ecookie的内容主要包括：名字、值、过期时间、路径和域，路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失，这种生命期为浏览器会话期的cookie被称为会话cookie\u003c/li\u003e\n\u003cli\u003e会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。\u003c/li\u003e\n\u003cli\u003e当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"cookie和session的区别\"\u003ecookie和session的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003ecookie数据存放在客户的浏览器上，session数据放在服务器上\u003c/li\u003e\n\u003cli\u003ecookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session\u003c/li\u003e\n\u003cli\u003esession会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie\u003c/li\u003e\n\u003cli\u003e单个cookie保存的数*据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie\u003c/li\u003e\n\u003cli\u003e建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中\u003c/li\u003e\n\u003cli\u003esession保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息\u003c/li\u003e\n\u003cli\u003esession中保存的是对象，cookie中保存的是字符串 8. session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"web-storage和cookie的区别\"\u003eweb Storage和cookie的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003eWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用\u003c/li\u003e\n\u003cli\u003eweb storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie\u003c/li\u003e\n\u003cli\u003e但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生 sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的\u003c/li\u003e\n\u003cli\u003eWeb Storage的好处 减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递 快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"浏览器本地存储与服务器端存储的区别\"\u003e浏览器本地存储与服务器端存储的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e数据既可以在浏览器本地存储，也可以在服务器端存储\u003c/li\u003e\n\u003cli\u003e浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据\u003c/li\u003e\n\u003cli\u003e服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据\u003c/li\u003e\n\u003cli\u003e服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端 ，服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上\u003c/li\u003e\n\u003cli\u003e服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期\u003c/li\u003e\n\u003cli\u003e服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"sessionstoragelocalstorage和cookie的区别\"\u003esessionStorage、localStorage和cookie的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e相同点是都是保存在浏览器端、且同源的\u003c/li\u003e\n\u003cli\u003ecookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下\u003c/li\u003e\n\u003cli\u003e存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大\u003c/li\u003e\n\u003cli\u003e数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭\u003c/li\u003e\n\u003cli\u003e作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的\u003c/li\u003e\n\u003cli\u003eweb Storage支持事件通知机制，可以将数据更新的通知发送给监听者\u003c/li\u003e\n\u003cli\u003eweb Storage的api接口使用更方便\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"sessionstorage与页面js数据对象的区别\"\u003esessionStorage与页面js数据对象的区别\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了\u003c/li\u003e\n\u003cli\u003esessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在\u003c/li\u003e\n\u003c/ol\u003e","title":"cookie、session和localStorage的区别"},{"content":" 以下代码取的是院校专业分数线\nF12 得到接口\nhttps://api.eol.cn/web/api/?local_batch_id=14\u0026amp;local_province_id=31\u0026amp;local_type_id=3\u0026amp;page=1\u0026amp;school_id=31\u0026amp;size=10\u0026amp;special_group=\u0026amp;uri=apidata/api/gk/score/special\u0026amp;year=2021\u0026amp;signsafe=6cdbc334a395abd2a99b9bd8cc29c42f\n推断参数含义 signsafe 数据加密签名获取 搜索 锁定 signsafe 字段以及加密\n以上看到，t就是请求中的signsafe参数。而且，函数中也出现了HmacSHA1、base64等方法。由此可知，定位的加密位置是正确的。接下来需要将加密函数抠下来改写，方便调用。下断点继续跟踪方法调用。跟踪v.a.enc.Utf8.parse方法，如下多次尝试, 最终试出\nvar CryptoJS = require(\u0026#34;crypto-js\u0026#34;); function signsafe_jami(p) { p = p.replace(/^\\/|https?:\\/\\/\\/?/, \u0026#34;\u0026#34;); p = p.replace(/%2F/g, \u0026#34;/\u0026#34;); console.log(p) let f = CryptoJS.HmacSHA1(CryptoJS.enc.Utf8.parse(p), \u0026#34;D23ABC@#56\u0026#34;); f = CryptoJS.enc.Base64.stringify(f).toString(); f = CryptoJS.MD5(f).toString(); return f; } url = \u0026#34;https://api.eol.cn/web/api/?local_batch_id=14\u0026amp;local_province_id=31\u0026amp;local_type_id=3\u0026amp;page=1\u0026amp;school_id=31\u0026amp;size=100\u0026amp;special_group=\u0026amp;uri=apidata%2Fapi%2Fgk%2Fscore%2Fspecial\u0026amp;year=2021\u0026#34; console.log(signsafe_jami(url)) 开始前 先安装 npm install crypto-js\ndata 解析 通过以上 signsafe 访问文章开头接口, 拿到一长串 data 数据(见开头图2)\n从 method 知道使用的是 aes-256-cbc的方式进行加密, 推出加密方法是aes-256， 密钥长度256位，cbc指的是在加密和解密是需要一个初始化向量(Initialization Vector, IV)，在每次加密之前或者解密之后，使用初始化向量与明文或密文异或。说白了，就是设定的密钥，添加一个初始化偏移量。加密时，明文先与iv偏移量异或，再将结果进行256位的块加密，得到的输出就是密文，同时本次的输出密文作为下一个块加密的IV。\n通过搜索 aes 确定疑似代码 进行仿写\n以下代码参考\nvar CryptoJS = CryptoJS || (function (Math, undefined) { var C = {}; var C_lib = C.lib = {}; var Base = C_lib.Base = (function () { function F() {}; return { extend: function (overrides) { F.prototype = this; var subtype = new F(); if (overrides) { subtype.mixIn(overrides); } if (!subtype.hasOwnProperty(\u0026#39;init\u0026#39;) || this.init === subtype.init) { subtype.init = function () { subtype.$super.init.apply(this, arguments); }; } subtype.init.prototype = subtype; subtype.$super = this; return subtype; }, create: function () { var instance = this.extend(); instance.init.apply(instance, arguments); return instance; }, init: function () {}, mixIn: function (properties) { for (var propertyName in properties) { if (properties.hasOwnProperty(propertyName)) { this[propertyName] = properties[propertyName]; } } if (properties.hasOwnProperty(\u0026#39;toString\u0026#39;)) { this.toString = properties.toString; } }, clone: function () { return this.init.prototype.extend(this); } }; }()); var WordArray = C_lib.WordArray = Base.extend({ init: function (words, sigBytes) { words = this.words = words || []; if (sigBytes != undefined) { this.sigBytes = sigBytes; } else { this.sigBytes = words.length * 4; } }, toString: function (encoder) { return (encoder || Hex).stringify(this); }, concat: function (wordArray) { var thisWords = this.words; var thatWords = wordArray.words; var thisSigBytes = this.sigBytes; var thatSigBytes = wordArray.sigBytes; this.clamp(); if (thisSigBytes % 4) { for (var i = 0; i \u0026lt; thatSigBytes; i++) { var thatByte = (thatWords[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; thisWords[(thisSigBytes + i) \u0026gt;\u0026gt;\u0026gt; 2] |= thatByte \u0026lt;\u0026lt; (24 - ((thisSigBytes + i) % 4) * 8); } } else if (thatWords.length \u0026gt; 0xffff) { for (var i = 0; i \u0026lt; thatSigBytes; i += 4) { thisWords[(thisSigBytes + i) \u0026gt;\u0026gt;\u0026gt; 2] = thatWords[i \u0026gt;\u0026gt;\u0026gt; 2]; } } else { thisWords.push.apply(thisWords, thatWords); } this.sigBytes += thatSigBytes; return this; }, clamp: function () { var words = this.words; var sigBytes = this.sigBytes; words[sigBytes \u0026gt;\u0026gt;\u0026gt; 2] \u0026amp;= 0xffffffff \u0026lt;\u0026lt; (32 - (sigBytes % 4) * 8); words.length = Math.ceil(sigBytes / 4); }, clone: function () { var clone = Base.clone.call(this); clone.words = this.words.slice(0); return clone; }, random: function (nBytes) { var words = []; var r = (function (m_w) { var m_w = m_w; var m_z = 0x3ade68b1; var mask = 0xffffffff; return function () { m_z = (0x9069 * (m_z \u0026amp; 0xFFFF) + (m_z \u0026gt;\u0026gt; 0x10)) \u0026amp; mask; m_w = (0x4650 * (m_w \u0026amp; 0xFFFF) + (m_w \u0026gt;\u0026gt; 0x10)) \u0026amp; mask; var result = ((m_z \u0026lt;\u0026lt; 0x10) + m_w) \u0026amp; mask; result /= 0x100000000; result += 0.5; return result * (Math.random() \u0026gt; .5 ? 1 : -1); } }); for (var i = 0, rcache; i \u0026lt; nBytes; i += 4) { var _r = r((rcache || Math.random()) * 0x100000000); rcache = _r() * 0x3ade67b7; words.push((_r() * 0x100000000) | 0); } return new WordArray.init(words, nBytes); } }); var C_enc = C.enc = {}; var Hex = C_enc.Hex = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var hexChars = []; for (var i = 0; i \u0026lt; sigBytes; i++) { var bite = (words[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; hexChars.push((bite \u0026gt;\u0026gt;\u0026gt; 4).toString(16)); hexChars.push((bite \u0026amp; 0x0f).toString(16)); } return hexChars.join(\u0026#39;\u0026#39;); }, parse: function (hexStr) { var hexStrLength = hexStr.length; var words = []; for (var i = 0; i \u0026lt; hexStrLength; i += 2) { words[i \u0026gt;\u0026gt;\u0026gt; 3] |= parseInt(hexStr.substr(i, 2), 16) \u0026lt;\u0026lt; (24 - (i % 8) * 4); } return new WordArray.init(words, hexStrLength / 2); } }; var Latin1 = C_enc.Latin1 = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var latin1Chars = []; for (var i = 0; i \u0026lt; sigBytes; i++) { var bite = (words[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; latin1Chars.push(String.fromCharCode(bite)); } return latin1Chars.join(\u0026#39;\u0026#39;); }, parse: function (latin1Str) { var latin1StrLength = latin1Str.length; var words = []; for (var i = 0; i \u0026lt; latin1StrLength; i++) { words[i \u0026gt;\u0026gt;\u0026gt; 2] |= (latin1Str.charCodeAt(i) \u0026amp; 0xff) \u0026lt;\u0026lt; (24 - (i % 4) * 8); } return new WordArray.init(words, latin1StrLength); } }; var Utf8 = C_enc.Utf8 = { stringify: function (wordArray) { try { return decodeURIComponent(escape(Latin1.stringify(wordArray))); } catch (e) { throw new Error(\u0026#39;Malformed UTF-8 data\u0026#39;); } }, parse: function (utf8Str) { return Latin1.parse(unescape(encodeURIComponent(utf8Str))); } }; var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({ reset: function () { this._data = new WordArray.init(); this._nDataBytes = 0; }, _append: function (data) { if (typeof data == \u0026#39;string\u0026#39;) { data = Utf8.parse(data); } this._data.concat(data); this._nDataBytes += data.sigBytes; }, _process: function (doFlush) { var data = this._data; var dataWords = data.words; var dataSigBytes = data.sigBytes; var blockSize = this.blockSize; var blockSizeBytes = blockSize * 4; var nBlocksReady = dataSigBytes / blockSizeBytes; if (doFlush) { nBlocksReady = Math.ceil(nBlocksReady); } else { nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0); } var nWordsReady = nBlocksReady * blockSize; var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); if (nWordsReady) { for (var offset = 0; offset \u0026lt; nWordsReady; offset += blockSize) { this._doProcessBlock(dataWords, offset); } var processedWords = dataWords.splice(0, nWordsReady); data.sigBytes -= nBytesReady; } return new WordArray.init(processedWords, nBytesReady); }, clone: function () { var clone = Base.clone.call(this); clone._data = this._data.clone(); return clone; }, _minBufferSize: 0 }); var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), init: function (cfg) { this.cfg = this.cfg.extend(cfg); this.reset(); }, reset: function () { BufferedBlockAlgorithm.reset.call(this); this._doReset(); }, update: function (messageUpdate) { this._append(messageUpdate); this._process(); return this; }, finalize: function (messageUpdate) { if (messageUpdate) { this._append(messageUpdate); } var hash = this._doFinalize(); return hash; }, blockSize: 512 / 32, _createHelper: function (hasher) { return function (message, cfg) { return new hasher.init(cfg).finalize(message); }; }, _createHmacHelper: function (hasher) { return function (message, key) { return new C_algo.HMAC.init(hasher, key).finalize(message); }; } }); var C_algo = C.algo = {}; return C; }(Math)); (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_enc = C.enc; var Base64 = C_enc.Base64 = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var map = this._map; wordArray.clamp(); var base64Chars = []; for (var i = 0; i \u0026lt; sigBytes; i += 3) { var byte1 = (words[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; var byte2 = (words[(i + 1) \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - ((i + 1) % 4) * 8)) \u0026amp; 0xff; var byte3 = (words[(i + 2) \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - ((i + 2) % 4) * 8)) \u0026amp; 0xff; var triplet = (byte1 \u0026lt;\u0026lt; 16) | (byte2 \u0026lt;\u0026lt; 8) | byte3; for (var j = 0; (j \u0026lt; 4) \u0026amp;\u0026amp; (i + j * 0.75 \u0026lt; sigBytes); j++) { base64Chars.push(map.charAt((triplet \u0026gt;\u0026gt;\u0026gt; (6 * (3 - j))) \u0026amp; 0x3f)); } } var paddingChar = map.charAt(64); if (paddingChar) { while (base64Chars.length % 4) { base64Chars.push(paddingChar); } } return base64Chars.join(\u0026#39;\u0026#39;); }, parse: function (base64Str) { var base64StrLength = base64Str.length; var map = this._map; var reverseMap = this._reverseMap; if (!reverseMap) { reverseMap = this._reverseMap = []; for (var j = 0; j \u0026lt; map.length; j++) { reverseMap[map.charCodeAt(j)] = j; } } var paddingChar = map.charAt(64); if (paddingChar) { var paddingIndex = base64Str.indexOf(paddingChar); if (paddingIndex !== -1) { base64StrLength = paddingIndex; } } return parseLoop(base64Str, base64StrLength, reverseMap); }, _map: \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#39; }; function parseLoop(base64Str, base64StrLength, reverseMap) { var words = []; var nBytes = 0; for (var i = 0; i \u0026lt; base64StrLength; i++) { if (i % 4) { var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] \u0026lt;\u0026lt; ((i % 4) * 2); var bits2 = reverseMap[base64Str.charCodeAt(i)] \u0026gt;\u0026gt;\u0026gt; (6 - (i % 4) * 2); words[nBytes \u0026gt;\u0026gt;\u0026gt; 2] |= (bits1 | bits2) \u0026lt;\u0026lt; (24 - (nBytes % 4) * 8); nBytes++; } } return WordArray.create(words, nBytes); } }()); CryptoJS.lib.Cipher || (function (undefined) { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var WordArray = C_lib.WordArray; var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm; var C_enc = C.enc; var Utf8 = C_enc.Utf8; var Base64 = C_enc.Base64; var C_algo = C.algo; var EvpKDF = C_algo.EvpKDF; var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), createEncryptor: function (key, cfg) { return this.create(this._ENC_XFORM_MODE, key, cfg); }, createDecryptor: function (key, cfg) { return this.create(this._DEC_XFORM_MODE, key, cfg); }, init: function (xformMode, key, cfg) { this.cfg = this.cfg.extend(cfg); this._xformMode = xformMode; this._key = key; this.reset(); }, reset: function () { BufferedBlockAlgorithm.reset.call(this); this._doReset(); }, process: function (dataUpdate) { this._append(dataUpdate); return this._process(); }, finalize: function (dataUpdate) { if (dataUpdate) { this._append(dataUpdate); } var finalProcessedData = this._doFinalize(); return finalProcessedData; }, keySize: 128 / 32, ivSize: 128 / 32, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: (function () { function selectCipherStrategy(key) { if (typeof key == \u0026#39;string\u0026#39;) { return PasswordBasedCipher; } else { return SerializableCipher; } } return function (cipher) { return { encrypt: function (message, key, cfg) { return selectCipherStrategy(key).encrypt(cipher, message, key, cfg); }, decrypt: function (ciphertext, key, cfg) { return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg); } }; }; }()) }); var StreamCipher = C_lib.StreamCipher = Cipher.extend({ _doFinalize: function () { var finalProcessedBlocks = this._process(!!\u0026#39;flush\u0026#39;); return finalProcessedBlocks; }, blockSize: 1 }); var C_mode = C.mode = {}; var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({ createEncryptor: function (cipher, iv) { return this.Encryptor.create(cipher, iv); }, createDecryptor: function (cipher, iv) { return this.Decryptor.create(cipher, iv); }, init: function (cipher, iv) { this._cipher = cipher; this._iv = iv; } }); var CBC = C_mode.CBC = (function () { var CBC = BlockCipherMode.extend(); CBC.Encryptor = CBC.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; xorBlock.call(this, words, offset, blockSize); cipher.encryptBlock(words, offset); this._prevBlock = words.slice(offset, offset + blockSize); } }); CBC.Decryptor = CBC.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var thisBlock = words.slice(offset, offset + blockSize); cipher.decryptBlock(words, offset); xorBlock.call(this, words, offset, blockSize); this._prevBlock = thisBlock; } }); function xorBlock(words, offset, blockSize) { var iv = this._iv; if (iv) { var block = iv; this._iv = undefined; } else { var block = this._prevBlock; } for (var i = 0; i \u0026lt; blockSize; i++) { words[offset + i] ^= block[i]; } } return CBC; }()); var C_pad = C.pad = {}; var Pkcs7 = C_pad.Pkcs7 = { pad: function (data, blockSize) { var blockSizeBytes = blockSize * 4; var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; var paddingWord = (nPaddingBytes \u0026lt;\u0026lt; 24) | (nPaddingBytes \u0026lt;\u0026lt; 16) | (nPaddingBytes \u0026lt;\u0026lt; 8) | nPaddingBytes; var paddingWords = []; for (var i = 0; i \u0026lt; nPaddingBytes; i += 4) { paddingWords.push(paddingWord); } var padding = WordArray.create(paddingWords, nPaddingBytes); data.concat(padding); }, unpad: function (data) { var nPaddingBytes = data.words[(data.sigBytes - 1) \u0026gt;\u0026gt;\u0026gt; 2] \u0026amp; 0xff; data.sigBytes -= nPaddingBytes; } }; var BlockCipher = C_lib.BlockCipher = Cipher.extend({ cfg: Cipher.cfg.extend({ mode: CBC, padding: Pkcs7 }), reset: function () { Cipher.reset.call(this); var cfg = this.cfg; var iv = cfg.iv; var mode = cfg.mode; if (this._xformMode == this._ENC_XFORM_MODE) { var modeCreator = mode.createEncryptor; } else { var modeCreator = mode.createDecryptor; this._minBufferSize = 1; } if (this._mode \u0026amp;\u0026amp; this._mode.__creator == modeCreator) { this._mode.init(this, iv \u0026amp;\u0026amp; iv.words); } else { this._mode = modeCreator.call(mode, this, iv \u0026amp;\u0026amp; iv.words); this._mode.__creator = modeCreator; } }, _doProcessBlock: function (words, offset) { this._mode.processBlock(words, offset); }, _doFinalize: function () { var padding = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { padding.pad(this._data, this.blockSize); var finalProcessedBlocks = this._process(!!\u0026#39;flush\u0026#39;); } else { var finalProcessedBlocks = this._process(!!\u0026#39;flush\u0026#39;); padding.unpad(finalProcessedBlocks); } return finalProcessedBlocks; }, blockSize: 128 / 32 }); var CipherParams = C_lib.CipherParams = Base.extend({ init: function (cipherParams) { this.mixIn(cipherParams); }, toString: function (formatter) { return (formatter || this.formatter).stringify(this); } }); var C_format = C.format = {}; var OpenSSLFormatter = C_format.OpenSSL = { stringify: function (cipherParams) { var ciphertext = cipherParams.ciphertext; var salt = cipherParams.salt; if (salt) { var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext); } else { var wordArray = ciphertext; } return wordArray.toString(Base64); }, parse: function (openSSLStr) { var ciphertext = Base64.parse(openSSLStr); var ciphertextWords = ciphertext.words; if (ciphertextWords[0] == 0x53616c74 \u0026amp;\u0026amp; ciphertextWords[1] == 0x65645f5f) { var salt = WordArray.create(ciphertextWords.slice(2, 4)); ciphertextWords.splice(0, 4); ciphertext.sigBytes -= 16; } return CipherParams.create({ ciphertext: ciphertext, salt: salt }); } }; var SerializableCipher = C_lib.SerializableCipher = Base.extend({ cfg: Base.extend({ format: OpenSSLFormatter }), encrypt: function (cipher, message, key, cfg) { cfg = this.cfg.extend(cfg); var encryptor = cipher.createEncryptor(key, cfg); var ciphertext = encryptor.finalize(message); var cipherCfg = encryptor.cfg; return CipherParams.create({ ciphertext: ciphertext, key: key, iv: cipherCfg.iv, algorithm: cipher, mode: cipherCfg.mode, padding: cipherCfg.padding, blockSize: cipher.blockSize, formatter: cfg.format }); }, decrypt: function (cipher, ciphertext, key, cfg) { cfg = this.cfg.extend(cfg); ciphertext = this._parse(ciphertext, cfg.format); var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext); return plaintext; }, _parse: function (ciphertext, format) { if (typeof ciphertext == \u0026#39;string\u0026#39;) { return format.parse(ciphertext, this); } else { return ciphertext; } } }); var C_kdf = C.kdf = {}; var OpenSSLKdf = C_kdf.OpenSSL = { execute: function (password, keySize, ivSize, salt) { if (!salt) { salt = WordArray.random(64 / 8); } var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt); var iv = WordArray.create(key.words.slice(keySize), ivSize * 4); key.sigBytes = keySize * 4; return CipherParams.create({ key: key, iv: iv, salt: salt }); } }; var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({ cfg: SerializableCipher.cfg.extend({ kdf: OpenSSLKdf }), encrypt: function (cipher, message, password, cfg) { cfg = this.cfg.extend(cfg); var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); cfg.iv = derivedParams.iv; var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg); ciphertext.mixIn(derivedParams); return ciphertext; }, decrypt: function (cipher, ciphertext, password, cfg) { cfg = this.cfg.extend(cfg); ciphertext = this._parse(ciphertext, cfg.format); var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt); cfg.iv = derivedParams.iv; var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg); return plaintext; } }); }()); (function () { var C = CryptoJS; var C_lib = C.lib; var BlockCipher = C_lib.BlockCipher; var C_algo = C.algo; var SBOX = []; var INV_SBOX = []; var SUB_MIX_0 = []; var SUB_MIX_1 = []; var SUB_MIX_2 = []; var SUB_MIX_3 = []; var INV_SUB_MIX_0 = []; var INV_SUB_MIX_1 = []; var INV_SUB_MIX_2 = []; var INV_SUB_MIX_3 = []; (function () { var d = []; for (var i = 0; i \u0026lt; 256; i++) { if (i \u0026lt; 128) { d[i] = i \u0026lt;\u0026lt; 1; } else { d[i] = (i \u0026lt;\u0026lt; 1) ^ 0x11b; } } var x = 0; var xi = 0; for (var i = 0; i \u0026lt; 256; i++) { var sx = xi ^ (xi \u0026lt;\u0026lt; 1) ^ (xi \u0026lt;\u0026lt; 2) ^ (xi \u0026lt;\u0026lt; 3) ^ (xi \u0026lt;\u0026lt; 4); sx = (sx \u0026gt;\u0026gt;\u0026gt; 8) ^ (sx \u0026amp; 0xff) ^ 0x63; SBOX[x] = sx; INV_SBOX[sx] = x; var x2 = d[x]; var x4 = d[x2]; var x8 = d[x4]; var t = (d[sx] * 0x101) ^ (sx * 0x1010100); SUB_MIX_0[x] = (t \u0026lt;\u0026lt; 24) | (t \u0026gt;\u0026gt;\u0026gt; 8); SUB_MIX_1[x] = (t \u0026lt;\u0026lt; 16) | (t \u0026gt;\u0026gt;\u0026gt; 16); SUB_MIX_2[x] = (t \u0026lt;\u0026lt; 8) | (t \u0026gt;\u0026gt;\u0026gt; 24); SUB_MIX_3[x] = t; var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100); INV_SUB_MIX_0[sx] = (t \u0026lt;\u0026lt; 24) | (t \u0026gt;\u0026gt;\u0026gt; 8); INV_SUB_MIX_1[sx] = (t \u0026lt;\u0026lt; 16) | (t \u0026gt;\u0026gt;\u0026gt; 16); INV_SUB_MIX_2[sx] = (t \u0026lt;\u0026lt; 8) | (t \u0026gt;\u0026gt;\u0026gt; 24); INV_SUB_MIX_3[sx] = t; if (!x) { x = xi = 1; } else { x = x2 ^ d[d[d[x8 ^ x2]]]; xi ^= d[d[xi]]; } } }()); var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]; var AES = C_algo.AES = BlockCipher.extend({ _doReset: function () { if (this._nRounds \u0026amp;\u0026amp; this._keyPriorReset === this._key) { return; } var key = this._keyPriorReset = this._key; var keyWords = key.words; var keySize = key.sigBytes / 4; var nRounds = this._nRounds = keySize + 6; var ksRows = (nRounds + 1) * 4; var keySchedule = this._keySchedule = []; for (var ksRow = 0; ksRow \u0026lt; ksRows; ksRow++) { if (ksRow \u0026lt; keySize) { keySchedule[ksRow] = keyWords[ksRow]; } else { var t = keySchedule[ksRow - 1]; if (!(ksRow % keySize)) { t = (t \u0026lt;\u0026lt; 8) | (t \u0026gt;\u0026gt;\u0026gt; 24); t = (SBOX[t \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[t \u0026amp; 0xff]; t ^= RCON[(ksRow / keySize) | 0] \u0026lt;\u0026lt; 24; } else if (keySize \u0026gt; 6 \u0026amp;\u0026amp; ksRow % keySize == 4) { t = (SBOX[t \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[t \u0026amp; 0xff]; } keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t; } } var invKeySchedule = this._invKeySchedule = []; for (var invKsRow = 0; invKsRow \u0026lt; ksRows; invKsRow++) { var ksRow = ksRows - invKsRow; if (invKsRow % 4) { var t = keySchedule[ksRow]; } else { var t = keySchedule[ksRow - 4]; } if (invKsRow \u0026lt; 4 || ksRow \u0026lt;= 4) { invKeySchedule[invKsRow] = t; } else { invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t \u0026gt;\u0026gt;\u0026gt; 24]] ^ INV_SUB_MIX_1[SBOX[(t \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff]] ^ INV_SUB_MIX_2[SBOX[(t \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff]] ^ INV_SUB_MIX_3[SBOX[t \u0026amp; 0xff]]; } } }, encryptBlock: function (M, offset) { this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX); }, decryptBlock: function (M, offset) { var t = M[offset + 1]; M[offset + 1] = M[offset + 3]; M[offset + 3] = t; this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); var t = M[offset + 1]; M[offset + 1] = M[offset + 3]; M[offset + 3] = t; }, _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) { var nRounds = this._nRounds; var s0 = M[offset] ^ keySchedule[0]; var s1 = M[offset + 1] ^ keySchedule[1]; var s2 = M[offset + 2] ^ keySchedule[2]; var s3 = M[offset + 3] ^ keySchedule[3]; var ksRow = 4; for (var round = 1; round \u0026lt; nRounds; round++) { var t0 = SUB_MIX_0[s0 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s1 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s2 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s3 \u0026amp; 0xff] ^ keySchedule[ksRow++]; var t1 = SUB_MIX_0[s1 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s2 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s3 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s0 \u0026amp; 0xff] ^ keySchedule[ksRow++]; var t2 = SUB_MIX_0[s2 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s3 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s0 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s1 \u0026amp; 0xff] ^ keySchedule[ksRow++]; var t3 = SUB_MIX_0[s3 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s0 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s1 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s2 \u0026amp; 0xff] ^ keySchedule[ksRow++]; s0 = t0; s1 = t1; s2 = t2; s3 = t3; } var t0 = ((SBOX[s0 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s1 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s2 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s3 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; var t1 = ((SBOX[s1 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s2 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s3 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s0 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; var t2 = ((SBOX[s2 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s3 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s0 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s1 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; var t3 = ((SBOX[s3 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s0 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s1 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s2 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; M[offset] = t0; M[offset + 1] = t1; M[offset + 2] = t2; M[offset + 3] = t3; }, keySize: 256 / 32 }); C.AES = BlockCipher._createHelper(AES); }()); var key = CryptoJS.enc.Hex.parse(\u0026#34;4587dc9b6a7c3e9ef3b920f994edc3a210c460977528138d41e58b9b02c94ffd\u0026#34;); var iv = CryptoJS.enc.Hex.parse(\u0026#34;6aa677d0f4d6646eec5e9a82aedb60b0\u0026#34;); function AES_Encrypt(word) { var srcs = CryptoJS.enc.Utf8.parse(word); var encrypted = CryptoJS.AES.encrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return CryptoJS.enc.Hex.stringify(CryptoJS.enc.Base64.parse(encrypted.toString())); } function AES_Decrypt(word) { var srcs = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Hex.parse(word)); var decrypt = CryptoJS.AES.decrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return decrypt.toString(CryptoJS.enc.Utf8); } var data=\u0026#39;eab8325abc5a1440b7708431e83f79acbb6d93e754ffb97db9a3e909336ebc6fa5c77d03767d43a902fe34554e069f3ef108ec973e20e97d0c32be7356d22a1f6e8ea837a9814ec86c6859fb3b96d3fb658ac67993f1beb71831fe406a0d26a2862bdc2b568b65980797ca725824759bab768cd65bc15fcc52ca58a02804456bbe1e7512fdd99a59fbd3b83f957f8250480999e1cbcbe148c99cfd11126d55371ccb563548ccd8df5587782dd7bc28eee2ef21d05fb580a861550283497ddd771692cc2f0d52f202b9368ba1f588f31097abca6503bfb6fc7a94181c21ff775448d62490d419ff52c0764f4a5a4086c31c12cdb3d6c49e5c100f4fc50db3ee3f069df5f3c0f5e2508261b2522240c5db187136d784ce1b71dfa8929271c22c8786e5cc96e5f810b11eff50ade8b8d88ce2c8897bd20bf07edc08a113344d313b8793288a62c389f307e49b52a86cc7c7180e805e375c338734052ea92a790b1d1461f9ff43617662256f616f73b65e1578fe5d76de4f9267497aaaad11d315b686e57c0d30d9ff0e16815cfe86315108f85de0c86096eb839dc68501874e671daaec503be3a02c8acde0f9be9948ca59e64bd9a7ecdfc62d2e431293c18844b5cc9ee07b7ac8135a69c2519b764d58a5363101a87d0c01400953bdc9927960956d2d93b824025248b02be7f00326e42ab37dcb9fb9a1b878eb5872249b6ed01a4662263d4ebc77e27be90cba3e06b5507c27736100847ea4ef4fff5517f5ecfc0149c3629c8d07c33a5f82467ae05013100af71070d3ca4197cf1a78151d809f675fcb2dee5609458d9a7c897c10cfe9a208abd05112b758c9c1a3fb8dba74972756dda008a5421443ca0e43be22dac7ac7bb6dc5d4f4e5fd3e1da327385fbffded88345fb66ef79fbcdcb7c3cb41232e7b4a06ae87d5c46e81efae06a86ddaa30d6e8e89a5c5ef7a26f96654fc4ffe0ce2496ab1c63d004502371626f2db6988002fc965b5cbcbfe1fc5d15ea396754c893df2fa3907cf45ea02afc3468a2646bd950e05b5ea8be736e7278d0891a1f2373a126b1267c19e5f9043825eed12d10d89b848bff44a44fb473cb425461bb67ba784d098060242df0605b6d62fe9fd1e7d832921124a0dde051e7b7d52630629523a817f09f7fac73d6d3fa59b727835eb0ae715a9f3f976c075acb616d1df462c56cdf494bb9fb320db118e8c85a132adda817cfcdf3d31d74b4a011f4f588bc17d296631e3d81ca37330c75e39d02b4f801b6fb73f0e77e2c4fe355b911ac2d6ede9edbec8a5587300557cb090fa50772fd8ab1b66b9ce68642d7326282001fec8c8f60d0864f543b8f4a4190803b954dd251a5e4cb1ddf8afdf1aef21203c06ebb88101c33bf70929d88f989112b653e71207d95ea5aad995a9634b9f2fb5f5180de0999cc0baee0286532aaa6cdcf3ff3719bd0934a355854881c08a01bff50fc031d5eab22155958677eebdd332a91435017c9c5260a54bf8d6461368fc5a28b0f0b12731592aae1caa21f59236df5516f2bf079da2d13fed406389c584e03232dd4fbf8b944476b9bacd4f3b4394af8651f03b81aec237527df8c6d45f2653b23685d08789e5d47d9e8117979a5d904225cdf48dbd25a2b7c61c1be507a6f322ecb823b4f7b62686914556957602075b13be2dac9af3bf7fe22b361bd3963724084cfdbca957134f32f75a1f0e1f63ff640999d16ad7675ab5da48d6c49d5e85e4bd5dddf2620c29f313add184c0123e587fe03d0d0833175e2c05c9cc3794934ae0c8dac883147b2f8bf0e8b44588f6b539c227c12aee61146c7d83f861fe7ebc1a8c549c108627d7bdbc9a77c41e43aea45f6473cf8c92738fe5547f29aee6e9969afb7fb1b17bc6a8fffb2a0e23c97f66d025c0670ef5b45d2b0506e5c09469e43814d1f9f520dd0c3f80184e7d7c89aa6cd9451e192685c18c63053ef61cf7711e4fc0104d0238d2946ed5a523d06674c76e6e6548271b6243d8a1adc220d5330362534b2f0fd9a787c84761c466d7b083a8fc7f902c2af18c02661e16af6b0a35224f0728ceb779e27216eb83a7f576aab0818ed2065310e06dee0c56416915c9d4eee5e268ea169cba8e969434e2181067d17eaa2d7691b130e20b7c9c39f51ccb0e834f97938a45ac63abfa1fc17ab6d06aa2588fd9a4159f2e00a744a7fd6d10105f9adb797984504df3d5228a814ee481521d6172e11a9266a55340acadfeb290c894d529f1abf5d885163e9d07f29eedd2828becaa23eed25aa858e26c9e82052d882589decbd3aa8721cf972b4237811831006788f9637a7769ee791603e595d07930d0e8f3391c626f665e7cfad4b83f1cfda8a10615faeb6bfc3042a1365daded79cff122db62f9bda995d88e8a9d9748e34e4f08b0dcb19d00135aa082f6a82af4f63feeff76af878dde25d792939035465c1a601f0e41dd7b2b37f6fc3e39fb105b9e94dd839257a0782621010538eca656aedf386fb2a136c2ecba35b32d537edb110b974eca7b7345b525fd5b679d741389e15d910d8f8b76e5f8776e017913c32a3384cceafad190bdc09b398c5b8cb259015f08ea4d8d5e27ca1d2b7930b7bbfcea03a449958f835f032ce85b41c82ada0195a047afe872085f6d2a11c4a7b6765c80aed6a2293118d3d478debd7401f7c07082b529bc70dfea042fac0222588e9b3dea91f16804c8e12ac8e2ac084f374477a9b60ef02c97cb1e136b1a7bff6ed0505216abeeb8b60e0fa6cd05383129c01c1b8643a648294199a71d40956a22879dffce5a16fe3d189c3fda64c82b3251d64e67e5286f9182192e2897f922f1ca5194a35e7134dc0f9f74be0300bce46ea90bc0a598ebf52522bf264dbceabec45813814cfd94581df49c5d5fc4222158dcf33d443000d22f6b9ab27b97d4a2571e16ec53703806072868a34b5c8b501624df2eaecaaff1f228158815c2c9fe9960ea20a21cd5e980e2b3c6121468adc90e9a3d1229989d2f4ec89e107d39cd3f6a6de5c5e38bfc6419b97fdeccbdad1b796eaf3d3c9b92ff62d1d55d86ec52a2d0ca92a6fc9a00818b883df5f96723bc1bc8063b664260df4b678cab9c05dda1060aff946e7104c5a4ded8b68bfb96ec7556fa5d1d9f617e41ac4c486671bb89bbd53f55fd34adc6965ee8c9afe3e2ad1ed06479130f0d758ca336326210090e2015aa2be5798d604b8074233c8d099c8e1b101c7f96c78306257e4973044af48110f326770ceeed2b35d87a3f6ce3fc96f97187605101654996c3338c82de4ac8734159cbac1a4847292ad030d398d5dc7351276ef23585ea52b1fbbe723394b91ef303f38bad03ab0b9b2a787124a34eb799c448402a70100aa7350cd3a58c6931f94179117c64b2a8c86928d614835f4c1bc29c546d913932cb17b78c1bac3c8dcd03130cbdd3889f0b5b46e7ff8c2007e5bbf6689049eae153fb93574a7134f2ccb4f1df1387e1baa1141b4ccb8d56ba764bdb73fd483a131bb1c2843fe12323e3692cc373d46664957e74d36ccd8e308636670b625549ecd103d4d51960215dc4b7d34fd035400e4cbaf0a98419e32ba9509c5738d01a4651c033b9b53a093327204cb45667cdc3ecacd75cc60a2abaf7665f4a6c091489c99dee08ee12e8736a17dbe000c9a78a4450e88d112db1215e6148dd1debfc91242289e90a303b280fb5f5ba12f43c45909f56a9eca8affe9f36560949d8abdb8e362c666efcf56f390c8ec48e0f6e9380dcc9fc62b55fb9cd7c2177ada9b8e73ed4fd6f8eff5fb5170507e4ec16438947c2c5b42082ed000d2414e7141b4a4f8443941433812b89ebdff6cdbaafcfc65ed1357ae4d11f23535b77e859fa313a1f97c9aa7038770cade727ea9341e5c6455e9aa0ab04af3b44c75ae16c4f6518630997774129c9b688206c0f4d1c79c12774552ecc27d8317f7f8f48c67cb24b84537be0a37fabf69ae995267ff70752d893dc09d2ed4967dc48ec7e64a9e36af8f97a957bb1266d5764d8277cdcc634f6ddda6473daf8cd7fc3efca9dfdd997b90a2961b7ac71b839a2f40b59daeef9a9b3e153a8f6f26bd956e7433635ba554c40c2bf6f7a3747dd539c930bf951bf09bf96660d51efa7ca291a053592a834b608b1b645c94b8dd7fcff79ae7bebe33c8ad5ca10e138ca054223edc5778ac62e6d38dd61dddca4a298ee4f2dab1f8a45828852156165ddad93dacfbadacfef92bfc5cc49c8f54b55fa029b21707a3dba0cb820cc38c1e457bc2766e0d699c6e5470ab0094bce377361abd8abc6272e93a743856385d5ed570dcc40a9704ff46d27ceb1612808068f57bc1bda7b03f64446058b60bc618a6b83c19ef1f20e3bf1b4a3ebd13fa2be0f34d6f03823f30644850c2635ee2baa4347dad5b677660635000b316f36c157c3713cc1fb8d922b6abf64790d73e5899f6dfeca58df1e4c2f37bd1473ba1df60e18bcd496150f2cd4ed859c9058ffbe1dcbc29870bc7043e7587694e6de3263a7c66db983a90e85922ffea3f5ddb746bdd26ad24f2bd4c3e1670c76ac6cdde0335e14fe741223cf216829532de108fa72493ff60ecd2f32bb7bd35e06a1a01ca25456cd8a9ca669fd0cc977ca2d1633be1de6a9b9086eed70e6f5b750657c852da4dc914b3049540014242b473e9e677afba3248eced6cb30357e6858e1967781641b25f0d0639c519642fd464f3e08e9a5e275cc943c391a9c18ec616b196166175e45030146b27b51608882f24e6bb2edb33bcfcfbd2bead8a54ddfe8793bd607f4dbf5d8180f2e0a5488f8c51669c1132dd8a1ed86dad3bf4f4fb14cd6b3d128f8fb54a55df88d09832f1313f237d5b43c9fcb6e5e31164a81eb579430f97dd39e5eba80a9f1cf05af2b623c64bd6146d4f6a980176fa30bb47a626e15f44b636bec735b41a404c1e7a279b931af69b9b1b7746bef945c38c1917085a195c9ef7c8d29c4c1d4e2e6c5443d4cc6fd13fc1bdf849a59ad3df1ea57ab0a5f066a0821ee3fa899d6d70720b3b31d2d268d5f7bfe5dc5d5a1dd44a13fead05cb53638d783939592dfe19ebf52a06afb37b1c885906d992b19576d4fb4bf85f892eaa515bc1791c1c5ae5101e91a93ea6204baeae7b45e531f1460062508d5d4a09ba4e63ce55128b7fecb5f81e61f51e23e4185e968109608e2c594903a4525e4cc8eb35043be7a2399f53edd775a78e43325dbd064219511a0683ab356ebe9cdd0d9da7f85fbee24d2a3d32cb8365382b9b2578aa93cbb5bd00e9b6921502e02af6b4439b1c2cf36cb9597ced751f6c6d490645c2af91115e82530a60c79fa71f88fbd6a7c8412f934374645c1588e39dc827d54f806152d89190d9889e46455483092c22a5d8de2e78ad7f140199ef7dd19d6d92de3c649c9fbb19f6f68d4b786855b022bcb4a453a2bd32db10fbbe58b7c665552d81303069b3fa49a49a0c51e989d857dc49d1ff7e7201177d610a8419e94889c4693c13934dafff162be6e3830695e55d60aa44840e3bc61233128ff2b0bb834cda423cc10dc7ac36a7747aa778025b9716e71f49321b95e6490a9223387ecb4c0c41a66b4ea516f3400048443d6b217ecfa1fa4b89cad746fce2bebef7204cd38ae4b1b021bbab60b928d3ab999c3cf4291495419b8cb001d5b1324d00a35e84abd29f3c8e71f183010ae3b7594560ea06a8749600b7c0e596809fa04078da260a02a78ec0fb918908d7148b0acc8d8ec1637aba9b4ad48e1e6358a8c8887e164f3135458bf623201b102ad06079a24a8b87f7e276c645e7cff61603414e565606bddd467da66aebb4d980802ebdd19d41ea924222c6848dc75259d2bbcd3ff3794f398d9de6a63f2e0bf2e30561650f64893a7daf926b42f928f625415bfc14cf524ff713b84408db4c3f7013af976672d486e48b20e9bf99f1d65d32ee0f90998e56ab9156d4f3078d68afbdbb61e259ee554da240eacd6bb974efe4b00429b1f9bf9dce5cbf2256019a7c0bb0772a7690d8fed79cbbf8376ed3791e8b17de6197ba8bb6002366a22577d4d57cc9ee1096e405bdaac9e77d91515269cb0a0fd6b5599fa7bd74bf89d974b69834b5505b58d00a1edba9b693a93507669c997835b7866926c97276af8640bf10663a30ddd8201a1b4bd3c562ad945bc699ebc57dfaa9a79f00d458d3ad82371bca11d57f3fbaa0776f230c0463309196400d07da1c46df36605610c4234fe4ea24cfad116c6b935ce9f6c9447d11c7cd0571639ac6a12786610705c30032376fed8eaa94fca700610ad0903052a89e04b3c8dee60e16f0f6bf479913dc17227d59e497d6e5cc551ec4ef6b41259a88c7e090d74f67a84245b768d11938aaa59e91097bc3adca12b1c066f6834634514184aa98f005b697d136f9ae47b2676d039ec8a54a0aacba8c2de4315d9539b1448e07484388b20f88edc327d505eb3d66371adcc469ad317eb9d0ec9aa26cbca2dec6b9542e8039ec8e298bbc5dfc7c98a07ea46fc95bde8e080da256d84e75f84b15a8a0a0d341149a1404ab6b4fc0fd6e0d03be9aad96d898a3ada0bc58800b6344c3912e881544344a4fea4a070e97e3b59b23cb0490566aa403fe87ec50deea84530dd4ac6ef238fb6ab44539ba5184710d50ef6bfe48cf448021b466a90d987812473da645239d07229539acf1993b76b2c12a48f23973ec1a324e7660a4da3a272e085c3eeb38d7a3cc8de7a44e93d1bdcebc3feb75ce9a537f20e437fd2f7ab70145415c09bd56ca380a3d3011d2e96cb3bcc74c7571a5e3704ad3b6dee3efbbbb9c06ad713fbd5bc3ad12a6e74b1d9fc250d96a86802056c102ba5178b1c3bc32823980f3348e2a6c46e7018da6b2be484ff5b8033332807a90b6428e293135b1199267e7e447000a8e9ceda12313d363b9953a4532da76b861cd3202cd4eef86c20e25b4fe5bdd07333ca14398d0d976cca91033f223b09be37ca9969afdbecdef7d3b0c4743a931d06feea202c70fd1d943288d377192f9e16e40499936eb70304e416821f5818cf5d799a4e2f6a6537a1714f2ff9b0be12561f5e059983ae2d03672fbbcb857b22565f8c6a286ca1c6d4a055b9265e02842cc9d4d37c5fe95766051c42a2b975c21479c810b2859b8863c0ad97e8b2fd08a46363c702dc88760567c8bd5fadb87940acc4f4e52c4ba035b75b9abafbee7ac92c7e52aa8572c2c259840b66981053fd701f8a1a1f2304c9ab39343659def12248718d9a39aa551499cb52d36e415cab6f016b56c2d8e20b49d2ed52d78f0d34c539eefbfeff245c67b3557d9d76fb0ef1d29172e3d674dcbf72067f69ff223bbb1991dff6ea79f35ffaae5f55486322dd6920c75fae42733d5b4b45e99cf26fd7ab7fc41845208dcc7d0c48a732d31a5d041881b3b92ab4400382669fb44e6723662148d96ab9dd7680f53fc4a35678fcf4e1c4eedad8011bb2c8650a3551736928dc1518f84d032458a1a1bc63517e672b42f444a8c7d18e8b9a1883d52954b67151b30b52bf53a40ed5efc1b3df1ef0b60351109c4c6335a2793344e762021a773feae5f81671c4f37e538fadace66c9d265b20d6758c8dfbfbcd8b953fc9f1ce77922bb7953f8d09490ef3dc48a4e84fcf1416408405814bf3858819bb0623a4a224cc800a615d21540adc3350d666d54f78a3535b283ce984455b883b62a82967b0eb2808fdac0c0b14965dae8b9b6df9117629a6ad8207aa7404f86c5019957a89806a981bf8f6a32066ef911d0135fab0a602d4715c826dfa45f31dd16edfafdf60be0860b6a634395ae4d8cf95072e21560171b605e94a73afa84658184122f95b7d4d265446c21fa9d6af6079a11b04ac01dcc42a787ce5bb5dcd2118d51e19260d4da566e70c056d3596b83c0336dd017ad2301d235bc1070849ba8c39d4c99486a805af94ad9eba03d0a4c256eb036335d8e33e0c105a2305a734ea9c38bed6613936efc60a9691936505f76705391c96bd5e66933375937a44f860f5f611954a465a0f657f32a6348501621bc0952a6102ff8257235fe4dc42f03267c7361d28c124e084d6ceab58f4e3992619dd49bbf3dbdb07a4164057302c2701d0f004691231e487746e8ced936b783ffeae8ba07491c69cf0fa4ac3163d09d82ba971523acc995bef28904eaff9483ec383001dd30f2a964aa6ed007e02ebadfbc53daab18e3a2120eb9b739ad40793f72199645890d58027aedb3526f4b89670c0bb78054d2acf7f6f9fd6b2b5209ce402008c2915c8113bac013366ca9b5b348305629130d0a3ab9f22d3bd81f5684034afa6127a13f19fd8e3602754012b6da100147b12850a6738d49c09956b8384e383950d5931948d9bb8b6bc01c92c43f88577b86835a571a872762e004fefe5975cc142719396a416636cd292778d4da6cc2dedc866d5c9526ba9eaded9ad3dd8ca1c500c3bffc35531a0b18fd7ef1d4698a9dd718f4119d40647fad03b20d7d84aa35db532fbee6641cc722b2aaab22761bf0f4f0fb0296855f121986ef12f1cb6d4fd342dbbdb6d016587d18f93f8d1ddfe7cc1d4cd93bb8a216743f694f555ffae9c782277ca880fc94a92c1448debbc1b2229ea609ad5b101fe3e46c96330c891d3d3167aea26254862aff1be5c74c15a3ba79dbcd34f5cb2d1265d6595b92ff691633534f856473d9c3214daa5fb042e64ac72cb5b6730e0e010e705ccdd3c62fbe77eb62187388ff46ba0c072210f40e46c271978f956076e08befa6aece0205948fb760dc0af18154145dc7e805ff066e5a430e517ce9e4df6f1768a61717686c94941cc8e0d427e13ce5e256c5e7b8a943de54ec999b2b8025af3384c36091e88a269bfc865486\u0026#39;; function get_data(){ return AES_Decrypt(data) } console.log(get_data()) 二次重写\nvar CryptoJS = require(\u0026#34;crypto-js\u0026#34;); var key = CryptoJS.enc.Hex.parse(\u0026#34;4587dc9b6a7c3e9ef3b920f994edc3a210c460977528138d41e58b9b02c94ffd\u0026#34;); var iv = CryptoJS.enc.Hex.parse(\u0026#34;6aa677d0f4d6646eec5e9a82aedb60b0\u0026#34;); console.log(key); console.log(iv); function AES_Decrypt(word) { var srcs = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Hex.parse(word)); var decrypt = CryptoJS.AES.decrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return decrypt.toString(CryptoJS.enc.Utf8); } url = \u0026#34;\u0026#34; data = \u0026#34;b9a35487d43ec989030037d14d27e154f69d28fc3d2ac20899b0c6479d652077\u0026#34; console.log(AES_Decrypt(data)) 最终完结, 又因为偷懒 想直接部署到服务器\n使用 express 部署 (第一次写 代码像 ? 一样)\nnpm install express npm install body-parser npm install cors --save npm install crypto-js index.js\n/* 引入express框架 */ const express = require(\u0026#39;express\u0026#39;); const app = express(); /* 引入cors */ const cors = require(\u0026#39;cors\u0026#39;); app.use(cors()); /* 引入body-parser */ const bodyParser = require(\u0026#39;body-parser\u0026#39;); const CryptoJS = require(\u0026#34;crypto-js\u0026#34;); app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: false})); const {get_data} = require(\u0026#34;./data_decode.js\u0026#34;); app.all(\u0026#39;*\u0026#39;, function (req, res, next) { if (!req.get(\u0026#39;Origin\u0026#39;)) return next(); // use \u0026#34;*\u0026#34; here to accept any origin res.set(\u0026#39;Access-Control-Allow-Origin\u0026#39;, \u0026#39;*\u0026#39;); res.set(\u0026#39;Access-Control-Allow-Methods\u0026#39;, \u0026#39;GET\u0026#39;); res.set(\u0026#39;Access-Control-Allow-Headers\u0026#39;, \u0026#39;X-Requested-With, Content-Type\u0026#39;); // res.set(\u0026#39;Access-Control-Allow-Max-Age\u0026#39;, 3600); if (\u0026#39;OPTIONS\u0026#39; == req.method) return res.send(200); next(); }); app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;\u0026lt;p style=\u0026#34;color:red\u0026#34;\u0026gt;服务已启动\u0026lt;/p\u0026gt;\u0026#39;); }) // get接收前端传递过来的参数 app.post(\u0026#34;/api/post/signsafe\u0026#34;,(req,res)=\u0026gt;{ let url = req.body.url; // 接收前端传递过来的参数 console.log(url) let obj = { code: 2000, status: \u0026#39;ok\u0026#39;, data: signsafe_jami(url) } res.send(obj) }) app.get(\u0026#34;/api/get/signsafe\u0026#34;,(req,res)=\u0026gt;{ let url = req.query.url; // 接收前端传递过来的参数 console.log(url) let obj = { code: 2000, status: \u0026#39;ok\u0026#39;, data: signsafe_jami(url) } res.send(obj) } ) app.post(\u0026#34;/api/post/data\u0026#34;,(req,res)=\u0026gt;{ console.log(req.body); let data = req.body.data; // 接收前端传递过来的参数 let obj = { code: 2000, status: \u0026#39;ok\u0026#39;, data: get_data(data) } res.send(obj) }) /* 监听端口 */ app.listen(3000, () =\u0026gt; { console.log(\u0026#39;listen:3000\u0026#39;); }) function signsafe_jami(p) { p = p.replace(/^\\/|https?:\\/\\/\\/?/, \u0026#34;\u0026#34;); p = p.replace(/%2F/g, \u0026#34;/\u0026#34;); console.log(p) let f = CryptoJS.HmacSHA1(CryptoJS.enc.Utf8.parse(p), \u0026#34;D23ABC@#56\u0026#34;); f = CryptoJS.enc.Base64.stringify(f).toString(); f = CryptoJS.MD5(f).toString(); return f; } data_decode.js\nexports.get_data = AES_Decrypt var CryptoJS = require(\u0026#34;crypto-js\u0026#34;); var key = CryptoJS.enc.Hex.parse(\u0026#34;4587dc9b6a7c3e9ef3b920f994edc3a210c460977528138d41e58b9b02c94ffd\u0026#34;); var iv = CryptoJS.enc.Hex.parse(\u0026#34;6aa677d0f4d6646eec5e9a82aedb60b0\u0026#34;); console.log(key); console.log(iv); function AES_Decrypt(word) { var srcs = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Hex.parse(word)); var decrypt = CryptoJS.AES.decrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return decrypt.toString(CryptoJS.enc.Utf8); } 最后记录一下最开始的解密 data 代码 () Tips: 只能说 可以实现 但没必要\nexports.get_data = get_data var CryptoJS = CryptoJS || (function (Math, undefined) { var C = {}; var C_lib = C.lib = {}; var Base = C_lib.Base = (function () { function F() {}; return { extend: function (overrides) { F.prototype = this; var subtype = new F(); if (overrides) { subtype.mixIn(overrides); } if (!subtype.hasOwnProperty(\u0026#39;init\u0026#39;) || this.init === subtype.init) { subtype.init = function () { subtype.$super.init.apply(this, arguments); }; } subtype.init.prototype = subtype; subtype.$super = this; return subtype; }, create: function () { var instance = this.extend(); instance.init.apply(instance, arguments); return instance; }, init: function () {}, mixIn: function (properties) { for (var propertyName in properties) { if (properties.hasOwnProperty(propertyName)) { this[propertyName] = properties[propertyName]; } } if (properties.hasOwnProperty(\u0026#39;toString\u0026#39;)) { this.toString = properties.toString; } }, clone: function () { return this.init.prototype.extend(this); } }; }()); var WordArray = C_lib.WordArray = Base.extend({ init: function (words, sigBytes) { words = this.words = words || []; if (sigBytes != undefined) { this.sigBytes = sigBytes; } else { this.sigBytes = words.length * 4; } }, toString: function (encoder) { return (encoder || Hex).stringify(this); }, concat: function (wordArray) { var thisWords = this.words; var thatWords = wordArray.words; var thisSigBytes = this.sigBytes; var thatSigBytes = wordArray.sigBytes; this.clamp(); if (thisSigBytes % 4) { for (var i = 0; i \u0026lt; thatSigBytes; i++) { var thatByte = (thatWords[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; thisWords[(thisSigBytes + i) \u0026gt;\u0026gt;\u0026gt; 2] |= thatByte \u0026lt;\u0026lt; (24 - ((thisSigBytes + i) % 4) * 8); } } else if (thatWords.length \u0026gt; 0xffff) { for (var i = 0; i \u0026lt; thatSigBytes; i += 4) { thisWords[(thisSigBytes + i) \u0026gt;\u0026gt;\u0026gt; 2] = thatWords[i \u0026gt;\u0026gt;\u0026gt; 2]; } } else { thisWords.push.apply(thisWords, thatWords); } this.sigBytes += thatSigBytes; return this; }, clamp: function () { var words = this.words; var sigBytes = this.sigBytes; words[sigBytes \u0026gt;\u0026gt;\u0026gt; 2] \u0026amp;= 0xffffffff \u0026lt;\u0026lt; (32 - (sigBytes % 4) * 8); words.length = Math.ceil(sigBytes / 4); }, clone: function () { var clone = Base.clone.call(this); clone.words = this.words.slice(0); return clone; }, random: function (nBytes) { var words = []; var r = (function (m_w) { var m_w = m_w; var m_z = 0x3ade68b1; var mask = 0xffffffff; return function () { m_z = (0x9069 * (m_z \u0026amp; 0xFFFF) + (m_z \u0026gt;\u0026gt; 0x10)) \u0026amp; mask; m_w = (0x4650 * (m_w \u0026amp; 0xFFFF) + (m_w \u0026gt;\u0026gt; 0x10)) \u0026amp; mask; var result = ((m_z \u0026lt;\u0026lt; 0x10) + m_w) \u0026amp; mask; result /= 0x100000000; result += 0.5; return result * (Math.random() \u0026gt; .5 ? 1 : -1); } }); for (var i = 0, rcache; i \u0026lt; nBytes; i += 4) { var _r = r((rcache || Math.random()) * 0x100000000); rcache = _r() * 0x3ade67b7; words.push((_r() * 0x100000000) | 0); } return new WordArray.init(words, nBytes); } }); var C_enc = C.enc = {}; var Hex = C_enc.Hex = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var hexChars = []; for (var i = 0; i \u0026lt; sigBytes; i++) { var bite = (words[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; hexChars.push((bite \u0026gt;\u0026gt;\u0026gt; 4).toString(16)); hexChars.push((bite \u0026amp; 0x0f).toString(16)); } return hexChars.join(\u0026#39;\u0026#39;); }, parse: function (hexStr) { var hexStrLength = hexStr.length; var words = []; for (var i = 0; i \u0026lt; hexStrLength; i += 2) { words[i \u0026gt;\u0026gt;\u0026gt; 3] |= parseInt(hexStr.substr(i, 2), 16) \u0026lt;\u0026lt; (24 - (i % 8) * 4); } return new WordArray.init(words, hexStrLength / 2); } }; var Latin1 = C_enc.Latin1 = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var latin1Chars = []; for (var i = 0; i \u0026lt; sigBytes; i++) { var bite = (words[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; latin1Chars.push(String.fromCharCode(bite)); } return latin1Chars.join(\u0026#39;\u0026#39;); }, parse: function (latin1Str) { var latin1StrLength = latin1Str.length; var words = []; for (var i = 0; i \u0026lt; latin1StrLength; i++) { words[i \u0026gt;\u0026gt;\u0026gt; 2] |= (latin1Str.charCodeAt(i) \u0026amp; 0xff) \u0026lt;\u0026lt; (24 - (i % 4) * 8); } return new WordArray.init(words, latin1StrLength); } }; var Utf8 = C_enc.Utf8 = { stringify: function (wordArray) { try { return decodeURIComponent(escape(Latin1.stringify(wordArray))); } catch (e) { throw new Error(\u0026#39;Malformed UTF-8 data\u0026#39;); } }, parse: function (utf8Str) { return Latin1.parse(unescape(encodeURIComponent(utf8Str))); } }; var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({ reset: function () { this._data = new WordArray.init(); this._nDataBytes = 0; }, _append: function (data) { if (typeof data == \u0026#39;string\u0026#39;) { data = Utf8.parse(data); } this._data.concat(data); this._nDataBytes += data.sigBytes; }, _process: function (doFlush) { var data = this._data; var dataWords = data.words; var dataSigBytes = data.sigBytes; var blockSize = this.blockSize; var blockSizeBytes = blockSize * 4; var nBlocksReady = dataSigBytes / blockSizeBytes; if (doFlush) { nBlocksReady = Math.ceil(nBlocksReady); } else { nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0); } var nWordsReady = nBlocksReady * blockSize; var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); if (nWordsReady) { for (var offset = 0; offset \u0026lt; nWordsReady; offset += blockSize) { this._doProcessBlock(dataWords, offset); } var processedWords = dataWords.splice(0, nWordsReady); data.sigBytes -= nBytesReady; } return new WordArray.init(processedWords, nBytesReady); }, clone: function () { var clone = Base.clone.call(this); clone._data = this._data.clone(); return clone; }, _minBufferSize: 0 }); var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), init: function (cfg) { this.cfg = this.cfg.extend(cfg); this.reset(); }, reset: function () { BufferedBlockAlgorithm.reset.call(this); this._doReset(); }, update: function (messageUpdate) { this._append(messageUpdate); this._process(); return this; }, finalize: function (messageUpdate) { if (messageUpdate) { this._append(messageUpdate); } var hash = this._doFinalize(); return hash; }, blockSize: 512 / 32, _createHelper: function (hasher) { return function (message, cfg) { return new hasher.init(cfg).finalize(message); }; }, _createHmacHelper: function (hasher) { return function (message, key) { return new C_algo.HMAC.init(hasher, key).finalize(message); }; } }); var C_algo = C.algo = {}; return C; }(Math)); (function () { var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_enc = C.enc; var Base64 = C_enc.Base64 = { stringify: function (wordArray) { var words = wordArray.words; var sigBytes = wordArray.sigBytes; var map = this._map; wordArray.clamp(); var base64Chars = []; for (var i = 0; i \u0026lt; sigBytes; i += 3) { var byte1 = (words[i \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - (i % 4) * 8)) \u0026amp; 0xff; var byte2 = (words[(i + 1) \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - ((i + 1) % 4) * 8)) \u0026amp; 0xff; var byte3 = (words[(i + 2) \u0026gt;\u0026gt;\u0026gt; 2] \u0026gt;\u0026gt;\u0026gt; (24 - ((i + 2) % 4) * 8)) \u0026amp; 0xff; var triplet = (byte1 \u0026lt;\u0026lt; 16) | (byte2 \u0026lt;\u0026lt; 8) | byte3; for (var j = 0; (j \u0026lt; 4) \u0026amp;\u0026amp; (i + j * 0.75 \u0026lt; sigBytes); j++) { base64Chars.push(map.charAt((triplet \u0026gt;\u0026gt;\u0026gt; (6 * (3 - j))) \u0026amp; 0x3f)); } } var paddingChar = map.charAt(64); if (paddingChar) { while (base64Chars.length % 4) { base64Chars.push(paddingChar); } } return base64Chars.join(\u0026#39;\u0026#39;); }, parse: function (base64Str) { var base64StrLength = base64Str.length; var map = this._map; var reverseMap = this._reverseMap; if (!reverseMap) { reverseMap = this._reverseMap = []; for (var j = 0; j \u0026lt; map.length; j++) { reverseMap[map.charCodeAt(j)] = j; } } var paddingChar = map.charAt(64); if (paddingChar) { var paddingIndex = base64Str.indexOf(paddingChar); if (paddingIndex !== -1) { base64StrLength = paddingIndex; } } return parseLoop(base64Str, base64StrLength, reverseMap); }, _map: \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#39; }; function parseLoop(base64Str, base64StrLength, reverseMap) { var words = []; var nBytes = 0; for (var i = 0; i \u0026lt; base64StrLength; i++) { if (i % 4) { var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] \u0026lt;\u0026lt; ((i % 4) * 2); var bits2 = reverseMap[base64Str.charCodeAt(i)] \u0026gt;\u0026gt;\u0026gt; (6 - (i % 4) * 2); words[nBytes \u0026gt;\u0026gt;\u0026gt; 2] |= (bits1 | bits2) \u0026lt;\u0026lt; (24 - (nBytes % 4) * 8); nBytes++; } } return WordArray.create(words, nBytes); } }()); CryptoJS.lib.Cipher || (function (undefined) { var C = CryptoJS; var C_lib = C.lib; var Base = C_lib.Base; var WordArray = C_lib.WordArray; var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm; var C_enc = C.enc; var Utf8 = C_enc.Utf8; var Base64 = C_enc.Base64; var C_algo = C.algo; var EvpKDF = C_algo.EvpKDF; var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({ cfg: Base.extend(), createEncryptor: function (key, cfg) { return this.create(this._ENC_XFORM_MODE, key, cfg); }, createDecryptor: function (key, cfg) { return this.create(this._DEC_XFORM_MODE, key, cfg); }, init: function (xformMode, key, cfg) { this.cfg = this.cfg.extend(cfg); this._xformMode = xformMode; this._key = key; this.reset(); }, reset: function () { BufferedBlockAlgorithm.reset.call(this); this._doReset(); }, process: function (dataUpdate) { this._append(dataUpdate); return this._process(); }, finalize: function (dataUpdate) { if (dataUpdate) { this._append(dataUpdate); } var finalProcessedData = this._doFinalize(); return finalProcessedData; }, keySize: 128 / 32, ivSize: 128 / 32, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: (function () { function selectCipherStrategy(key) { if (typeof key == \u0026#39;string\u0026#39;) { return PasswordBasedCipher; } else { return SerializableCipher; } } return function (cipher) { return { encrypt: function (message, key, cfg) { return selectCipherStrategy(key).encrypt(cipher, message, key, cfg); }, decrypt: function (ciphertext, key, cfg) { return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg); } }; }; }()) }); var StreamCipher = C_lib.StreamCipher = Cipher.extend({ _doFinalize: function () { var finalProcessedBlocks = this._process(!!\u0026#39;flush\u0026#39;); return finalProcessedBlocks; }, blockSize: 1 }); var C_mode = C.mode = {}; var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({ createEncryptor: function (cipher, iv) { return this.Encryptor.create(cipher, iv); }, createDecryptor: function (cipher, iv) { return this.Decryptor.create(cipher, iv); }, init: function (cipher, iv) { this._cipher = cipher; this._iv = iv; } }); var CBC = C_mode.CBC = (function () { var CBC = BlockCipherMode.extend(); CBC.Encryptor = CBC.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; xorBlock.call(this, words, offset, blockSize); cipher.encryptBlock(words, offset); this._prevBlock = words.slice(offset, offset + blockSize); } }); CBC.Decryptor = CBC.extend({ processBlock: function (words, offset) { var cipher = this._cipher; var blockSize = cipher.blockSize; var thisBlock = words.slice(offset, offset + blockSize); cipher.decryptBlock(words, offset); xorBlock.call(this, words, offset, blockSize); this._prevBlock = thisBlock; } }); function xorBlock(words, offset, blockSize) { var iv = this._iv; if (iv) { var block = iv; this._iv = undefined; } else { var block = this._prevBlock; } for (var i = 0; i \u0026lt; blockSize; i++) { words[offset + i] ^= block[i]; } } return CBC; }()); var C_pad = C.pad = {}; var Pkcs7 = C_pad.Pkcs7 = { pad: function (data, blockSize) { var blockSizeBytes = blockSize * 4; var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; var paddingWord = (nPaddingBytes \u0026lt;\u0026lt; 24) | (nPaddingBytes \u0026lt;\u0026lt; 16) | (nPaddingBytes \u0026lt;\u0026lt; 8) | nPaddingBytes; var paddingWords = []; for (var i = 0; i \u0026lt; nPaddingBytes; i += 4) { paddingWords.push(paddingWord); } var padding = WordArray.create(paddingWords, nPaddingBytes); data.concat(padding); }, unpad: function (data) { var nPaddingBytes = data.words[(data.sigBytes - 1) \u0026gt;\u0026gt;\u0026gt; 2] \u0026amp; 0xff; data.sigBytes -= nPaddingBytes; } }; var BlockCipher = C_lib.BlockCipher = Cipher.extend({ cfg: Cipher.cfg.extend({ mode: CBC, padding: Pkcs7 }), reset: function () { Cipher.reset.call(this); var cfg = this.cfg; var iv = cfg.iv; var mode = cfg.mode; if (this._xformMode == this._ENC_XFORM_MODE) { var modeCreator = mode.createEncryptor; } else { var modeCreator = mode.createDecryptor; this._minBufferSize = 1; } if (this._mode \u0026amp;\u0026amp; this._mode.__creator == modeCreator) { this._mode.init(this, iv \u0026amp;\u0026amp; iv.words); } else { this._mode = modeCreator.call(mode, this, iv \u0026amp;\u0026amp; iv.words); this._mode.__creator = modeCreator; } }, _doProcessBlock: function (words, offset) { this._mode.processBlock(words, offset); }, _doFinalize: function () { var padding = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { padding.pad(this._data, this.blockSize); var finalProcessedBlocks = this._process(!!\u0026#39;flush\u0026#39;); } else { var finalProcessedBlocks = this._process(!!\u0026#39;flush\u0026#39;); padding.unpad(finalProcessedBlocks); } return finalProcessedBlocks; }, blockSize: 128 / 32 }); var CipherParams = C_lib.CipherParams = Base.extend({ init: function (cipherParams) { this.mixIn(cipherParams); }, toString: function (formatter) { return (formatter || this.formatter).stringify(this); } }); var C_format = C.format = {}; var OpenSSLFormatter = C_format.OpenSSL = { stringify: function (cipherParams) { var ciphertext = cipherParams.ciphertext; var salt = cipherParams.salt; if (salt) { var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext); } else { var wordArray = ciphertext; } return wordArray.toString(Base64); }, parse: function (openSSLStr) { var ciphertext = Base64.parse(openSSLStr); var ciphertextWords = ciphertext.words; if (ciphertextWords[0] == 0x53616c74 \u0026amp;\u0026amp; ciphertextWords[1] == 0x65645f5f) { var salt = WordArray.create(ciphertextWords.slice(2, 4)); ciphertextWords.splice(0, 4); ciphertext.sigBytes -= 16; } return CipherParams.create({ ciphertext: ciphertext, salt: salt }); } }; var SerializableCipher = C_lib.SerializableCipher = Base.extend({ cfg: Base.extend({ format: OpenSSLFormatter }), encrypt: function (cipher, message, key, cfg) { cfg = this.cfg.extend(cfg); var encryptor = cipher.createEncryptor(key, cfg); var ciphertext = encryptor.finalize(message); var cipherCfg = encryptor.cfg; return CipherParams.create({ ciphertext: ciphertext, key: key, iv: cipherCfg.iv, algorithm: cipher, mode: cipherCfg.mode, padding: cipherCfg.padding, blockSize: cipher.blockSize, formatter: cfg.format }); }, decrypt: function (cipher, ciphertext, key, cfg) { cfg = this.cfg.extend(cfg); ciphertext = this._parse(ciphertext, cfg.format); var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext); return plaintext; }, _parse: function (ciphertext, format) { if (typeof ciphertext == \u0026#39;string\u0026#39;) { return format.parse(ciphertext, this); } else { return ciphertext; } } }); var C_kdf = C.kdf = {}; var OpenSSLKdf = C_kdf.OpenSSL = { execute: function (password, keySize, ivSize, salt) { if (!salt) { salt = WordArray.random(64 / 8); } var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt); var iv = WordArray.create(key.words.slice(keySize), ivSize * 4); key.sigBytes = keySize * 4; return CipherParams.create({ key: key, iv: iv, salt: salt }); } }; var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({ cfg: SerializableCipher.cfg.extend({ kdf: OpenSSLKdf }), encrypt: function (cipher, message, password, cfg) { cfg = this.cfg.extend(cfg); var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); cfg.iv = derivedParams.iv; var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg); ciphertext.mixIn(derivedParams); return ciphertext; }, decrypt: function (cipher, ciphertext, password, cfg) { cfg = this.cfg.extend(cfg); ciphertext = this._parse(ciphertext, cfg.format); var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt); cfg.iv = derivedParams.iv; var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg); return plaintext; } }); }()); (function () { var C = CryptoJS; var C_lib = C.lib; var BlockCipher = C_lib.BlockCipher; var C_algo = C.algo; var SBOX = []; var INV_SBOX = []; var SUB_MIX_0 = []; var SUB_MIX_1 = []; var SUB_MIX_2 = []; var SUB_MIX_3 = []; var INV_SUB_MIX_0 = []; var INV_SUB_MIX_1 = []; var INV_SUB_MIX_2 = []; var INV_SUB_MIX_3 = []; (function () { var d = []; for (var i = 0; i \u0026lt; 256; i++) { if (i \u0026lt; 128) { d[i] = i \u0026lt;\u0026lt; 1; } else { d[i] = (i \u0026lt;\u0026lt; 1) ^ 0x11b; } } var x = 0; var xi = 0; for (var i = 0; i \u0026lt; 256; i++) { var sx = xi ^ (xi \u0026lt;\u0026lt; 1) ^ (xi \u0026lt;\u0026lt; 2) ^ (xi \u0026lt;\u0026lt; 3) ^ (xi \u0026lt;\u0026lt; 4); sx = (sx \u0026gt;\u0026gt;\u0026gt; 8) ^ (sx \u0026amp; 0xff) ^ 0x63; SBOX[x] = sx; INV_SBOX[sx] = x; var x2 = d[x]; var x4 = d[x2]; var x8 = d[x4]; var t = (d[sx] * 0x101) ^ (sx * 0x1010100); SUB_MIX_0[x] = (t \u0026lt;\u0026lt; 24) | (t \u0026gt;\u0026gt;\u0026gt; 8); SUB_MIX_1[x] = (t \u0026lt;\u0026lt; 16) | (t \u0026gt;\u0026gt;\u0026gt; 16); SUB_MIX_2[x] = (t \u0026lt;\u0026lt; 8) | (t \u0026gt;\u0026gt;\u0026gt; 24); SUB_MIX_3[x] = t; var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100); INV_SUB_MIX_0[sx] = (t \u0026lt;\u0026lt; 24) | (t \u0026gt;\u0026gt;\u0026gt; 8); INV_SUB_MIX_1[sx] = (t \u0026lt;\u0026lt; 16) | (t \u0026gt;\u0026gt;\u0026gt; 16); INV_SUB_MIX_2[sx] = (t \u0026lt;\u0026lt; 8) | (t \u0026gt;\u0026gt;\u0026gt; 24); INV_SUB_MIX_3[sx] = t; if (!x) { x = xi = 1; } else { x = x2 ^ d[d[d[x8 ^ x2]]]; xi ^= d[d[xi]]; } } }()); var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]; var AES = C_algo.AES = BlockCipher.extend({ _doReset: function () { if (this._nRounds \u0026amp;\u0026amp; this._keyPriorReset === this._key) { return; } var key = this._keyPriorReset = this._key; var keyWords = key.words; var keySize = key.sigBytes / 4; var nRounds = this._nRounds = keySize + 6; var ksRows = (nRounds + 1) * 4; var keySchedule = this._keySchedule = []; for (var ksRow = 0; ksRow \u0026lt; ksRows; ksRow++) { if (ksRow \u0026lt; keySize) { keySchedule[ksRow] = keyWords[ksRow]; } else { var t = keySchedule[ksRow - 1]; if (!(ksRow % keySize)) { t = (t \u0026lt;\u0026lt; 8) | (t \u0026gt;\u0026gt;\u0026gt; 24); t = (SBOX[t \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[t \u0026amp; 0xff]; t ^= RCON[(ksRow / keySize) | 0] \u0026lt;\u0026lt; 24; } else if (keySize \u0026gt; 6 \u0026amp;\u0026amp; ksRow % keySize == 4) { t = (SBOX[t \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(t \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[t \u0026amp; 0xff]; } keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t; } } var invKeySchedule = this._invKeySchedule = []; for (var invKsRow = 0; invKsRow \u0026lt; ksRows; invKsRow++) { var ksRow = ksRows - invKsRow; if (invKsRow % 4) { var t = keySchedule[ksRow]; } else { var t = keySchedule[ksRow - 4]; } if (invKsRow \u0026lt; 4 || ksRow \u0026lt;= 4) { invKeySchedule[invKsRow] = t; } else { invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t \u0026gt;\u0026gt;\u0026gt; 24]] ^ INV_SUB_MIX_1[SBOX[(t \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff]] ^ INV_SUB_MIX_2[SBOX[(t \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff]] ^ INV_SUB_MIX_3[SBOX[t \u0026amp; 0xff]]; } } }, encryptBlock: function (M, offset) { this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX); }, decryptBlock: function (M, offset) { var t = M[offset + 1]; M[offset + 1] = M[offset + 3]; M[offset + 3] = t; this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); var t = M[offset + 1]; M[offset + 1] = M[offset + 3]; M[offset + 3] = t; }, _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) { var nRounds = this._nRounds; var s0 = M[offset] ^ keySchedule[0]; var s1 = M[offset + 1] ^ keySchedule[1]; var s2 = M[offset + 2] ^ keySchedule[2]; var s3 = M[offset + 3] ^ keySchedule[3]; var ksRow = 4; for (var round = 1; round \u0026lt; nRounds; round++) { var t0 = SUB_MIX_0[s0 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s1 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s2 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s3 \u0026amp; 0xff] ^ keySchedule[ksRow++]; var t1 = SUB_MIX_0[s1 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s2 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s3 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s0 \u0026amp; 0xff] ^ keySchedule[ksRow++]; var t2 = SUB_MIX_0[s2 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s3 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s0 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s1 \u0026amp; 0xff] ^ keySchedule[ksRow++]; var t3 = SUB_MIX_0[s3 \u0026gt;\u0026gt;\u0026gt; 24] ^ SUB_MIX_1[(s0 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] ^ SUB_MIX_2[(s1 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] ^ SUB_MIX_3[s2 \u0026amp; 0xff] ^ keySchedule[ksRow++]; s0 = t0; s1 = t1; s2 = t2; s3 = t3; } var t0 = ((SBOX[s0 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s1 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s2 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s3 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; var t1 = ((SBOX[s1 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s2 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s3 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s0 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; var t2 = ((SBOX[s2 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s3 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s0 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s1 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; var t3 = ((SBOX[s3 \u0026gt;\u0026gt;\u0026gt; 24] \u0026lt;\u0026lt; 24) | (SBOX[(s0 \u0026gt;\u0026gt;\u0026gt; 16) \u0026amp; 0xff] \u0026lt;\u0026lt; 16) | (SBOX[(s1 \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; 0xff] \u0026lt;\u0026lt; 8) | SBOX[s2 \u0026amp; 0xff]) ^ keySchedule[ksRow++]; M[offset] = t0; M[offset + 1] = t1; M[offset + 2] = t2; M[offset + 3] = t3; }, keySize: 256 / 32 }); C.AES = BlockCipher._createHelper(AES); }()); var key = CryptoJS.enc.Hex.parse(\u0026#34;4587dc9b6a7c3e9ef3b920f994edc3a210c460977528138d41e58b9b02c94ffd\u0026#34;); var iv = CryptoJS.enc.Hex.parse(\u0026#34;6aa677d0f4d6646eec5e9a82aedb60b0\u0026#34;); function AES_Encrypt(word) { var srcs = CryptoJS.enc.Utf8.parse(word); var encrypted = CryptoJS.AES.encrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return CryptoJS.enc.Hex.stringify(CryptoJS.enc.Base64.parse(encrypted.toString())); } function AES_Decrypt(word) { var srcs = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Hex.parse(word)); var decrypt = CryptoJS.AES.decrypt(srcs, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 }); return decrypt.toString(CryptoJS.enc.Utf8); } function get_data(data){ return AES_Decrypt(data) } ","permalink":"https://waite.wang/posts/python/cawler-from-zhangshang-college-page/","summary":"\u003cblockquote\u003e\n\u003cp\u003e以下代码取的是院校专业分数线\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202309151459082.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202309151459082.png\" alt=\"_20221027212744\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eF12 得到接口\u003cbr\u003e\n\u003ca href=\"https://api.eol.cn/web/api/?local\"\u003ehttps://api.eol.cn/web/api/?local\u003c/a\u003e_batch_id=14\u0026amp;local_province_id=31\u0026amp;local_type_id=3\u0026amp;page=1\u0026amp;school_id=31\u0026amp;size=10\u0026amp;special_group=\u0026amp;uri=apidata/api/gk/score/special\u0026amp;year=2021\u0026amp;signsafe=6cdbc334a395abd2a99b9bd8cc29c42f\u003cbr\u003e\n\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202309151459515.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202309151459515.png\" alt=\"_20221027213021\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cp\u003e推断参数含义\n\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202309151459905.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202309151459905.png\" alt=\"_20221027213205\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"signsafe-数据加密签名获取\"\u003esignsafe 数据加密签名获取\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e搜索 锁定 signsafe 字段以及加密\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202309151459897.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202309151459897.png\" alt=\"image\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cp\u003e以上看到，t就是请求中的signsafe参数。而且，函数中也出现了HmacSHA1、base64等方法。由此可知，定位的加密位置是正确的。接下来需要将加密函数抠下来改写，方便调用。下断点继续跟踪方法调用。跟踪v.a.enc.Utf8.parse方法，如下多次尝试, 最终试出\u003c/p\u003e","title":"某高考平台逆向"},{"content":" 参考 https://answers.microsoft.com/zh-hans/windows/forum/all/win11%E6%97%A0%E6%B3%95%E6%8A%8A%E8%99%9A%E6%8B%9F/50381a46-ce77-40f5-8bde-a9d01b361e6c\n解决: WIN11无法把虚拟内存更改到其他盘，改完后重启显示由于启动页面文件配置的问题,然后虚拟内存又回c盘了\n分页文件更改 此电脑 -\u0026gt; 右键属性 -\u0026gt; 高级系统设置 选择高级 -\u0026gt; 性能(设置) -\u0026gt; 高级 -\u0026gt; 虚拟内存 -\u0026gt; 更改 取消勾选“自动管理所有驱动器的分页文件大小\u0026quot; C -\u0026gt; 无分页文件 -\u0026gt; 设置 D -\u0026gt; 自定义大小 -\u0026gt; 建议最小在 1.5 倍数以上 输入虚拟内存大小后请务在设置的虚拟内存大小右侧点击“设置”后再点击“确定”/“应用”，否则虚拟内存配量将不生效。 重启 提示以及解决方案 通过修该键值解决问题一般是因为当前开启了Bitlocker，所以对于虚拟内存的修改做出了一些限制。 解决此限制\nwin键+R， 输入：regedit 打开注册表编辑器 找到：HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager\\Memory Management 然后PagefileOnOsVolume和ExistingPageFiles，将PagefileOnOsVolume 的值由默认的1改为0，ExistingPageFiles里面的C:改为你要更换的盘符名。 ","permalink":"https://waite.wang/posts/win/modify-virtual-memory-to-other-disk/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考 \u003ca href=\"https://answers.microsoft.com/zh-hans/windows/forum/all/win11%E6%97%A0%E6%B3%95%E6%8A%8A%E8%99%9A%E6%8B%9F/50381a46-ce77-40f5-8bde-a9d01b361e6c\"\u003ehttps://answers.microsoft.com/zh-hans/windows/forum/all/win11%E6%97%A0%E6%B3%95%E6%8A%8A%E8%99%9A%E6%8B%9F/50381a46-ce77-40f5-8bde-a9d01b361e6c\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e解决: WIN11无法把虚拟内存更改到其他盘，改完后重启显示由于启动页面文件配置的问题,然后虚拟内存又回c盘了\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"分页文件更改\"\u003e分页文件更改\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e此电脑 -\u0026gt; 右键属性 -\u0026gt; 高级系统设置\u003c/li\u003e\n\u003cli\u003e选择高级 -\u0026gt; 性能(设置) -\u0026gt; 高级 -\u0026gt; 虚拟内存 -\u0026gt; 更改\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/20230903163805.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/20230903163805.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e","title":"Win11 改虚拟内存到C盘之外的盘"},{"content":"认识 Django 简介 Django(发音:[`dʒæŋɡəʊ]) 也有的小伙伴读成 “酱狗”，\u0026ldquo;贱狗\u0026rdquo;，\u0026ldquo;进狗\u0026rdquo;，\u0026ldquo;撞狗\u0026rdquo;，甚至还有读成\u0026quot;打 狗\u0026quot;。 官方：https://www.djangoproject.com/ Django是一个高级的Python Web框架，可以快速开发安全和可维护的网站。由经验丰富的开发者构 建，Django负责处理网站开发中麻烦的部分，可以专注于编写应用程序，而无需重新开发。它是免费和 开源的，有活跃繁荣的社区，丰富的文档，以及很多免费和付费的解决方案。目前最新版本：5.0.1\n安装 pip安装：\npip install Django==5.0.1 -i https://pypi.tuna.tsinghua.edu.cn/simple 执行安装完成后，在python目录的Scripts下，会多出一个diango-admin.exe 这个是django项目创建工具\n当然同时Lib下的site-packages下，也会有一个django目录，这个是后面我们开发项目会用到的django开发包。\n项目创建与项目配置 Django5创建项目用命令方式 通过以下命令可以查看版本号：\n## python3 -V Python 3.9.7 ## python3 -m django --version 4.2.7 django-admin startproject 项目名称 Django5创建项目用PyCharm工具 目录结构 使用 django-admin 来创建 HelloWorld 项目：\ndjango-admin startproject HelloWorld 创建完成后我们可以查看下项目的目录结构：\n$ cd HelloWorld/ $ tree . |-- HelloWorld | |-- __init__.py | |-- asgi.py | |-- settings.py | |-- urls.py | `-- wsgi.py `-- manage.py 目录说明：\nHelloWorld: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 HelloWorld/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 HelloWorld/asgi.py: 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。 HelloWorld/settings.py: 该 Django 项目的设置/配置。 HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站\u0026quot;目录\u0026quot;。 HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 接下来我们进入 HelloWorld 目录输入以下命令，启动服务器：\npython3 manage.py runserver 0.0.0.0:8000 0.0.0.0 让其它电脑可连接到开发服务器，8000 为端口号。如果不说明，那么端口号默认为 8000。\n在浏览器输入你服务器的 ip（这里我们输入本机 IP 地址： 127.0.0.1:8000） 及端口号，如果正常启动，输出结果如下：\n视图和 URL 配置 在先前创建的 HelloWorld 目录下的 HelloWorld 目录新建一个 views.py 文件，并输入代码：\nfrom django.http import HttpResponse def hello(request): return HttpResponse(\u0026#34;Hello world ! \u0026#34;) 接着，绑定 URL 与视图函数。打开 urls.py 文件，删除原来代码，将以下代码复制粘贴到 urls.py 文件中：\nfrom django.urls import path from . import views urlpatterns = [ path(\u0026#34;\u0026#34;, views.hello, name=\u0026#34;hello\u0026#34;), ] 整个目录结构如下：\n$ tree . |-- HelloWorld | |-- __init__.py | |-- __init__.pyc | |-- settings.py | |-- settings.pyc | |-- urls.py ## url 配置 | |-- urls.pyc | |-- views.py ## 添加的视图文件 | |-- views.pyc ## 编译后的视图文件 | |-- wsgi.py | `-- wsgi.pyc `-- manage.py 完成后，启动 Django 开发服务器，并在浏览器访问打开浏览器并访问：\n我们也可以修改以下规则：\n## HelloWorld/HelloWorld/urls.py 文件代码： from django.urls import path from . import views urlpatterns = [ path(\u0026#39;hello/\u0026#39;, views.hello), ] 通过浏览器打开 **http://127.0.0.1:8000/hello**，输出结果如下：\n**注意：**项目中如果代码有改动，服务器会自动监测代码的改动并自动重新载入，所以如果你已经启动了服务器则不需手动重启。\n创建app - 项目 - app，用户管理【表结构、函数、HTML模板、CSS】 - app，订单管理【表结构、函数、HTML模板、CSS】 - app，后台管理【表结构、函数、HTML模板、CSS】 - app，网站 【表结构、函数、HTML模板、CSS】 - app，API 【表结构、函数、HTML模板、CSS】 .. 注意：我们开发比较简洁，用不到多app，一般情况下，项目下创建1个app即可。 ├── app01 │ ├── __init__.py │ ├── admin.py 【固定，不用动】django默认提供了admin后台管理。 │ ├── apps.py 【固定，不用动】app启动类 │ ├── migrations 【固定，不用动】数据库变更记录 │ │ └── __init__.py │ ├── models.py 【**重要**】，对数据库操作。 │ ├── tests.py 【固定，不用动】单元测试 │ └── views.py 【**重要**】，函数。 ├── manage.py └── mysite2 ├── __init__.py ├── asgi.py ├── settings.py ├── urls.py 【URL-\u0026gt;函数】 └── wsgi.py Django 模板 我们接着上一章节的项目将在 HelloWorld 目录底下创建 templates 目录并建立hello.html文件，整个目录结构如下：\nHelloWorld/ |-- HelloWorld | |-- __init__.py | |-- __init__.pyc | |-- settings.py | |-- settings.pyc | |-- urls.py | |-- urls.pyc | |-- views.py | |-- views.pyc | |-- wsgi.py | `-- wsgi.pyc |-- manage.py `-- templates `-- hello.html \u0026lt;!-- hello.html --\u0026gt; \u0026lt;h1\u0026gt; {{ hello }} \u0026lt;/h1\u0026gt; 我们现在修改 views.py，增加一个新的对象，用于向模板提交数据：\n## views.py def hello_world(request): context = {\u0026#39;hello\u0026#39;: \u0026#39;Hello World11!\u0026#39;} return render(request, \u0026#39;hello.html\u0026#39;, context) ## urls from django.urls import path from . import views urlpatterns = [ path(\u0026#34;hello/\u0026#34;, views.hello_world, name=\u0026#34;hello_world\u0026#34;), ] Django 模板标签 变量 模板语法：\nview：｛\u0026#34;HTML变量名\u0026#34; : \u0026#34;views变量名\u0026#34;｝ HTML：｛｛变量名｝｝ ## views.py from django.shortcuts import render def runoob(request): views_name = \u0026#34;菜鸟教程\u0026#34; return render(request,\u0026#34;runoob.html\u0026#34;, {\u0026#34;name\u0026#34;:views_name}) templates 中的 runoob.html ：\n\u0026lt;p\u0026gt;{{ name }}\u0026lt;/p\u0026gt; 列表 from django.shortcuts import render def runoob(request): views_list = [\u0026#34;菜鸟教程1\u0026#34;,\u0026#34;菜鸟教程2\u0026#34;,\u0026#34;菜鸟教程3\u0026#34;] return render(request, \u0026#34;runoob.html\u0026#34;, {\u0026#34;views_list\u0026#34;: views_list}) \u0026lt;p\u0026gt;{{ views_list }}\u0026lt;/p\u0026gt; ## 取出整个列表 \u0026lt;p\u0026gt;{{ views_list.0 }}\u0026lt;/p\u0026gt; ## 取出列表的第一个元素 过滤器 模板语法：\n{{ 变量名 | 过滤器：可选参数 }} 模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示：\n{{ name|lower }} {{ name }} 变量被过滤器 lower 处理后，文档大写转换文本为小写。\n过滤管道可以被套接 ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：\n{{ my_list|first|upper }} 以上实例将第一个元素并将其转化为大写。\n有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：\n{{ bio|truncatewords:\u0026#34;30\u0026#34; }} 这个将显示变量 bio 的前30个词。\n其他过滤器：\naddslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。\ndate : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例：\n{{ pub_date|date:\u0026#34;F j, Y\u0026#34; }} length : 返回变量的长度。\ndefault\ndefault 为变量提供一个默认值。\n如果 views 传的变量的布尔值是 false，则使用指定的默认值。\n以下值为 false：\n0 0.0 False 0j \u0026#34;\u0026#34; [] () set() {} None from django.shortcuts import render def runoob(request): name =0 return render(request, \u0026#34;runoob.html\u0026#34;, {\u0026#34;name\u0026#34;: name}) {{ name|default:\u0026#34;菜鸟教程666\u0026#34; }} length\n返回对象的长度，适用于字符串和列表。\n字典返回的是键值对的数量，集合返回的是去重后的长度。\n{{ name|length}} filesizeformat\n以更易读的方式显示文件的大小（即'13 KB\u0026rsquo;, \u0026lsquo;4.1 MB\u0026rsquo;, \u0026lsquo;102 bytes\u0026rsquo;等）。\n字典返回的是键值对的数量，集合返回的是去重后的长度。\nfrom django.shortcuts import render def runoob(request): num=1024 return render(request, \u0026#34;runoob.html\u0026#34;, {\u0026#34;num\u0026#34;: num}) {{ num|filesizeformat}} date\n根据给定格式对一个日期变量进行格式化。\n格式 Y-m-d H:i:s返回 年-月-日 小时:分钟:秒 的格式时间。\nfrom django.shortcuts import render def runoob(request): import datetime now =datetime.datetime.now() return render(request, \u0026#34;runoob.html\u0026#34;, {\u0026#34;time\u0026#34;: now}) {{ time|date:\u0026#34;Y-m-d\u0026#34; }} truncatechars\n如果字符串包含的字符总个数多于指定的字符数量，那么会被截断掉后面的部分。\n截断的字符串将以 \u0026hellip; 结尾。\nfrom django.shortcuts import render def runoob(request): views_str = \u0026#34;菜鸟教程\u0026#34; return render(request, \u0026#34;runoob.html\u0026#34;, {\u0026#34;views_str\u0026#34;: views_str}) {{ views_str|truncatechars:2}} safe\n将字符串标记为安全，不需要转义。\n要保证 views.py 传过来的数据绝对安全，才能用 safe。\n和后端 views.py 的 mark_safe 效果相同。\nDjango 会自动对 views.py 传到HTML文件中的标签语法进行转义，令其语义失效。加 safe 过滤器是告诉 Django 该数据是安全的，不必对其进行转义，可以让该数据语义生效。\nfrom django.shortcuts import render def runoob(request): views_str = \u0026#34;\u0026lt;a href=\u0026#39;https://www.runoob.com/\u0026#39;\u0026gt;点击跳转\u0026lt;/a\u0026gt;\u0026#34; return render(request, \u0026#34;runoob.html\u0026#34;, {\u0026#34;views_str\u0026#34;: views_str}) {{ views_str|safe }} 对比\nif/else 标签 基本语法格式如下：\n{% if condition %} ... display {% endif %} 或者：\n{% if condition1 %} ... display 1 {% elif condition2 %} ... display 2 {% else %} ... display 3 {% endif %} 根据条件判断是否输出。if/else 支持嵌套。\n{% if %} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )，例如：\n{% if athlete_list and coach_list %} athletes 和 coaches 变量都是可用的。 {% endif %} for 标签 {% for %} 允许我们在一个序列上迭代。\n与 Python 的 for 语句的情形类似，循环语法是 for X in Y ，Y 是要迭代的序列而 X 是在每一个特定的循环中使用的变量名称。\n每一次循环中，模板系统会渲染在 {% for %} 和 {% endfor %} 之间的所有内容。\n例如，给定一个运动员列表 athlete_list 变量，我们可以使用下面的代码来显示这个列表：\n\u0026lt;ul\u0026gt; {% for athlete in athlete_list %} \u0026lt;li\u0026gt;{{ athlete.name }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; 给标签增加一个 reversed 使得该列表被反向迭代：\n{% for athlete in athlete_list reversed %} ... {% endfor %} 遍历字典: 可以直接用字典 .items 方法，用变量的解包分别获取键和值。\n在 {% for %} 标签里可以通过 {{forloop}} 变量获取循环序号。\nforloop.counter: 顺序获取循环序号，从 1 开始计算 forloop.counter0: 顺序获取循环序号，从 0 开始计算 forloop.revcounter: 倒序获取循环序号，结尾序号为 1 forloop.revcounter0: 倒序获取循环序号，结尾序号为 0 forloop.first（一般配合if标签使用）: 第一条数据返回 True，其他数据返回 False forloop.last（一般配合if标签使用）: 最后一条数据返回 True，其他数据返回 False 模块化 调整 djangoProject/urls.py\nfrom django.urls import path, include from app import views ## from . import views urlpatterns = [ path(\u0026#39;book/\u0026#39;, include(\u0026#34;app.urls\u0026#34;)), ] app/urls.py\nfrom django.urls import path from app import views urlpatterns = [ path(\u0026#34;home\u0026#34;, views.home, name=\u0026#34;home\u0026#34;), path(\u0026#34;add\u0026#34;, views.add_book, name=\u0026#34;add_book\u0026#34;), path(\u0026#34;query\u0026#34;, views.query_book, name=\u0026#34;query_book\u0026#34;), path(\u0026#34;delete\u0026#34;, views.delete_book, name=\u0026#34;delete_book\u0026#34;), path(\u0026#34;update\u0026#34;, views.update_book, name=\u0026#34;update_book\u0026#34;), ] 数据库操作 数据库配置 安装环境\npip install mysqlclient 更改 settings.py 中的配置\nDATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.mysql\u0026#39;, ## 数据库引擎 \u0026#39;NAME\u0026#39;: \u0026#39;runoob\u0026#39;, ## 数据库名称 \u0026#39;HOST\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, ## 数据库地址，本机 ip 地址 127.0.0.1 \u0026#39;PORT\u0026#39;: 3306, ## 端口 \u0026#39;USER\u0026#39;: \u0026#39;root\u0026#39;, ## 数据库用户名 \u0026#39;PASSWORD\u0026#39;: \u0026#39;123456\u0026#39;, ## 数据库密码 } } 数据库配置是选择项目所使用的数据库的类型，不同的数据库需要设置不同的数据库引擎，数据库引擎\n用于实现项目与数据库的连接，Django提供4种数据库引擎:\n\u0026lsquo;django.db.backends.postgresql\u0026rsquo; \u0026lsquo;django.db.backends.mysql\u0026rsquo; \u0026lsquo;django.db.backends.sqlite3\u0026rsquo; \u0026lsquo;django.db.backends.oracle\u0026rsquo; 我们有两种方式进行数据库的操作, 如下\n普通 SQL 增删查改 ## app/views from django.shortcuts import render from django.db import connection ## Create your views here. def home(request): ## 获取数据库连接 cursor = connection.cursor() ## 创建 book 表如果不存在 cursor.execute(\u0026#34;CREATE TABLE IF NOT EXISTS book (id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(255))\u0026#34;) ## 插入数据 cursor.execute(\u0026#34;INSERT INTO book (name) VALUES (\u0026#39;Python\u0026#39;)\u0026#34;) ## 查询数据 cursor.execute(\u0026#34;SELECT * FROM book\u0026#34;) ## 获取所有数据 books = cursor.fetchall() ## 更改数据 if books[0][1] == \u0026#39;Python\u0026#39;: cursor.execute(\u0026#34;UPDATE book SET name = \u0026#39;Java\u0026#39; WHERE id = 1\u0026#34;) else: cursor.execute(\u0026#34;UPDATE book SET name = \u0026#39;Python\u0026#39; WHERE id = 1\u0026#34;) ## 输出数据 for book in books: print(book) ## 关闭数据库连接 cursor.close() return render(request, \u0026#34;home.html\u0026#34;, {\u0026#34;books\u0026#34;: books}) ## 主项目/urls from django.urls import path from app import views urlpatterns = [ path(\u0026#34;home/\u0026#34;, views.home, name=\u0026#34;home\u0026#34;), ] \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {% for book in books %} \u0026lt;h1\u0026gt;{{ book}}\u0026lt;/h1\u0026gt; {% endfor %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下\nDjango ORM Django 模型使用自带的 ORM。\n对象关系映射（Object Relational Mapping，简称 ORM ）用于实现面向对象编程语言里不同类型系统的数据之间的转换。\nORM 在业务逻辑层和数据库层之间充当了桥梁的作用。\nORM 是通过使用描述对象和数据库之间的映射的元数据，将程序中的对象自动持久化到数据库中。\n使用 ORM 的好处：\n提高开发效率。 不同数据库可以平滑切换。 使用 ORM 的缺点：\nORM 代码转换为 SQL 语句时，需要花费一定的时间，执行效率会有所降低。 长期写 ORM 代码，会降低编写 SQL 语句的能力。 ORM 解析过程:\n1、ORM 会将 Python 代码转成为 SQL 语句。 2、SQL 语句通过 pymysql 传送到数据库服务端。 3、在数据库中执行 SQL 语句并将结果返回。 ORM 对应关系表：\n定义模型 Django 规定，如果要使用模型，必须要创建一个 app。我们使用以下命令创建一个 app 的 app:\ndjango-admin startapp app 创建一个新的 模块, 更改其中的 app.models\nfrom django.db import models ## Create your models here. class Book(models.Model): name = models.CharField(max_length=255) author = models.CharField(max_length=255) pub_time = models.DateField(auto_now_add=True) price = models.FloatField(default=0) 以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime）， max_length 参数限定长度。\n接下来在 settings.py 中找到INSTALLED_APPS这一项，如下：\nINSTALLED_APPS = ( \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, \u0026#39;app\u0026#39;, ## 添加此项 ) 在命令行中运行：\npython3 manage.py makemigrations ## 让 Django 知道我们在我们的模型有一些变更 python3 manage.py migrate ## 创建表结构 执行此命令, 也会把 django 自带的数据库导入进数据库中\n编辑 mysite/settings.py 文件前，先设置 TIME_ZONE 为你自己时区。\n此外，关注一下文件头部的 INSTALLED_APPS 设置项。这里包括了会在你项目中启用的所有 Django 应用。应用能在多个项目中使用，你也可以打包并且发布应用，让别人使用它们。\n通常， INSTALLED_APPS 默认包括了以下 Django 的自带应用：\ndjango.contrib.admin \u0026ndash; 管理员站点， 你很快就会使用它。 django.contrib.auth \u0026ndash; 认证授权系统。 django.contrib.contenttypes \u0026ndash; 内容类型框架。 django.contrib.sessions \u0026ndash; 会话框架。 django.contrib.messages \u0026ndash; 消息框架。 django.contrib.staticfiles \u0026ndash; 管理静态文件的框架。 这些应用被默认启用是为了给常规项目提供方便。\n默认开启的某些应用需要至少一个数据表，所以，在使用他们之前需要在数据库中创建一些表。请执行以下命令：\npython manage.py migrate 这个 migrate 命令查看 INSTALLED_APPS 配置，并根据 mysite/settings.py 文件中的数据库配置和随应用提供的数据库迁移文件（我们将在后面介绍这些），创建任何必要的数据库表。你会看到它应用的每一个迁移都有一个消息。如果你有兴趣，运行你的数据库的命令行客户端，输入 \\dt （PostgreSQL）， SHOW TABLES; （MariaDB，MySQL）， .tables （SQLite）或 SELECT TABLE_NAME FROM USER_TABLES; （Oracle）来显示 Django 创建的表。\n就像之前说的，为了方便大多数项目，我们默认激活了一些应用，但并不是每个人都需要它们。如果你不需要某个或某些应用，你可以在运行 migrate 前毫无顾虑地从 INSTALLED_APPS 里注释或者删除掉它们。 migrate 命令只会为在 INSTALLED_APPS 里声明了的应用进行数据库迁移。\n实现基本 CRUD 操作 数据库添加 def add_book(request): book = Book(name=\u0026#34;Python\u0026#34;, author=\u0026#34;菜鸟教程\u0026#34;, price=1024) book.save() ## books = Book.objects.create(name=\u0026#34;如来神掌\u0026#34;, price=200, author=\u0026#34;功夫出版社\u0026#34;, pub_time=\u0026#34;2010-10-10\u0026#34;) return HttpResponse(\u0026#34;添加数据成功！\u0026#34;) 数据库查询 以下可能不全 具体可以参看官方文档\n使用 all() 方法来查询所有内容。返回的是 QuerySet 类型数据，类似于 list，里面放的是一个个模型类的对象，可用索引下标取出模型类的对象。\nfilter() 方法用于查询符合条件的数据。返回的是 QuerySet 类型数据，类似于 list，里面放的是满足条件的模型类的对象，可用索引下标取出模型类的对象。pk=3 的意思是主键 primary key=3，相当于 id=3。因为 id 在 pycharm 里有特殊含义，是看内存地址的内置函数 id()，因此用 pk。\nexclude() 方法用于查询不符合条件的数据。返回的是 QuerySet 类型数据，类似于 list，里面放的是不满足条件的模型类的对象，可用索引下标取出模型类的对象。\nget() 方法用于查询符合条件的返回模型类的对象符合条件的对象只能为一个，如果符合筛选条件的对象超过了一个或者没有一个都会抛出错误。\norder_by() 方法用于对查询结果进行排序。返回的是 QuerySet类型数据，类似于list，里面放的是排序后的模型类的对象，可用索引下标取出模型类的对象。\n注意：\na、参数的字段名要加引号。 b、降序为在字段前面加个负号 -。 reverse() 方法用于对查询结果进行反转。返回的是 QuerySe t类型数据，类似于 list，里面放的是反转后的模型类的对象，可用索引下标取出模型类的对象。\ncount() 方法用于查询数据的数量返回的数据是整数。\nfirst() 方法返回第一条数据返回的数据是模型类的对象也可以用索引下标 [0]。\nlast() 方法返回最后一条数据返回的数据是模型类的对象不能用索引下标 [-1]，ORM 没有逆序索引。\nexists() 方法用于判断查询的结果 QuerySet 列表里是否有数据。返回的数据类型是布尔，有为 true，没有为 false。**注意：**判断的数据类型只能为 QuerySet 类型数据，不能为整型和模型类的对象。\nvalues() 方法用于查询部分字段的数据。返回的是 QuerySet 类型数据，类似于 list，里面不是模型类的对象，而是一个可迭代的字典序列，字典里的键是字段，值是数据。\n注意：\n参数的字段名要加引号 想要字段名和数据用 values实例 def query_book(request): books = Book.objects.all() ## books = Book.objects.filter(name=\u0026#34;Python\u0026#34;) for book in books: print(book.name) book_return = [ { \u0026#34;id\u0026#34;: book.id, \u0026#34;name\u0026#34;: book.name, \u0026#34;author\u0026#34;: book.author, \u0026#34;price\u0026#34;: book.price } for book in books ] return HttpResponse(\u0026#34;查询数据成功！\u0026#34; + str(book_return)) 删除 **方式一：**使用模型类的 对象.delete()。\n**返回值：**元组，第一个元素为受影响的行数。\nbooks=models.Book.objects.filter(pk=8).first().delete() 方式二：使用 QuerySet 类型数据.delete()(推荐)\n**返回值：**元组，第一个元素为受影响的行数。\nbooks=models.Book.objects.filter(pk__in=[1,2]).delete() def delete_book(request): ## 使用 QuerySet 类型数据.delete()(推荐) books = Book.objects.filter(pk__in=[1, 2]).delete() print(books) ## 使用模型类的 对象.delete()。 books = Book.objects.filter(name=\u0026#34;Python\u0026#34;).first().delete() print(books) return HttpResponse(\u0026#34;删除数据成功！\u0026#34;) 注意：\na. Django 删除数据时，会模仿 SQL约束 ON DELETE CASCADE 的行为，也就是删除一个对象时也会删除与它相关联的外键对象。 b. delete() 方法是 QuerySet 数据类型的方法，但并不适用于 Manager 本身。也就是想要删除所有数据，不能不写 all。 books=models.Book.objects.delete()　## 报错 books=models.Book.objects.all().delete()　## 删除成功 修改 方式一：\n模型类的对象.属性 = 更改的属性值 模型类的对象.save() **返回值：**编辑的模型类的对象。\ndef update_book(request): book = Book.objects.filter(name=\u0026#34;Python\u0026#34;).first() book.name = \u0026#34;Java\u0026#34; book.save() return HttpResponse(\u0026#34;更新数据成功！\u0026#34;) **方式二：**QuerySet 类型数据.update(字段名=更改的数据)（推荐）\n**返回值：**整数，受影响的行数\nBook.objects.filter(name=\u0026#34;Java\u0026#34;).update(price=100) 模型常用Field和参数 常用字段 在Django中，定义了一些Field来与数据库表中的字段类型来进行映射。以下将介绍那些常用的字段类\n型。\nAutoField：映射到数据库中是int类型，可以有自动增长的特性。一般不需要使用这个类型，如果不指定主键，那么模型会自动的生成一个叫做id的自动增长的主键。如果你想指定一个其他名字的并且具有自动增长的主键，使用AutoField也是可以的。\nBigAutoField：64 位的整形，类似于AutoField，只不过是产生的数据的范围是从1-9223372036854775807。\nBooleanField：在模型层面接收的是True/False。在数据库层面是tinyint类型。如果没有指定默认值，默认值是None。\nCharField：在数据库层面是varchar类型。在Python层面就是普通的字符串。这个类型在使用的时候必须要指定最大的长度，也即必须要传递max_length这个关键字参数进去。\nDateField：日期类型。在Python中是datetime.date类型，可以记录年月日。在映射到数据库中也是date类型。使用这个Field可以传递以下几个参数：\nauto_now：在每次这个数据保存的时候，都使用当前的时间。比如作为一个记录修改日期的字段，可以将这个属性设置为True。\nauto_now_add：在每次数据第一次被添加进去的时候，都使用当前的时间。比如作为一个记录第一次入库的字段，可以将这个属性设置为True。\nDateTimeField：日期时间类型，类似于DateField。不仅仅可以存储日期，还可以存储时间。映射到数据库中是datetime类型。这个Field也可以使用auto_now和auto_now_add两个属性。\nTimeField：时间类型。在数据库中是time类型。在Python中是datetime.time类型。\nEmailField：类似于CharField。在数据库底层也是一个varchar类型。最大长度是 254 个字符。\nFileField：用来存储文件的。这个请参考后面的文件上传章节部分。\nImageField：用来存储图片文件的。这个请参考后面的图片上传章节部分。\nFloatField：浮点类型。映射到数据库中是float类型。\nIntegerField：整形。值的区间是-2147483648——2147483647。\nBigIntegerField：大整形。值的区间是-9223372036854775808——9223372036854775807。\nPositiveIntegerField：正整形。值的区间是0——2147483647。\nSmallIntegerField：小整形。值的区间是-32768——32767。\nPositiveSmallIntegerField：正小整形。值的区间是0——32767。\nTextField：大量的文本类型。映射到数据库中是longtext类型。\nUUIDField：只能存储uuid格式的字符串。uuid是一个 32 位的全球唯一的字符串，一般用来作为主键。\nURLField：类似于CharField，只不过只能用来存储url格式的字符串。并且默认的max_length是 200 。\nField的常用参数 null：如果设置为True，Django将会在映射表的时候指定是否为空。默认是为False。在使用字符串相关的Field（CharField/TextField）的时候，官方推荐尽量不要使用这个参数，也就是保持默认值False。因为Django在处理字符串相关的Field的时候，即使这个Field的null=False，如果你没有给这个Field传递任何值，那么Django也会使用一个空的字符串\u0026quot;\u0026ldquo;来作为默认值存储进去。因此如果再使用null=True，Django会产生两种空值的情形（NULL或者空字符串）。如果想要在表单验证的时候允许这个字符串为空，那么建议使用blank=True。如果你的Field是BooleanField，那么对应的可空的字段则为NullBooleanField。\nblank：标识这个字段在表单验证的时候是否可以为空。默认是False。这个和null是有区别的，null是一个纯数据库级别的。而blank是表单验证级别的。\ndb_column：这个字段在数据库中的名字。如果没有设置这个参数，那么将会使用模型中属性的名字。\ndefault：默认值。可以为一个值，或者是一个函数，但是不支持lambda表达式。并且不支持列表/字典/集合等可变的数据结构。\nprimary_key：是否为主键。默认是False。\nunique：在表中这个字段的值是否唯一。一般是设置手机号码/邮箱等。\n更多Field参数请参考官方文档：https://docs.djangoproject.com/zh-hans/5.0/ref/models/fields/\n模型中 Meta 配置 db_table：这个模型映射到数据库中的表名。如果没有指定这个参数，那么在映射的时候将会使用模型名来作为默认的表名。 ordering：设置在提取数据的排序方式。后面章节会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序，那么示例代码如下： class Book(models.Model): name = models.CharField(max_length=20,null=False) desc = models.CharField(max_length=100,name=\u0026#39;description\u0026#39;,db_column=\u0026#34;description1\u0026#34;) pub_date = models.DateTimeField(auto_now_add=True) class Meta: db_table = \u0026#39;book_model\u0026#39; ordering = [\u0026#39;pub_date\u0026#39;] 更多的配置后面会慢慢介绍到。 官方文档：https://docs.djangoproject.com/zh-hans/5.0/ref/models/\n外键使用 在MySQL中，表有两种引擎，一种是InnoDB，另外一种是myisam。如果使用的是InnoDB引擎，是支持外键约束的。外键的存在使得ORM框架在处理表关系的时候异常的强大。因此这里我们首先来介绍下外键在Django中的使用。\nInnoDB: 事务支持：InnoDB支持事务处理，具有提交(commit)、回滚(rollback)和崩溃恢复能力，适合需要事务处理的应用。 行级锁定：InnoDB使用行级锁定和MVCC（多版本并发控制），在高并发环境下性能更好。 外键约束：InnoDB支持外键约束，有助于保持数据的完整性。 崩溃恢复：InnoDB具有崩溃恢复的能力，可以保证数据的安全性。 存储限制：InnoDB表有16TB的存储限制。 默认引擎：从MySQL 5.5.5版本开始，InnoDB成为了MySQL的默认存储引擎。 MyISAM: 表级锁定：MyISAM使用表级锁定，这意味着在高并发环境下，性能可能不如InnoDB。 全文索引：MyISAM提供了全文索引功能，适合需要全文搜索的应用。 没有事务支持：MyISAM不支持事务处理，适用于不需要事务的应用。 存储限制：MyISAM表有256TB的存储限制。 快速读取：MyISAM通常在读取密集型的应用中表现更好，因为它的索引结构设计得更简单。 选择哪种存储引擎取决于你的应用需求。如果需要事务支持、行级锁定和外键约束，InnoDB通常是更好的选择。如果应用主要是读取密集型，并且需要全文索引功能，那么MyISAM可能更合适。不过，由于InnoDB的广泛特性和性能优势，它在现代应用中被广泛使用。\n定义 类定义为 class ForeignKey(to,on_delete,**options) 。第一个参数是引用的是哪个模型，第二个参数是在使用外键引用的模型数据被删除了，这个字段该如何处理，比如有 CASCADE 、 SET_NULL 等。这里以一个实际案例来说明。比如有一个 User 和一个 Article 两个模型。一个 User 可以发表多篇文章，一个 Article 只能有一个 Author ，并且通过外键进行引用。那么相关的示例代码如下：\nfrom django.db import models class User(models.Model): username = models.CharField(max_length=255) password = models.CharField(max_length=255) class Article(models.Model): title = models.CharField(max_length=255) content = models.TextField() ## 外键 author = models.ForeignKey(\u0026#39;User\u0026#39;, on_delete=models.CASCADE) 如果不同的 app, 可以这样子使用外键 author = models.ForeignKey('app.User', on_delete=models.CASCADE)\n以上使用 ForeignKey 来定义模型之间的关系。即在 article 的实例中可以通过 author 属性来操作对应的 User 模型。这样使用起来非常的方便。示例代码如下：\nfrom django.shortcuts import HttpResponse from .models import User, Article def article_test(request): ## user = User(username=\u0026#34;admin\u0026#34;, password=\u0026#34;123456\u0026#34;) ## user.save() # ## article = Article(title=\u0026#34;Django\u0026#34;, content=\u0026#34;Django 是一个开放源代码的 Web 应用框架，由 Python 编写。\u0026#34;, author=user) ## article.save() article = Article.objects.first() return HttpResponse(article.author.username) 如果模型的外键引用的是本身自己这个模型，那么 to 参数可以为 \u0026lsquo;self\u0026rsquo; ，或者是这个模型的名字。在论坛开发中，一般评论都可以进行二级评论，即可以针对另外一个评论进行评论，那么在定义模型的时候就需要使用外键来引用自身。示例代码如下：\nclass Comment(models.Model): content = models.TextField() article = models.ForeignKey(\u0026#39;self\u0026#39;, on_delete=models.CASCADE, null=True) ## or article = models.ForeignKey(\u0026#39;Comment\u0026#39;, on_delete=models.CASCADE, null=True) 外键删除操作 在数据库中使用外键（Foreign Key）时，我们需要考虑当外键所引用的记录被删除时，应如何处理与该记录相关联的其他记录。Django ORM 提供了几种 on_delete 选项来处理这种情况，每种选项都定义了不同的行为。以下是这些选项的解释：\nCASCADE：当外键所引用的主键记录被删除时，所有引用该记录的外键记录也将被自动删除。这种操作称为级联删除，它确保了数据库的引用完整性。 PROTECT：当尝试删除一个被外键引用的主键记录时，如果存在引用，Django 会抛出一个 ProtectedError 异常，阻止删除操作。这是一种保护机制，确保数据的完整性不被破坏。 SET_NULL：如果外键所引用的主键记录被删除，那么所有引用该记录的外键字段将被设置为 NULL。使用这个选项之前，需要确保外键字段在数据库中允许为空（null=True）。 SET_DEFAULT：当外键所引用的主键记录被删除时，所有引用该记录的外键字段将被设置为字段的默认值。这要求外键字段在定义时有一个默认值。 SET()：允许你指定一个可调用的对象（如函数或方法），当外键所引用的主键记录被删除时，Django 会调用这个对象，并使用返回的值来更新外键字段。这提供了高度的灵活性，可以根据业务逻辑来决定如何更新外键字段。 DO_NOTHING：这个选项不会在 Django 层面上做任何操作，所有的约束都依赖于数据库级别的约束。如果数据库设置为不允许删除被引用的记录（如 RESTRICT），那么删除操作将会失败。 需要注意的是，尽管 Django 提供了多种 on_delete 选项，但数据库层面的行为不会改变。例如，如果数据库设置为 RESTRICT，则即使 Django 设置为 CASCADE，数据库也不会执行级联删除，而是会阻止删除操作。因此，在使用 on_delete 选项时，还需要考虑数据库层面的约束。\n表的关系 表与表之间的关系可分为以下三种：\n一对一: 一个人对应一个身份证号码，数据字段设置 unique。 一对多: 一个家庭有多个人，一般通过外键来实现。 多对多: 一个学生有多门课程，一个课程有很多学生，一般通过第三个表来实现关联。 一对多 应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。\n实现方式：一对多或者多对一，都是通过ForeignKey来实现的。还是以文章和作者的案例进行讲解。那么以后在给Article对象指定author，就可以使用以下代码来完成：\nfrom django.db import models class User(models.Model): username = models.CharField(max_length=255) password = models.CharField(max_length=255) class Article(models.Model): title = models.CharField(max_length=255) content = models.TextField() ## 外键 author = models.ForeignKey(\u0026#39;User\u0026#39;, on_delete=models.CASCADE) 并且以后如果想要获取某个用户下所有的文章，可以通过article_set来实现。示例代码如下：\ndef article_test(request): user = User.objects.first() ## ## user.save() ## # ## article = Article(title=\u0026#34;Django12\u0026#34;, content=\u0026#34;Django 是一个开放源代码的 Web 应用框架，由 Python 编写。\u0026#34;, author=user) ## article.save() article = user.article_set.all() for a in article: print(a.title) print(a.content) print(a.author.username) return HttpResponse(\u0026#34;添加数据成功！\u0026#34;) 一对一 应用场景：比如一个用户表和一个用户信息表。在实际网站中，可能需要保存用户的许多信息，但是有些信息是不经常用的。如果把所有信息都存放到一张表中可能会影响查询效率，因此可以把用户的一些不常用的信息存放到另外一张表中我们叫做UserExtension。但是用户表User和用户信息表UserExtension就是典型的一对一了。\n实现方式：Django为一对一提供了一个专门的Field叫做OneToOneField来实现一对一操作。示例代码如下：\nfrom django.db import models class User(models.Model): username = models.CharField(max_length=255) password = models.CharField(max_length=255) class UserExtension(models.Model): birthday = models.DateField(null=True) school = models.CharField(max_length=255) ## user = models.OneToOneField(\u0026#39;User\u0026#39;, on_delete=models.CASCADE, related_name=\u0026#39;extension\u0026#39;) user = models.OneToOneField(\u0026#39;User\u0026#39;, on_delete=models.CASCADE) 只允许一对一, 超过既会报错,\n在UserExtension模型上增加了一个一对一的关系映射。其实底层是在UserExtension这个表上增加了一个user_id，来和user表进行关联，并且这个外键数据在表中必须是唯一的，来保证一对一。\n多对多 应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。\n实现方式：Django为这种多对多的实现提供了专门的Field。叫做ManyToManyField。还是拿文章和标签为例进行讲解。示例代码如下：\nclass Article(models.Model): title = models.CharField(max_length=255) content = models.TextField() ## 外键 author = models.ForeignKey(\u0026#39;User\u0026#39;, on_delete=models.CASCADE) ## 多对多 tags = models.ManyToManyField(\u0026#39;Tag\u0026#39;) class Tag(models.Model): name = models.CharField(max_length=255) 在数据库层面，实际上Django是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到article和tag两张表的主键。\nrelated_name和related_query_name 在 Django 中，related_name 和 related_query_name 是两个与模型的外键关系相关的参数，它们允许你自定义反向关系和查询的名称。\nrelated_name related_name 是 ForeignKey 或 ManyToManyField 字段的一个选项，它允许你为反向关系指定一个自定义名称。默认情况下，Django 会使用 \u0026lt;模型名\u0026gt;_set 作为反向关系的名称（例如，Article 模型的反向关系默认为 article_set）。但是，如果你想要一个更有意义的名称或避免名称冲突，你可以使用 related_name 来指定。\n例如，如果你有一个 User 模型和一个 Article 模型，并且每个用户可以有多个文章，你可以这样定义模型：\nclass Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() ## 使用related_name指定反向关系名称为\u0026#39;articles\u0026#39; author = models.ForeignKey(\u0026#34;User\u0026#34;, on_delete=models.SET_NULL, null=True, related_name=\u0026#39;articles\u0026#39;) 这样，你就可以通过 user.articles.all() 来获取一个用户的所有文章。\n如果你不想使用任何自定义的反向关系名称，可以设置 related_name='+'，这将禁用自动生成的 \u0026lt;模型名\u0026gt;_set 名称。\nclass Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() ## 传递related_name参数，以后在方向引用的时候使用articles进行访问 author = models.ForeignKey(\u0026#34;User\u0026#34;,on_delete=models.SET_NULL,null=True,related_name=\u0026#39;+\u0026#39;) related_query_name related_query_name 是 related_name 的一个补充选项，它允许你自定义在查询集中使用 filter 方法时反向关系的名称。默认情况下，Django 会使用 related_name 的值加上下划线和字段名来生成查询名称（例如，articles_title）。\n如果你设置了 related_name='articles'，那么在进行反向查询时，你可以这样写：\nusers = User.objects.filter(articles__title=\u0026#39;abc\u0026#39;) 如果你想要一个不同的查询名称，可以使用 related_query_name 来指定：\nclass Article(models.Model): title = models.CharField(max_length=100) content = models.TextField() ## 使用related_name指定反向关系名称为\u0026#39;articles\u0026#39; ## 使用related_query_name指定查询时的名称为\u0026#39;article\u0026#39; author = models.ForeignKey(\u0026#34;User\u0026#34;, on_delete=models.SET_NULL, null=True, related_name=\u0026#39;articles\u0026#39;, related_query_name=\u0026#39;article\u0026#39;) 这样，你就可以使用 article__title 来进行查询：\nusers = User.objects.filter(article__title=\u0026#39;abc\u0026#39;) 请注意，related_query_name 只在反向查询中使用，而 related_name 用于定义反向关系名称。\n最后，你提供的代码片段中有一些格式错误和不完整的部分，我已经根据上下文进行了修正。如果你有更具体的问题或需要进一步的帮助，请随时提问。\n查询操作 查找是数据库操作中一个非常重要的技术。查询一般就是使用 filter 、 exclude 以及 get 三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在 ORM 层面，这些查询条件都是使用 field + __ + condition 的方式来使用的。以下将那些常用的查询条件来一一解释。\n在 Django 中，查询集（QuerySet）提供了多种方法来过滤和查询数据库中的数据。以下是对您提供的查询条件的优化格式和解释：\n1. exact 执行精确匹配，相当于 SQL 中的 = 操作符。如果查询值为 None，则在 SQL 中对应 IS NULL 示例:\narticle = Article.objects.get(id__exact=14) article = Article.objects.get(id__exact=None) SQL 翻译:\nSELECT ... FROM article WHERE id = 14; SELECT ... FROM article WHERE id IS NULL; 2. iexact 执行不区分大小写的模糊匹配，相当于 SQL 中的 LIKE 操作符。\n示例:\narticle = Article.objects.filter(title__iexact=\u0026#39;hello world\u0026#39;) SQL 翻译:\nSELECT ... FROM article WHERE title LIKE \u0026#39;hello world\u0026#39;; 3. contains 执行大小写敏感的模糊匹配，字段值包含给定的字符串。\n示例:\narticles = Article.objects.filter(title__contains=\u0026#39;hello\u0026#39;) SQL 翻译:\nSELECT ... WHERE title LIKE BINARY \u0026#39;%hello%\u0026#39;; 4. icontains 与 contains 类似，但不区分大小写。\n示例:\narticles = Article.objects.filter(title__icontains=\u0026#39;hello\u0026#39;) SQL 翻译:\nSELECT ... WHERE title LIKE \u0026#39;%hello%\u0026#39;; 5. in 检查字段值是否包含在给定的容器中，容器可以是列表、元组或任何可迭代对象。\n示例:\narticles = Article.objects.filter(id__in=[1, 2, 3]) SQL 翻译:\nSELECT ... WHERE id IN (1, 2, 3); 6. gt 检查字段值是否大于给定值。\n示例:\narticles = Article.objects.filter(id__gt=4) SQL 翻译:\nSELECT ... WHERE id \u0026gt; 4; 7. gte 检查字段值是否大于或等于给定值。\n8. lt 检查字段值是否小于给定值。\n9. lte 检查字段值是否小于或等于给定值。\n10. startswith 检查字段值是否以特定字符串开始，大小写敏感。\n示例:\narticles = Article.objects.filter(title__startswith=\u0026#39;hello\u0026#39;) SQL 翻译:\nSELECT ... WHERE title LIKE \u0026#39;hello%\u0026#39;; 11. istartswith 与 startswith 类似，但不区分大小写。\n12. endswith 检查字段值是否以特定字符串结束，大小写敏感。\n示例:\narticles = Article.objects.filter(title__endswith=\u0026#39;world\u0026#39;) SQL 翻译:\nSELECT ... WHERE title LIKE \u0026#39;%world\u0026#39;; 13. iendswith 与 endswith 类似，但不区分大小写。\n14. range 检查字段值是否在给定的范围内。\n示例:\nstart_date = datetime(2018, 1, 1) end_date = datetime(2018, 12, 31) articles = Article.objects.filter(pub_date__range=(start_date, end_date)) SQL 翻译:\nSELECT ... FROM article WHERE pub_date BETWEEN \u0026#39;2018-01-01\u0026#39; AND \u0026#39;2018-12-31\u0026#39;; 15. date 针对 DateField 或 DateTimeField 类型的字段，可以指定日期的范围。\n示例:\narticles = Article.objects.filter(pub_date__date=date(2018, 3, 29)) SQL 翻译:\nSELECT ... WHERE DATE(pub_date) = \u0026#39;2018-03-29\u0026#39;; 16. year、month、day、week_day、time 这些查询条件允许你根据日期和时间的特定部分进行过滤。\n示例:\narticles = Article.objects.filter(pub_date__year=2018) articles = Article.objects.filter(pub_date__time=datetime.time(12, 12, 12)) SQL 翻译:\nSELECT ... WHERE YEAR(pub_date) = 2018; SELECT ... WHERE TIME(pub_date) = \u0026#39;12:12:12\u0026#39;; 这些查询条件使得在 Django 中进行数据库查询变得非常灵活和强大。你可以根据需要选择合适的查询条件来获取所需的数据。更多详细信息和高级用法，请参考 Django 官方文档。\n聚合函数 前期准备\nfrom django.db import models class Author(models.Model): \u0026#34;\u0026#34;\u0026#34;作者模型\u0026#34;\u0026#34;\u0026#34; name = models.CharField(max_length=100) age = models.IntegerField() email = models.EmailField() class Meta: db_table = \u0026#39;front_author\u0026#39; class Publisher(models.Model): \u0026#34;\u0026#34;\u0026#34;出版社模型\u0026#34;\u0026#34;\u0026#34; name = models.CharField(max_length=300) class Meta: db_table = \u0026#39;front_publisher\u0026#39; class Book(models.Model): \u0026#34;\u0026#34;\u0026#34;图书模型\u0026#34;\u0026#34;\u0026#34; name = models.CharField(max_length=300) pages = models.IntegerField() price = models.FloatField() rating = models.FloatField() author = models.ForeignKey(Author, on_delete=models.CASCADE) publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE) class Meta: db_table = \u0026#39;front_book\u0026#39; class BookOrder(models.Model): \u0026#34;\u0026#34;\u0026#34;图书订单模型\u0026#34;\u0026#34;\u0026#34; book = models.ForeignKey(\u0026#34;Book\u0026#34;, on_delete=models.CASCADE) price = models.FloatField() class Meta: db_table = \u0026#39;front_book_order\u0026#39; /* Navicat MySQL Data Transfer Source Server : zhiliao Source Server Version : 50718 Source Host : localhost:3306 Source Database : orm_aggregate_demo2 Target Server Type : MYSQL Target Server Version : 50718 File Encoding : 65001 */ SET FOREIGN_KEY_CHECKS=0; -- ---------------------------- -- Records of author -- ---------------------------- INSERT INTO `front_author` VALUES (1, \u0026#39;曹雪芹\u0026#39;, \u0026#39;35\u0026#39;, \u0026#39;cxq@qq.com\u0026#39;); INSERT INTO `front_author` VALUES (2, \u0026#39;吴承恩\u0026#39;, \u0026#39;28\u0026#39;, \u0026#39;wce@qq.com\u0026#39;); INSERT INTO `front_author` VALUES (3, \u0026#39;罗贯中\u0026#39;, \u0026#39;36\u0026#39;, \u0026#39;lgz@qq.com\u0026#39;); INSERT INTO `front_author` VALUES (4, \u0026#39;施耐庵\u0026#39;, \u0026#39;46\u0026#39;, \u0026#39;sna@qq.com\u0026#39;); -- ---------------------------- -- Records of book -- ---------------------------- INSERT INTO `front_book` VALUES (\u0026#39;1\u0026#39;, \u0026#39;三国演义\u0026#39;, \u0026#39;987\u0026#39;, \u0026#39;98\u0026#39;, \u0026#39;4.8\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO `front_book` VALUES (\u0026#39;2\u0026#39;, \u0026#39;水浒传\u0026#39;, \u0026#39;967\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;4.83\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO `front_book` VALUES (\u0026#39;3\u0026#39;, \u0026#39;西游记\u0026#39;, \u0026#39;1004\u0026#39;, \u0026#39;95\u0026#39;, \u0026#39;4.85\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;2\u0026#39;); INSERT INTO `front_book` VALUES (\u0026#39;4\u0026#39;, \u0026#39;红楼梦\u0026#39;, \u0026#39;1007\u0026#39;, \u0026#39;99\u0026#39;, \u0026#39;4.9\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;); -- ---------------------------- -- Records of book_order -- ---------------------------- INSERT INTO `front_book_order` VALUES (\u0026#39;1\u0026#39;, \u0026#39;95\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO `front_book_order` VALUES (\u0026#39;2\u0026#39;, \u0026#39;85\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO `front_book_order` VALUES (\u0026#39;3\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;1\u0026#39;); INSERT INTO `front_book_order` VALUES (\u0026#39;4\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;2\u0026#39;); INSERT INTO `front_book_order` VALUES (\u0026#39;5\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;2\u0026#39;); -- ---------------------------- -- Records of publisher -- ---------------------------- INSERT INTO `front_publisher` VALUES (\u0026#39;1\u0026#39;, \u0026#39;中国邮电出版社\u0026#39;); INSERT INTO `front_publisher` VALUES (\u0026#39;2\u0026#39;, \u0026#39;清华大学出版社\u0026#39;); 聚合查询 聚合查询函数是对一组值执行计算，并返回单个值。Django 使用聚合查询前要先从 django.db.models 引入 Avg、Max、Min、Count、Sum（首字母大写）。\nfrom .models import Book from django.db.models import Avg, Max, Min, Count, Sum def test(request): ## 查询所有图书的平均价格 avg_price = Book.objects.aggregate(Avg(\u0026#39;price\u0026#39;)) print(avg_price) ## 查询所有图书的最高价格 max_price = Book.objects.aggregate(Max(\u0026#39;price\u0026#39;)) print(max_price) ## 查询所有图书的最低价格 min_price = Book.objects.aggregate(Min(\u0026#39;price\u0026#39;)) print(min_price) ## 查询所有图书的价格之和 sum_price = Book.objects.aggregate(Sum(\u0026#39;price\u0026#39;)) print(sum_price) ## 查询所有图书的数量 count = Book.objects.aggregate(Count(\u0026#39;id\u0026#39;)) print(count) return HttpResponse(\u0026#34;查询数据成功！\u0026#34;) aggregate() 示例 假设我们想要计算所有书籍的平均价格。\nfrom django.db.models import Avg from .models import Book ## 使用 aggregate() 方法来计算书籍的平均价格 average_price = Book.objects.aggregate(average=Avg(\u0026#39;price\u0026#39;)) ## average_price 是一个字典，包含键 \u0026#39;average\u0026#39;，其值为平均价格 print(average_price) ## 输出: {\u0026#39;average\u0026#39;: 25.5} 假设平均价格为25.5 annotate() 示例 假设我们想要为每个出版社添加一个字段，表示该出版社出版的所有书籍的平均价格。\nfrom django.db.models import Avg from .models import Publisher, Book ## 使用 annotate() 方法为每个出版社添加一个平均价格字段 publishers_with_average_price = Publisher.objects.annotate(average_price=Avg(\u0026#39;book__price\u0026#39;)) ## 现在 publishers_with_average_price 是一个查询集，我们可以通过迭代来查看每个出版社及其平均价格 for publisher in publishers_with_average_price: print(f\u0026#34;{publisher.name}: Average Book Price = {publisher.average_price}\u0026#34;) 在这个例子中，annotate() 方法为 Publisher 查询集中的每个出版社对象添加了一个 average_price 属性，表示该出版社出版的所有书籍的平均价格。\naggregate() 返回一个字典，其中包含了聚合函数的结果，适用于计算总和、平均值、最大值、最小值等聚合数据。 annotate() 返回一个查询集，其中的每个对象都添加了聚合字段，适用于为查询集中的每个对象添加聚合数据相关的字段。 这两个方法都使用 Django 的聚合函数，如 Sum、Avg、Max、Min 等，但是它们的使用场景和返回结果不同。aggregate() 用于获取单个或多个聚合值，而 annotate() 用于扩展查询集中每个对象的属性。\nF 表达式 以及 Q表达式 F 表达式 F 表达式（Field expressions）允许你引用模型字段，并在数据库层面上执行操作，而不是在 Python 层面上。这意味着你可以在查询中使用字段的当前值，而无需在 Python 中加载整个对象。\n使用场景:\n当你想基于现有字段的值进行计算或条件判断时。 当你想避免在 Python 层面上加载对象，从而提高查询效率时。 示例: 假设我们有一个 Book 模型，我们想要更新所有书籍的价格，使其变为当前价格的两倍。\nfrom .models import Book Book.objects.update(price=F(\u0026#39;price\u0026#39;) * 2) 在这个例子中，我们没有首先加载所有的 Book 对象到 Python 中，而是直接在数据库层面上将 price 字段的值乘以 2。\nQ 表达式 Q 表达式（Query expressions）提供了一种查询接口，允许你构建复杂的查询，可以包含多个条件，并且这些条件可以使用 \u0026amp;（和）、|（或）和 ~（非）运算符来组合。\n使用场景:\n当你想构建包含多个条件的复杂查询时。 当你想使用逻辑运算符组合查询条件时。 示例: 假设我们想要查询所有由特定作者编写，并且价格大于 10 的书籍。\nfrom .models import Book from django.db.models import Q query = Q(author__name=\u0026#39;John Doe\u0026#39;) \u0026amp; Q(price__gt=10) books = Book.objects.filter(query) 在这个例子中，我们创建了一个 Q 对象，它表示作者是 \u0026ldquo;John Doe\u0026rdquo; 并且价格大于 10 的书籍。然后我们使用 filter() 方法来获取匹配这些条件的书籍。\nF 表达式 用于引用模型字段并在数据库层面上执行操作，如字段值的计算。 Q 表达式 用于构建复杂的查询，可以包含多个逻辑条件，并使用逻辑运算符进行组合。 F 表达式和 Q 表达式都是 Django ORM 中不可或缺的工具，它们可以帮助你编写更高效、更灵活的数据库查询。\nCookie 和 Session 操作 Cookie和Session简介 1. Cookie Cookies用于解决HTTP协议无状态的问题。当用户登录成功后，服务器会返回一些数据（cookie）给浏览器，浏览器将其保存。随后的请求中，浏览器自动携带cookie，服务器通过这些数据识别用户。\n限制: Cookie的数据量有限，通常不超过4KB，因此只能存储少量数据。 2. Session Session用于存储用户信息，与Cookie类似但更安全，因为数据存储在服务器端。不同服务器和框架有不同的实现方式。\n3. 使用场景 Server Side Session: 通过cookie存储session ID，数据存储在服务器的session中。 Client Side Session: Session数据加密后存储在cookie中。 Django中操作Cookie 设置Cookie 使用response.set_cookie方法，参数包括：\nkey: Cookie的键名。 value: Cookie的值。 max_age: 生命周期（秒）。 expires: 过期日期。 path: 有效的路径。 domain: 有效的域名。 secure: 是否仅在HTTPS下有效。 httponly: 是否禁止客户端脚本访问。 删除Cookie 使用delete_cookie，将cookie的值设置为空字符串，并设置过期时间为0。\n获取Cookie 通过request.COOKIES获取，这是一个字典类型对象。\nDjango中操作Session Django的session默认存储在数据库中，通过session ID与cookie交互。操作session使用request.session，包括：\nget: 获取值。 pop: 删除值。 keys: 获取所有键。 items: 获取所有项。 clear: 清除session数据。 flush: 删除session及cookie中的session ID。 set_expiry: 设置过期时间。 clear_expired: 清理过期session。 示例代码：\n# 获取所有cookie cookies = request.COOKIES for cookie_key, cookie_value in cookies.items(): print(cookie_key, cookie_value) # 使用session def index(request): username = request.session.get(\u0026#39;username\u0026#39;) return HttpResponse(\u0026#39;index\u0026#39;) 修改Session的存储机制 Django默认将Session数据存储在数据库中。但您可以通过设置SESSION_ENGINE来更改Session的存储位置。以下是几种可选的存储方案：\n数据库存储 (django.contrib.sessions.backends.db): 默认方案，Session数据存储在数据库中。 文件存储 (django.contrib.sessions.backends.file): Session数据存储在服务器的文件系统中。 缓存存储 (django.contrib.sessions.backends.cache): 将Session数据存储在缓存中，如Memcached。 需要在settings.py中配置CACHES。 缓存数据库混合存储 (django.contrib.sessions.backends.cached_db): 首先将Session数据存储在缓存中，然后同步到数据库。 即使缓存系统出现问题，Session数据也不会丢失。 加密Cookie存储 (django.contrib.sessions.backends.signed_cookies): 将Session信息加密后存储在浏览器的Cookie中。 需要考虑安全性，建议设置SESSION_COOKIE_HTTPONLY=True以防止通过JavaScript操作Session数据。 保护settings.py中的SECRET_KEY，防止解密Session数据。 Cookie中存储的数据量不能超过4KB。 请注意，选择存储方案时，需要根据您的应用需求和安全要求来决定最合适的方法。\n","permalink":"https://waite.wang/posts/python/learn-django-1/","summary":"\u003ch2 id=\"认识-django\"\u003e认识 Django\u003c/h2\u003e\n\u003ch3 id=\"简介\"\u003e简介\u003c/h3\u003e\n\u003cp\u003eDjango(发音:[`dʒæŋɡəʊ]) 也有的小伙伴读成 “酱狗”，\u0026ldquo;贱狗\u0026rdquo;，\u0026ldquo;进狗\u0026rdquo;，\u0026ldquo;撞狗\u0026rdquo;，甚至还有读成\u0026quot;打\n狗\u0026quot;。\n官方：\u003ca href=\"https://www.djangoproject.com/\"\u003ehttps://www.djangoproject.com/\u003c/a\u003e\nDjango是一个高级的Python Web框架，可以快速开发安全和可维护的网站。由经验丰富的开发者构\n建，Django负责处理网站开发中麻烦的部分，可以专注于编写应用程序，而无需重新开发。它是免费和\n开源的，有活跃繁荣的社区，丰富的文档，以及很多免费和付费的解决方案。目前最新版本：5.0.1\u003c/p\u003e","title":"初识 Django"},{"content":"安装 MinGW MinGW（Minimalist GNU for Windows）, 是一个适用于微软windows应用程序的极简洁的开发环境。MinGW提供了一个完整的开源编程工具集，适用于原生MS-Windows应用程序的开发，并且不依赖于任何第三方C运行时DLL。MinGW主要供在MS-Windows平台上工作的开发人员使用，但也可跨平台使用。\n安装 https://sourceforge.net/projects/mingw-w64/files/ 解压 配置 环境变量 到 bin 目录 验证 gcc -v 查看版本号\n新建文件 test.c\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello world\\n\u0026#34;); return 0; } gcc test.c -o test\ntest.exe\nVsCode 配置 插件安装 C/C++\nCode Runner\n设置 code runner 右键 扩展设置 勾选以下 打开项目 在打开的文件夹中新建一个名为“.vscode”的子文件夹\n选中“.vscode”子文件夹，新增三个配置文件”c_cpp_propertise.json“、”launch.json“、”tasks.json“\n以下 C:/mingw64/ 替换为 自己路径\nc_cpp_propertise.json\n{ \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Win32\u0026#34;, \u0026#34;includePath\u0026#34;: [ \u0026#34;${workspaceRoot}\u0026#34;, \u0026#34;C:/mingw64/include/**\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include\u0026#34; ], \u0026#34;defines\u0026#34;: [ \u0026#34;_DEBUG\u0026#34;, \u0026#34;UNICODE\u0026#34;, \u0026#34;__GNUC__=6\u0026#34;, \u0026#34;__cdecl=__attribute__((__cdecl__))\u0026#34; ], \u0026#34;intelliSenseMode\u0026#34;: \u0026#34;msvc-x64\u0026#34;, \u0026#34;browse\u0026#34;: { \u0026#34;limitSymbolsToIncludedHeaders\u0026#34;: true, \u0026#34;databaseFilename\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: [ \u0026#34;${workspaceRoot}\u0026#34;, \u0026#34;C:/mingw64/include/**\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed\u0026#34;, \u0026#34;C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include\u0026#34; ] } } ], \u0026#34;version\u0026#34;: 4 } launch.json { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(gdb) Launch\u0026#34;, // 配置名称，将会在启动配置的下拉菜单中显示 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, // 配置类型，这里只能为cppdbg \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, //请求配置类型，可以为launch（启动）或attach（附加） \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/${fileBasenameNoExtension}.exe\u0026#34;, // 将要进行调试的程序的路径 \u0026#34;args\u0026#34;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \u0026#34;stopAtEntry\u0026#34;: false, // 设为true时程序将暂停在程序入口处，一般设置为false \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, // 调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录workspaceRoot已被弃用，现改为workspaceFolder \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;C:/mingw64/bin/gdb.exe\u0026#34;, // miDebugger的路径，注意这里要与MinGw的路径对应 \u0026#34;preLaunchTask\u0026#34;: \u0026#34;gcc\u0026#34;, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: false } ] } ] } tasks.json { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;gcc\u0026#34;, // 注意对应 \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileBasenameNoExtension}.exe\u0026#34; ], // 编译命令参数 \u0026#34;problemMatcher\u0026#34;: { \u0026#34;owner\u0026#34;: \u0026#34;cpp\u0026#34;, \u0026#34;fileLocation\u0026#34;: [ \u0026#34;relative\u0026#34;, \u0026#34;${workspaceFolder}\u0026#34; ], \u0026#34;pattern\u0026#34;: { \u0026#34;regexp\u0026#34;: \u0026#34;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\u0026#34;, \u0026#34;file\u0026#34;: 1, \u0026#34;line\u0026#34;: 2, \u0026#34;column\u0026#34;: 3, \u0026#34;severity\u0026#34;: 4, \u0026#34;message\u0026#34;: 5 } } } 运行 新建 hello.c #include \u0026lt;stdio.h\u0026gt; int main(void){ printf(\u0026#34;hello world! I\\\u0026#39; m VSCode\\n\u0026#34;); return 0; } 右键 Run Code ","permalink":"https://waite.wang/posts/win/gcc-install-and-use-in-vscode/","summary":"\u003ch2 id=\"安装-mingw\"\u003e安装 MinGW\u003c/h2\u003e\n\u003cp\u003eMinGW（Minimalist GNU for Windows）, 是一个适用于微软windows应用程序的极简洁的开发环境。MinGW提供了一个完整的开源编程工具集，适用于原生MS-Windows应用程序的开发，并且不依赖于任何第三方C运行时DLL。MinGW主要供在MS-Windows平台上工作的开发人员使用，但也可跨平台使用。\u003c/p\u003e","title":"gcc 安装 + vscode 搭建"},{"content":"什么是 TypeScript TypeScript既是一种语言又是一组工具。TypeScript是JavaScript的一个超集。换句话说，TypeScript是JavaScript加上一些额外的功能。\nTypeScript 扩展了 JavaScript 的语法，所以任何现有的 JavaScript 程序可以不加改变的在 TypeScript 下工作。TypeScript 是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。\nTypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的 JavaScript 引擎中。\nTypeScript的组成部分 语言 - 它包括语法，关键字和类型注释。\n编译器 - TypeScript编译器（TSC）将使用TypeScript编写的指令转换为其等效的JavaScript。\n语言服务 - “TypeScript语言服务”在核心编译管道周围公开了一个额外的层，它是类似编辑器的应用程序。语言服务支持常见的编辑器操作集，如语句完成，签名帮助，代码格式化和大纲，着色等。\nTypescript 官网地址: https://www.typescriptlang.org/zh/\n使用 nvm 来管理 node 版本: https://github.com/nvm-sh/nvm\n安装 Typescript: npm install -g typescript 使用 tsc 全局命令：\n// 查看 tsc 版本 tsc -v // 编译 ts 文件 tsc fileName.ts // 使用 tsc -v 查看是否安装成功, 若成功返回 typescript 版本号 // 链接失败使用淘宝镜像 npm config set registry https://registry.npm.taobao.org TypeScript 转 JavaScript cmd 到文件目录 tsc 文件名.ts WebStorm 中自动转换, 勾选 Recompile on change, Webstorm 中勾选如下 类型声明 Boolean、Number let val2:boolean; val2 = true; // val2 = 1; // 会报错 console.log(val2); let val1:number; // 定义了一个名称叫做val1的变量, 这个变量中将来只能存储数值类型的数据 val1 = 123; // val1 = \u0026#34;123\u0026#34;; // 会报错 console.log(val1); String 多行字符串 let hello: string = `Welcome to W3cschool`; // 类似于 \u0026#34;Welcome to \\nW3cschool\u0026#34;; 内嵌表达式 let name: string = `Loen`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I\u0026#39;ll be ${ age + 1 } years old next month.`; // 类似于 \u0026#34;Hello, my name is \u0026#34; + name + \u0026#34;.\\nI\u0026#39;ll be \u0026#34; + (age + 1) + \u0026#34; years old next month.\u0026#34;; // 和 format 性质差不多 自动拆分字符串 function userinfo(params,name,age){ console.log(params); console.log(name); console.log(age); } let myname = \u0026#34;Loen Wang\u0026#34;; let getAge = function(){ return 18; } // 调用 userinfo`hello my name is ${myname}, i\u0026#39;m ${getAge()}` 数组和元祖 数组数据类型一致 Array \u0026lt; number \u0026gt; // 需求: 要求定义一个数组, 这个数组中将来只能存储数值类型的数据 let arr1: Array\u0026lt;number\u0026gt;; // 表示定义了一个名称叫做arr1的数组, 这个数组中将来只能够存储数值类型的数据 arr1 = [1, 3, 5]; // arr1 = [\u0026#39;a\u0026#39;, 3, 5]; // 报错 console.log(arr1); string[ ] // 需求: 要求定义一个数组, 这个数组中将来只能存储字符串类型的数据 let arr2:string[]; // 表示定义了一个名称叫做arr2的数组, 这个数组中将来只能够存储字符串类型的数据 arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; // arr2 = [1, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; // 报错 console.log(arr2); 数组数据类型不一致 联合类型声明数组 (number | string)[ ]\nlet arr3:(number | string)[]; // 表示定义了一个名称叫做arr3的数组, 这个数组中将来既可以存储数值类型的数据, 也可以存储字符串类型的数据 arr3 = [1, \u0026#39;b\u0026#39;, 2, \u0026#39;c\u0026#39;]; // arr3 = [1, \u0026#39;b\u0026#39;, 2, \u0026#39;c\u0026#39;, false]; // 报错 console.log(arr3); 自由任意类型元素的数组 如果不希望类型检查器对值进行检查,直接通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量 let notSure: any = 4; notSure = \u0026#34;这是一个字符串\u0026#34;; notSure = false; // 现在我们又可以将其改成布尔类型 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let arr4:any[]; // 表示定义了一个名称叫做arr4的数组, 这个数组中将来可以存储任意类型的数据 arr4 = [1, \u0026#39;b\u0026#39;, false]; console.log(arr4); 严格限制类型和长度的元祖数组 {% note blue \u0026rsquo;\u0026rsquo; flat %}\nTS中的元祖类型其实就是数组类型的扩展,元祖用于保存定长定数据类型的数据\n{% endnote %}\nlet arr5:[string, number, boolean]; // 表示定义了一个名称叫做arr5的元祖, 这个元祖中将来可以存储3个元素, 第一个元素必须是字符串类型, 第二个元素必须是数字类型, 第三个元素必须是布尔类型 arr5 = [\u0026#39;a\u0026#39;, 1, true]; // arr5 = [\u0026#39;a\u0026#39;, 1, true, false]; // 超过指定的长度会报错 arr5 = [\u0026#39;a\u0026#39;, 1, true]; console.log(arr5); enum枚举 枚举用于表示固定的几个取值,例如: 一年只有四季、人的性别只能是男或者女。 枚举类型是TS为JS扩展的一种类型, 在原生的JS中是没有枚举类型的。\nenum Color {Red, Green, Blue} let c: Color = Color.Green; // 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值 // tips: enum Color {Red = 1, Green, Blue} let c: Color = Color.Green; // 或者 enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; /* 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字， 我们可以查找相应的名字： */ enum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; alert(colorName); // 显示\u0026#39;Green\u0026#39;因为上面代码里它的值是2 Any、Void any表示任意类型, 当我们不清楚某个值的具体类型的时候我们就可以使用any，任何数据类型的值都可以赋值给any类型, 一般用于定义一些通用性比较强的变量, 或者用于保存从其它框架中获取的不确定类型的值\nlet value:any; // 定义了一个可以保存任意类型数据的变量 value = 123; value = \u0026#34;abc\u0026#34;; value = true; value = [1, 3, 5]; void与any正好相反, 表示没有任何类型, 一般用于函数返回值。在TS中只有null和undefined可以赋值给void类型\nfunction test():void { console.log(\u0026#34;hello world\u0026#34;); } test(); let value:void; // 定义了一个不可以保存任意类型数据的变量, 只能保存null和undefined // value = 123; // 报错 // value = \u0026#34;abc\u0026#34;;// 报错 // value = true;// 报错 // 注意点: null和undefined是所有类型的子类型, 所以我们可以将null和undefined赋值给任意类型 // value = null; // 不会报错 value = undefined;// 不会报错 Never 表示的是那些永不存在的值的类型,一般用于抛出异常或根本不可能有返回值的函数。\nNever 可以赋值给任意类型, 但其他类型不可以赋值给 Never\n// 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\u0026#34;Something failed\u0026#34;); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } Object 对象 let obj:object; // 定义了一个只能保存对象的变量 // obj = 1; // obj = \u0026#34;123\u0026#34;; // obj = true; obj = {name:\u0026#39;lnj\u0026#39;, age:33}; console.log(obj); interface 接口 基本用法 interface Person { firstName: string; lastName: string; } function hello(person: Person) { return \u0026#34;Hello, \u0026#34; + person.firstName + \u0026#34; \u0026#34; + person.lastName; } let user = { firstName: \u0026#34;Wang\u0026#34;, lastName: \u0026#34;Loen\u0026#34; // else: \u0026#34;error\u0026#34; 会报错 }; document.body.innerHTML = hello(user); 属性数量不确定时的定义方法 少用可选属性 属性名字后面加一个 ？表示可选属性\ninterface FullName{ firstName:string lastName:string middleName?:string } function say({firstName, lastName, middleName}:FullName):void { // console.log(`我的姓名是:${firstName}_${lastName}`); if(middleName){ console.log(`我的姓名是:${firstName}_${middleName}_${lastName}`); }else{ console.log(`我的姓名是:${firstName}_${lastName}`); } } say({firstName:\u0026#39;Jonathan\u0026#39;, lastName:\u0026#39;Lee\u0026#39;, middleName:\u0026#34;666\u0026#34;}); say({firstName:\u0026#39;Jonathan\u0026#39;, lastName:\u0026#39;Lee\u0026#39;}); 多用索引签名 在定义对象中key（propName）和value的数据结构，后续对象中的属性，只要key和value满足索引签名的限定即可, 无论有多少个都无所谓。\ninterface FullName { [propName:string]:string } let obj:FullName = { // 注意点: 只要key和value满足索引签名的限定即可, 无论有多少个都无所谓 firstName:\u0026#39;Jonathan\u0026#39;, lastName:\u0026#39;Lee\u0026#39;, // middleName:false // 报错 // 无论key是什么类型最终都会自动转换成字符串类型, 所以没有报错 // false: \u0026#39;666\u0026#39; } interface stringArray { [propName:number]:string } let arr:stringArray = { 0:\u0026#39;a\u0026#39;, 1:\u0026#39;b\u0026#39;, 2:\u0026#39;c\u0026#39; }; // let arr:stringArray = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; console.log(arr[0]); console.log(arr[1]); console.log(arr[2]); 接口的继承 interface LengthInterface { length:number } interface WidthInterface { width:number } interface HeightInterface { height:number } interface RectInterface extends LengthInterface,WidthInterface,HeightInterface { // length:number // width:number // height:number color:string } let rect:RectInterface = { length:10, width:20, height:30, color:\u0026#39;red\u0026#39; } 函数接口 interface SumInterface { (a:number, b:number):number } // 建议使用这种写法 let sum:SumInterface= function(x,y) { return x + y; } let res = sum(10, 20); console.log(res); 只读属性 可以在属性名前用 readonly来指定只读属性:\ninterface Point { readonly x: number; readonly y: number; } 可以通过赋值一个对象字面量来构造一个Point。 赋值后， x 和 y 再也不能被改变了。\nlet p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript 具有 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\nlet a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray\u0026lt;number\u0026gt; = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! 函数声明 定义函数 // typescript定义函数的方法 // 命名函数 function say1(name:string):void { console.log(name); } // 匿名函数 let say2 = function (name:string):void { console.log(name); } // 箭头函数 let say3 = (name:string):void =\u0026gt;{ console.log(name); } 函数声明和分离实现 利用 type 声明函数 // 先利用type声明一个函数 type AddFun = (a:number, b:number)=\u0026gt;number; // 再根据声明去实现这个函数 // 此时函数的参数和返回值可以不需要写类型声明了，因为ts可以通过这个函数声明推断出来类型了 let add:AddFun = function (x, y) { return x + y; }; let res = add(30, 20); console.log(res); 利用 interface 声明函数 // 先利用interface声明一个函数 interface AddFun { (a:number, b:number):number } let add:AddFun = function (x, y) { return x + y; }; let res = add(30, 20); console.log(res); 参数 可选参数 // 需求: 要求定义一个函数可以实现2个数或者3个数的加法 function add(x:number, y:number, z?:number):number { return x + y + (z ? z : 0); } let res = add(10, 20); let res = add(10, 20, 30); // 可选参数后面只能跟可选参数 // 可选参数可以是一个或多个 默认参数 function add(x:number, y:number=10):number { return x + y; } let res = add(10); let res = add(10, 30); 剩余参数 function add(x:number, ...ags:number[]) { console.log(x); console.log(ags); } add(10, 20, 30, 40, 50) 类型断言 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。TypeScript 会假设你，程序员，已经进行了必须的检查。\n类型断言有两种形式。 其一是尖括号语法： let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; 另一个为as语法： let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (someValue as string).length; 例如: 我们拿到了一个any类型的变量, 但是我们明确的知道这个变量中保存的是字符串类型，此时我们就可以通过类型断言将any类型转换成string类型, 使用字符串类型中相关的方法了。\nlet str:any = \u0026#39;it666\u0026#39;; // 当还是any的时候是没有.length的提示的 let len = (str as string).length; console.log(len); 泛型 什么是泛型 用来弥补any没有语法提示和报错的缺点。\n最开始不指定类型，后面根据我们传入的类型确定类型。\n软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n使用方法 我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。\n我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。\n泛型类 class GenericNumber\u0026lt;T\u0026gt; { zeroValue: T; add: (x: T, y: T) =\u0026gt; T; } let myGenericNumber = new GenericNumber\u0026lt;number\u0026gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function(x, y) { return x + y; };\\ // GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型。 let stringNumeric = new GenericNumber\u0026lt;string\u0026gt;(); stringNumeric.zeroValue = \u0026#34;\u0026#34;; stringNumeric.add = function(x, y) { return x + y; }; console.log(stringNumeric.add(stringNumeric.zeroValue, \u0026#34;test\u0026#34;)); //与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 泛型约束 默认情况下我们可以指定泛型为任意类型，但是有些情况下我们需要指定的类型满足某些条件后才能指定\n那么这个时候我们就可以使用泛型约束。\ninterface IWithLength { length: number } function echoWithLength\u0026lt;T extends IWithLength\u0026gt;(arg: T): T { console.log(arg.length) return arg } const len01 = echoWithLength(\u0026#39;abc\u0026#39;) // 3 const len02 = echoWithLength({ length: 12 }) // 12 const len03 = echoWithLength([1, 2, 3]) // 3 ","permalink":"https://waite.wang/posts/web/ts-learn/","summary":"\u003ch2 id=\"什么是-typescript\"\u003e什么是 TypeScript\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eTypeScript既是一种语言又是一组工具。TypeScript是JavaScript的一个超集。换句话说，TypeScript是JavaScript加上一些额外的功能。\u003c/p\u003e","title":"TypeScript 入门"},{"content":" 首先由于 Win10 家庭版没有 gpedit.msc (本地策略组编辑器), cmd 以下代码将电脑模拟为 专业版\n@echo off pushd \u0026#34;%~dp0\u0026#34; dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum \u0026gt;List.txt dir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum \u0026gt;\u0026gt;List.txt for /f %%i in (\u0026#39;findstr /i . List.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /add-package:\u0026#34;C:\\Windows\\servicing\\Packages\\%%i\u0026#34; pause Win + R 打开 gpedit.msc, 将 \u0026ldquo;以管理员批准模式运行所有管理员\n原因: 电脑本身是管理员用户 但 更上层还有个 更高的管理员\n","permalink":"https://waite.wang/posts/win/power-up-operation-based-on-insufficient-aministrator-uthority-in-win10/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e首先由于 Win10 家庭版没有 gpedit.msc (本地策略组编辑器), cmd 以下代码将电脑模拟为 专业版\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e@echo off\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epushd \u0026#34;%~dp0\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum \u0026gt;List.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edir /b C:\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum \u0026gt;\u0026gt;List.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efor /f %%i in (\u0026#39;findstr /i . List.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /add-package:\u0026#34;C:\\Windows\\servicing\\Packages\\%%i\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003epause\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eWin + R 打开 gpedit.msc, 将 \u0026ldquo;以管理员批准模式运行所有管理员\u003c/strong\u003e\u003c/p\u003e","title":"基于 Win10 管理员权限不足的升权操作"},{"content":"窗口透明 \u0026lt;style\u0026gt; .hope-ui-light{ background-image: url(\u0026#34;https://www.dmoe.cc/random.php\u0026#34;) !important; background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center; } .obj-box { border-radius: 15px !important; } .hope-ui-light .obj-box { background-color: #ffffff70 !important; } .hope-c-PJLV .hope-c-PJLV-ikSuVsl-css { border-radius: 15px !important; background-color: #ffffff70 !important; } .hope-c-PJLV .hope-c-PJLV-ibtHApG-css { border-radius: 15px !important; background-color: #ffffff70 !important; } \u0026lt;/style\u0026gt; 看板娘 \u0026lt;script src=\u0026#34;https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 看板娘 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 鼠标点击效果 \u0026lt;!--鼠标点击效果--\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/maodian.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Aplayer、Meting \u0026lt;!-- aplayer、meting --\u0026gt; \u0026lt;!-- require APlayer --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- require MetingJS --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 不显示歌词 --\u0026gt; \u0026lt;script\u0026gt; function removelrc() { //检测是否存在歌词按钮 if (!document.querySelector(\u0026#34;.aplayer-icon-lrc\u0026#34;)) return; else { //触发以后立刻移除监听 document.removeEventListener(\u0026#34;DOMNodeInserted\u0026#34;,removelrc); //稍作延时保证触发函数时存在按钮 setTimeout(function() { //以触发按钮的方式隐藏歌词，防止在点击显示歌词按钮时需要点击两次才能出现的问题 document.querySelector(\u0026#34;.aplayer-icon-lrc\u0026#34;).click(); }, 1); console.log(\u0026#34;success\u0026#34;); return; } } document.addEventListener(\u0026#39;DOMNodeInserted\u0026#39;, removelrc) \u0026lt;/script\u0026gt; Meting Body部分\n\u0026lt;meting-js server=\u0026#34;netease\u0026#34; type=\u0026#34;playlist\u0026#34; id=\u0026#34;7292043675\u0026#34; fixed = true \u0026gt; \u0026lt;/meting-js\u0026gt; \u0026lt;!-- 吸附边缘 css --\u0026gt; \u0026lt;style\u0026gt; .aplayer.aplayer-withlist.aplayer-fixed.aplayer-narrow, .aplayer.aplayer-withlist.aplayer-fixed.aplayer-narrow .aplayer-body { left: -66px !important; } .aplayer.aplayer-withlist.aplayer-fixed.aplayer-narrow:hover .aplayer-body { left: 0 !important; } \u0026lt;/style\u0026gt; Nnplayer \u0026lt;script src=\u0026#34;https://unpkg.com/nplayer@latest/dist/index.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 备案信息 及 图标颜色 \u0026lt;!--备案信息--\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;link href=\u0026#34;https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css\u0026#34; rel=\u0026#34; stylesheet \u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;customize\u0026#34; style=\u0026#34;display:none; text-align:center;\u0026#34;\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;div style=\u0026#34;font-size:15px; font-family: \u0026#39;Segoe UI\u0026#39;, Tahoma, Geneva, Verdana, sans-serif;\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://github.com/Xhofe/alist\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-heart\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 由Alist驱动 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34; style=\u0026#34;margin-bottom: 5px;\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://cloud1.waite.wang/@manage\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-gear\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 管理后台 \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://waite.wang/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-copyright\u0026#34; style=\u0026#34;color:#9932CC\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 2022 WAITE.WANG | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://beian.miit.gov.cn/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-balance-scale\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 粤 ICP 备 2022028437 号 \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let interval = setInterval(() =\u0026gt; { if (document.querySelector(\u0026#34;.footer\u0026#34;)) { document.querySelector(\u0026#34;#customize\u0026#34;).style.display = \u0026#34;\u0026#34;; clearInterval(interval); } }, 200); \u0026lt;/script\u0026gt; \u0026lt;/font\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .footer { display: none !important; } .hope-c-ivMHWx-dvmlqS-cv { color: #9932CC !important; } .hope-c-PJLV-igVoCQk-css { color: #9932CC !important; } .hope-c-PJLV-ilcHcHe-css { color: #9932CC !important; } .hope-c-PJLV-ieavQQG-css { color: #9932CC !important; } \u0026lt;/style\u0026gt; 运行时间 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function show_runtime() { window.setTimeout(\u0026#34;show_runtime()\u0026#34;, 1000); X = new Date(\u0026#34;8/24/2022 10:28:00\u0026#34;); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = \u0026#34;本站已运行 \u0026#34; + A + \u0026#34;天\u0026#34; + B + \u0026#34;小时\u0026#34; + C + \u0026#34;分\u0026#34; + D + \u0026#34;秒\u0026#34; } show_runtime(); \u0026lt;/script\u0026gt; \u0026lt;span id=\u0026#34;runtime_span\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 网站访问量 \u0026lt;!-- 访问量 --\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 本站总访问量 \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次 自定义头部代码 \u0026lt;!--Alist V3建议添加的，已经默认添加了，如果你的没有建议加上--\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=String.prototype.replaceAll\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--引入字体，全局字体使用--\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://npm.elemecdn.com/lxgw-wenkai-webfont@1.1.0/lxgwwenkai-regular.css\u0026#34; /\u0026gt; \u0026lt;!--评论系统使用的js--\u0026gt; \u0026lt;script src=\u0026#39;https://unpkg.com/valine/dist/Valine.min.js\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--不蒜子计数器--\u0026gt; \u0026lt;script async src=\u0026#34;https://busuanzi.icodeq.com/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- Font6，自定义底部使用和看板娘使用的图标和字体文件--\u0026gt; \u0026lt;link type=\u0026#39;text/css\u0026#39; rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://npm.elemecdn.com/font6pro@6.0.1/css/fontawesome.min.css\u0026#34; media=\u0026#39;all\u0026#39;\u0026gt; \u0026lt;link href=\u0026#34;https://npm.elemecdn.com/font6pro@6.0.1/css/all.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; \u0026lt;!--音乐播放器所用的文件--\u0026gt; \u0026lt;!-- require APlayer --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://npm.elemecdn.com/aplayer@1.10.1/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://npm.elemecdn.com/aplayer@1.10.1/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- require MetingJS --\u0026gt; \u0026lt;script src=\u0026#34;https://npm.elemecdn.com/meting@2.0.1/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 去除通知栏 右上角 X */ .notify-render .hope-close-button{ display: none; } /* 图片API用法点进去都会有食用说明的 樱花：https://www.dmoe.cc 夏沫：https://cdn.seovx.com 搏天：https://api.btstu.cn/doc/sjbz.php 姬长信：https://github.com/insoxin/API 小歪：https://api.ixiaowai.cn/ 保罗：https://api.paugram.com 墨天逸：https://api.mtyqx.cn 岁月小筑：https://img.xjh.me 东方Project：https://img.paulzzh.com */ /*白天背景图*/ .hope-ui-light{ background-image: url(\u0026#34;http://pic.rmb.bdstatic.com/bjh/7569b014a1abafd5481298763300ae1d.png\u0026#34;) !important; background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center; } /*夜间背景图*/ .hope-ui-dark { background-image: url(http://pic.rmb.bdstatic.com/bjh/ebe942a9de49856f389c65f25a338335.png) !important; background-repeat:no-repeat;background-size:cover;background-attachment:fixed;background-position-x:center; } /*主列表夜间模式透明，50%这数值是控制透明度大小的*/ .obj-box.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-iigjoxS-css{ background-color:rgb(0 0 0 / 50%) !important; } /*readme夜间模式透明，50%这数值是控制透明度大小的*/ .hope-c-PJLV.hope-c-PJLV-iiuDLME-css{ background-color:rgb(0 0 0 / 50%) !important; } /*主列表透明*/ .obj-box.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-igScBhH-css { background-color: rgba(255, 255, 255, 0.5) !important; } /*readme透明*/ .hope-c-PJLV.hope-c-PJLV-ikSuVsl-css{ background-color: rgba(255, 255, 255, 0.5) !important; } /*顶部右上角切换按钮透明*/ .hope-c-ivMHWx-hZistB-cv.hope-icon-button{ background-color: rgba(255, 255, 255, 0.3) !important; } /*右下角侧边栏按钮透明*/ .hope-c-PJLV-ijgzmFG-css{ background-color: rgba(255, 255, 255, 0.5) !important; } /*白天模式代码块透明*/ .hope-ui-light pre{ background-color: rgba(255, 255, 255, 0.1) !important; } /*夜间模式代码块透明*/ .hope-ui-dark pre { background-color: rgba(255, 255, 255, 0) !important; } /*底部CSS，.App .table这三个一起的*/ dibu { border-top: 0px; position: absolute; bottom: 0; width: 100%; margin: 0px; padding: 0px; } .App { min-height: 85vh; } .table { margin: auto; } /*去掉底部*/ .footer { display: none !important; } /*全局字体*/ *{font-family:LXGW WenKai} *{font-weight:bold} body {font-family: LXGW WenKai;} /*以下为评论系统专用*/ /*适配大小契合度*/ .newValine{ width: min(96%, 940px); flex-direction: column; row-gap: var(--hope-space-2); border-radius: var(--hope-radii-xl); padding: var(--hope-space-2); box-shadow: var(--hope-shadows-lg); } /*评论区 - 白天模式透明度*/ .hope-ui-light .newValine{ background-color: rgba(255, 255, 255, 0.8) !important; } /*评论区 - 夜间模式透明度*/ .hope-ui-dark .newValine{ background-color:rgb(0 0 0 / 80%) !important; } /*输入栏里面跳舞的小人背景图*/ .vedit{ background-image:url(https://cdn.jsdelivr.net/gh/anwen-anyi/imgAnwen/images/OuNiJiang.gif); background-size:contain; background-repeat:no-repeat; background-position:right bottom; transition:all 0.25s ease-in-out 0s; } textarea#comment-textarea:focus{ background-position-y:120px; transition:all 0.25s ease-in-out 0s; } /*渐变背景CSS*/ #canvas-basic { position: fixed; display: block; width: 100%; height: 100%; top: 0; right: 0; bottom: 0; left: 0; z-index: -999; } \u0026lt;/style\u0026gt; 看板娘代码 \u0026lt;!--看板娘 -自定义大小，隐藏对话框和对话框高度--\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #waifu #live2d { height: 350px!important; width: 350px!important; } #waifu-tips { top: -60px; /*display:none !important;隐藏对话框*/ } \u0026lt;/style\u0026gt; \u0026lt;!--看板娘加载指定模型--\u0026gt; \u0026lt;script\u0026gt; localStorage.setItem(\u0026#39;modelId\u0026#39;, \u0026#39;7\u0026#39;); localStorage.setItem(\u0026#39;modelTexturesId\u0026#39;, \u0026#39;3\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;!--自己选左右--\u0026gt; \u0026lt;script src=\u0026#34;https://api.itggg.cn/live2dnew/left/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://api.itggg.cn/live2dnew/right/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--以下四个两个主用两个备用的,选一条使用即可--\u0026gt; \u0026lt;!--自己选左右--\u0026gt; \u0026lt;script src=\u0026#34;https://api.itggg.cn/live2dnew/left/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://api.itggg.cn/live2dnew/right/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--备用的，自己选左右--\u0026gt; \u0026lt;script src=\u0026#34;https://luluossfile.lulufind.com/work/teacher_u20221017ce7b5991_1666420843832_19934968_file.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://luluossfile.lulufind.com/work/teacher_u20221017bb6d7454_1666420849979_19584065_file.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 自行替换鼠标样式说明 \u0026lt;!--较为个性化的鼠标指针样式，可结合个人需要自行修改--\u0026gt; \u0026lt;style\u0026gt; body { cursor: url(https://luluossfile.lulufind.com/work/teacher_u20221021b3a89013_1666841028833_10660845_file.cur), default; } select{ cursor: url(https://luluossfile.lulufind.com/work/teacher_u2021090299b56677_1666842679271_10490748_file.cur), pointer; } button,a:hover{ cursor: url(https://luluossfile.lulufind.com/work/teacher_u20221017ac9f1124_1666842626270_11086578_file.cur), pointer; } input{ cursor:url(https://luluossfile.lulufind.com/work/teacher_u2021090299b56677_1666842633386_14976764_file.cur), text; } textarea,input:focus{ cursor:url(https://luluossfile.lulufind.com/work/teacher_u202210176ba36766_1666842640146_15845280_file.cur), text; } code{ cursor: url(https://luluossfile.lulufind.com/work/teacher_u20221021b3a89013_1666842646779_15864973_file.cur), default; } pre\u0026gt;code{ cursor: url(https://luluossfile.lulufind.com/work/teacher_u202210176ba36766_1666842653500_10010236_file.cur), default; } \u0026lt;/style\u0026gt; 自定义内容代码 \u0026lt;!--延迟加载--\u0026gt; \u0026lt;!--如果要写自定义内容建议都加到这个延迟加载的范围内--\u0026gt; \u0026lt;div id=\u0026#34;customize\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--音乐播放器--\u0026gt; \u0026lt;meting-js fixed=\u0026#34;true\u0026#34; autoplay=\u0026#34;false\u0026#34; theme=\u0026#34;#409EFF\u0026#34; list-folded=\u0026#34;true\u0026#34; auto=\u0026#34;QQ音乐或者网易云的链接\u0026#34;\u0026gt;\u0026lt;/meting-js\u0026gt; \u0026lt;!--评论模块还有下面的script也是--\u0026gt; \u0026lt;center\u0026gt; \u0026lt;div class=\u0026#34;newValine\u0026#34; id=\u0026#34;vcomments\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;script\u0026gt; new Valine({ visitor: true, el: \u0026#39;#vcomments\u0026#39;, avatar: \u0026#39;wavatar\u0026#39;, appId: \u0026#39;Your appId\u0026#39;, appKey: \u0026#39;Your appKey\u0026#39;, placeholder: \u0026#34;有什么问题欢迎评论区留言~么么哒\u0026#34; }) \u0026lt;/script\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;center class=\u0026#34;dibu\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34; line-height: 20px;font-size: 9pt;font-weight: bold;\u0026#34;\u0026gt; \u0026lt;span\u0026gt; \u0026#34; \u0026lt;span style=\u0026#34;color: rgb(13, 109, 252); font-weight: bold;\u0026#34; id=\u0026#34;hitokoto\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; id=\u0026#34;hitokoto_text\u0026#34;\u0026gt; \u0026#34;人生最大的遗憾,就是在最无能为力的时候遇到一个想要保护一生的人.\u0026#34; \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026#34; \u0026lt;/span\u0026gt; \u0026lt;p style=\u0026#34;margin-left: 10rem;font-size: 8pt;\u0026#34;\u0026gt; \u0026lt;small\u0026gt; —— Anwen\u0026#39;s Cloud \u0026lt;/small\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;font-size: 13px; font-weight: bold;\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;xxxxxxxxxx\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fab fa-qq\u0026#34; style=\u0026#34;color:#409EFF\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; QQ | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;mailto:xxxxx@foxmail.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-duotone fa-envelope-open\u0026#34; style=\u0026#34;color:#409EFF\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 邮箱 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;xxxxxx\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-edit\u0026#34; style=\u0026#34;color:#409EFF\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 博客 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;xxxxxxxx\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-comment-lines\u0026#34; style=\u0026#34;color:#409EFF;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 留言 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;xxxxxxx\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-cloud-download\u0026#34; style=\u0026#34;color:#409EFF;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 云盘 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!--后台入口--\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;/@manage\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-folder-gear\u0026#34; style=\u0026#34;color:#409EFF;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 管理 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!--版权，请尊重作者--\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://github.com/Xhofe/alist\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-copyright\u0026#34; style=\u0026#34;color:#409EFF;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; Alist \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;!--添加一个访问量--\u0026gt; \u0026lt;span\u0026gt; 本\u0026#34;\u0026lt;span style=\u0026#34;color: rgb(13, 109, 252); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;目录\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026#34;访问量 \u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34; style=\u0026#34;color: rgb(13, 109, 252); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次 本站总访问量 \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34; style=\u0026#34;color: rgb(13, 109, 252); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次 本站总访客数 \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34; style=\u0026#34;color: rgb(13, 109, 252); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 人 \u0026lt;/span\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;!--添加备案信息--\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://beian.miit.gov.cn/#/Integrated/index\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-shield-check\u0026#34; style=\u0026#34;color:#409EFF;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 冀 ICP备2222000777号 \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--一言API--\u0026gt; \u0026lt;script src=\u0026#34;https://v1.hitokoto.cn/?encode=js\u0026amp;select=%23hitokoto\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--延迟加载范围到这里结束--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--延迟加载配套使用JS--\u0026gt; \u0026lt;script\u0026gt; let interval = setInterval(() =\u0026gt; { if (document.querySelector(\u0026#34;.footer\u0026#34;)) { document.querySelector(\u0026#34;#customize\u0026#34;).style.display = \u0026#34;\u0026#34;; clearInterval(interval); } }, 200); \u0026lt;/script\u0026gt; \u0026lt;!-- 渐变背景初始化,如果要使用渐变背景把下面的那一行注释去掉即可--\u0026gt; \u0026lt;!-- 下面的几行都是渐变的一套,自定义头部内还有一个关联的自定义CSS --\u0026gt; \u0026lt;!--\u0026lt;canvas id=\u0026#34;canvas-basic\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; --\u0026gt; \u0026lt;script src=\u0026#34;https://npm.elemecdn.com/granim@2.0.0/dist/granim.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var granimInstance = new Granim({ element: \u0026#39;#canvas-basic\u0026#39;, direction: \u0026#39;left-right\u0026#39;, isPausedWhenNotInView: true, states : { \u0026#34;default-state\u0026#34;: { gradients: [ [\u0026#39;#a18cd1\u0026#39;, \u0026#39;#fbc2eb\u0026#39;], [\u0026#39;#fff1eb\u0026#39;, \u0026#39;#ace0f9\u0026#39;], [\u0026#39;#d4fc79\u0026#39;, \u0026#39;#96e6a1\u0026#39;], [\u0026#39;#a1c4fd\u0026#39;, \u0026#39;#c2e9fb\u0026#39;], [\u0026#39;#a8edea\u0026#39;, \u0026#39;#fed6e3\u0026#39;], [\u0026#39;#9890e3\u0026#39;, \u0026#39;#b1f4cf\u0026#39;], [\u0026#39;#a1c4fd\u0026#39;, \u0026#39;#c2e9fb\u0026#39;], [\u0026#39;#fff1eb\u0026#39;, \u0026#39;#ace0f9\u0026#39;] ] } } }); \u0026lt;/script\u0026gt; 网页点击鼠标特效 \u0026lt;!-- 网页鼠标点击特效 - 核心价值观关键字 --\u0026gt; \u0026lt;script\u0026gt; (function () { var a_idx = 0; window.onclick = function (event) { var a = new Array(\u0026#34;❤富强❤\u0026#34;, \u0026#34;❤民主❤\u0026#34;, \u0026#34;❤文明❤\u0026#34;, \u0026#34;❤和谐❤\u0026#34;, \u0026#34;❤自由❤\u0026#34;, \u0026#34;❤平等❤\u0026#34;, \u0026#34;❤公正❤\u0026#34;, \u0026#34;❤法治❤\u0026#34;, \u0026#34;❤爱国❤\u0026#34;, \u0026#34;❤敬业❤\u0026#34;, \u0026#34;❤诚信❤\u0026#34;, \u0026#34;❤友善❤\u0026#34;); var heart = document.createElement(\u0026#34;b\u0026#34;); //创建b元素 heart.onselectstart = new Function(\u0026#39;event.returnValue=false\u0026#39;); //防止拖动 document.body.appendChild(heart).innerHTML = a[a_idx]; //将b元素添加到页面上 a_idx = (a_idx + 1) % a.length; heart.style.cssText = \u0026#34;position: fixed;left:-100%;\u0026#34;; //给p元素设置样式 var f = 13, // 字体大小 x = event.clientX - f / 2 - 30, // 横坐标 y = event.clientY - f, // 纵坐标 c = randomColor(), // 随机颜色 a = 1, // 透明度 s = 0.8; // 放大缩小 var timer = setInterval(function () { //添加定时器 if (a \u0026lt;= 0) { document.body.removeChild(heart); clearInterval(timer); } else { heart.style.cssText = \u0026#34;font-size:16px;cursor: default;position: fixed;color:\u0026#34; + c + \u0026#34;;left:\u0026#34; + x + \u0026#34;px;top:\u0026#34; + y + \u0026#34;px;opacity:\u0026#34; + a + \u0026#34;;transform:scale(\u0026#34; + s + \u0026#34;);\u0026#34;; y--; a -= 0.016; s += 0.002; } }, 15) } // 随机颜色 function randomColor() { return \u0026#34;rgb(\u0026#34; + (~~(Math.random() * 255)) + \u0026#34;,\u0026#34; + (~~(Math.random() * 255)) + \u0026#34;,\u0026#34; + (~~(Math .random() * 255)) + \u0026#34;)\u0026#34;; } }()); \u0026lt;/script\u0026gt; \u0026lt;!-- 网页鼠标点击特效 - 爱心 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; ! function (e, t, a) { function r() { for (var e = 0; e \u0026lt; s.length; e++) s[e].alpha \u0026lt;= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[ e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = \u0026#34;left:\u0026#34; + s[e].x + \u0026#34;px;top:\u0026#34; + s[e].y + \u0026#34;px;opacity:\u0026#34; + s[e].alpha + \u0026#34;;transform:scale(\u0026#34; + s[e].scale + \u0026#34;,\u0026#34; + s[e] .scale + \u0026#34;) rotate(45deg);background:\u0026#34; + s[e].color + \u0026#34;;z-index:99999\u0026#34;); requestAnimationFrame(r) } function n() { var t = \u0026#34;function\u0026#34; == typeof e.onclick \u0026amp;\u0026amp; e.onclick; e.onclick = function (e) { t \u0026amp;\u0026amp; t(), o(e) } } function o(e) { var a = t.createElement(\u0026#34;div\u0026#34;); a.className = \u0026#34;heart\u0026#34;, s.push({ el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: c() }), t.body.appendChild(a) } function i(e) { var a = t.createElement(\u0026#34;style\u0026#34;); a.type = \u0026#34;text/css\u0026#34;; try { a.appendChild(t.createTextNode(e)) } catch (t) { a.styleSheet.cssText = e } t.getElementsByTagName(\u0026#34;head\u0026#34;)[0].appendChild(a) } function c() { return \u0026#34;rgb(\u0026#34; + ~~(255 * Math.random()) + \u0026#34;,\u0026#34; + ~~(255 * Math.random()) + \u0026#34;,\u0026#34; + ~~(255 * Math .random()) + \u0026#34;)\u0026#34; } var s = []; e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e .mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60) }, i( \u0026#34;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: \u0026#39;\u0026#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\u0026#34; ), n(), r() }(window, document); \u0026lt;/script\u0026gt; \u0026lt;!--鼠标点击效果--\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/maodian.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 音乐播放器添加说明 核心代码（记得引用头部内的喔~） QQ音乐 \u0026lt;meting-js fixed=\u0026#34;true\u0026#34; autoplay=\u0026#34;false\u0026#34; theme=\u0026#34;#409EFF\u0026#34; list-folded=\u0026#34;true\u0026#34; auto=\u0026#34;https://y.qq.com/n/yqq/playlist/7927599544.html\u0026#34;\u0026gt;\u0026lt;/meting-js\u0026gt; 网易云 \u0026lt;meting-js fixed=\u0026#34;true\u0026#34; autoplay=\u0026#34;false\u0026#34; theme=\u0026#34;#409EFF\u0026#34; list-folded=\u0026#34;true\u0026#34; server=\u0026#34;netease\u0026#34; type=\u0026#34;playlist\u0026#34; id=\u0026#34;2195404116\u0026#34;\u0026gt; \u0026lt;/meting-js\u0026gt; 加上歌词 \u0026lt;meting-js name=\u0026#34;rainymood\u0026#34; artist=\u0026#34;rainymood\u0026#34; url=\u0026#34;https://rainymood.com/audio1110/0.m4a\u0026#34; cover=\u0026#34;https://rainymood.com/i/badge.jpg\u0026#34; fixed=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;pre hidden\u0026gt; [00:00.00]This [00:04.01]is [00:08.02]Waite \u0026lt;/pre\u0026gt; \u0026lt;/meting-js\u0026gt; 音乐的一些其他参数 选项 默认 描述 id require require song id / playlist id / album id / search keyword server require music platform: netease, tencent, kugou, xiami, baidu type require song, playlist, album, search, artist auto options music link, support: netease, tencent, xiami fixed false enable fixed mode mini false enable mini mode autoplay false audio autoplay theme #2980b9 main color loop all player loop play, values: \u0026lsquo;all\u0026rsquo;, \u0026lsquo;one\u0026rsquo;, \u0026rsquo;none\u0026rsquo; order list player play order, values: \u0026rsquo;list\u0026rsquo;, \u0026lsquo;random\u0026rsquo; preload auto values: \u0026rsquo;none\u0026rsquo;, \u0026lsquo;metadata\u0026rsquo;, \u0026lsquo;auto\u0026rsquo; volume 0.7 default volume, notice that player will remember user setting, default volume will not work after user set volume themselves mutex true prevent to play multiple player at the same time, pause other play lrc-type 0 lyric type list-folded false indicate whether list should folded at first list-max-height 340px list max height storage-name metingjs localStorage key that store player setting 自用 \u0026lt;!--如果要写自定义内容建议都加到这个延迟加载的范围内--\u0026gt; \u0026lt;div id=\u0026#34;customize\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--音乐播放器--\u0026gt; \u0026lt;meting-js list-folded=\u0026#34;true\u0026#34; server=\u0026#34;netease\u0026#34; type=\u0026#34;playlist\u0026#34; id=\u0026#34;7292043675\u0026#34; fixed=true\u0026gt; \u0026lt;pre hidden\u0026gt; [00:00.00]This [00:04.01]is [00:08.02]Waite \u0026lt;/pre\u0026gt; \u0026lt;/meting-js\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;center class=\u0026#34;dibu\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34; line-height: 20px;font-size: 9pt;font-weight: bold;\u0026#34;\u0026gt; \u0026lt;span\u0026gt; \u0026#34; \u0026lt;span style=\u0026#34;color: rgb(121, 15, 104); font-weight: bold; font-size: 15px;\u0026#34; id=\u0026#34;hitokoto\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; id=\u0026#34;hitokoto_text\u0026#34;\u0026gt; \u0026#34;人生最大的遗憾,就是在最无能为力的时候遇到一个想要保护一生的人.\u0026#34; \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026#34; \u0026lt;/span\u0026gt; \u0026lt;p style=\u0026#34;margin-left: 10rem;font-size: 8pt;\u0026#34;\u0026gt; \u0026lt;small\u0026gt; —— Waite\u0026#39;s Cloud \u0026lt;/small\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;font-size: 13px; font-weight: bold;\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;tencent://message/?uin=1657724340\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fab fa-qq\u0026#34; style=\u0026#34;color:#9932CC\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; QQ | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;mailto:waite0603@qq.com\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-duotone fa-envelope-open\u0026#34; style=\u0026#34;color:#9932CC\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 邮箱 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://waite.wang/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-edit\u0026#34; style=\u0026#34;color:#9932CC\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 博客 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;#\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-cloud-download\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 云盘 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!--后台入口--\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;/@manage\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-folder-gear\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 管理 | \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!--版权，请尊重作者--\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://github.com/Xhofe/alist\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-copyright\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; Alist \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;!--添加一个访问量--\u0026gt; \u0026lt;span\u0026gt; 本\u0026#34;\u0026lt;span style=\u0026#34;color: rgb(121, 15, 104); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;目录\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt;\u0026#34;访问量 \u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34; style=\u0026#34;color: rgb(121, 15, 104); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次 本站总访问量 \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34; style=\u0026#34;color: rgb(121, 15, 104); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次 本站总访客数 \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34; style=\u0026#34;color: rgb(121, 15, 104); font-weight: bold;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 人 \u0026lt;/span\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;!--添加备案信息--\u0026gt; \u0026lt;span class=\u0026#34;nav-item\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;nav-link\u0026#34; href=\u0026#34;https://beian.miit.gov.cn/#/Integrated/index\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-shield-check\u0026#34; style=\u0026#34;color:#9932CC;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/i\u0026gt; 粤 ICP 备 2022028437 号 \u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--一言API--\u0026gt; \u0026lt;script src=\u0026#34;https://v1.hitokoto.cn/?encode=js\u0026amp;select=%23hitokoto\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--延迟加载范围到这里结束--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--延迟加载配套使用JS--\u0026gt; \u0026lt;script\u0026gt; let interval = setInterval(() =\u0026gt; { if (document.querySelector(\u0026#34;.footer\u0026#34;)) { document.querySelector(\u0026#34;#customize\u0026#34;).style.display = \u0026#34;\u0026#34;; clearInterval(interval); } }, 200); function removelrc() { //检测是否存在歌词按钮 if (!document.querySelector(\u0026#34;.aplayer-icon-lrc\u0026#34;)) return; else { //触发以后立刻移除监听 document.removeEventListener(\u0026#34;DOMNodeInserted\u0026#34;, removelrc); //稍作延时保证触发函数时存在按钮 setTimeout(function () { //以触发按钮的方式隐藏歌词，防止在点击显示歌词按钮时需要点击两次才能出现的问题 document.querySelector(\u0026#34;.aplayer-icon-lrc\u0026#34;).click(); }, 1); console.log(\u0026#34;success\u0026#34;); return; } } document.addEventListener(\u0026#39;DOMNodeInserted\u0026#39;, removelrc) \u0026lt;/script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 去除通知栏 右上角 X */ .notify-render .hope-close-button { display: none; } /* 图片API用法点进去都会有食用说明的 樱花：https://www.dmoe.cc 夏沫：https://cdn.seovx.com 搏天：https://api.btstu.cn/doc/sjbz.php 姬长信：https://github.com/insoxin/API 小歪：https://api.ixiaowai.cn/ 保罗：https://api.paugram.com 墨天逸：https://api.mtyqx.cn 岁月小筑：https://img.xjh.me 东方Project：https://img.paulzzh.com */ .footer { display: none !important; } .hope-c-ivMHWx-dvmlqS-cv { color: #9932CC !important; } .hope-c-PJLV-igVoCQk-css { color: #9932CC !important; } .hope-c-PJLV-ilcHcHe-css { color: #9932CC !important; } .hope-c-PJLV-ieavQQG-css { color: #9932CC !important; } /*白天背景图*/ .hope-ui-light { background-image: url(\u0026#34;https://img.waite.wang/images/2022/11/27/640x420.jpg\u0026#34;) !important; background-repeat: no-repeat; background-size: cover; background-attachment: fixed; background-position-x: center; } /*夜间背景图*/ .hope-ui-dark { background-image: url(\u0026#34;https://img.waite.wang/images/2022/11/27/640x420-1.jpg\u0026#34;) !important; background-repeat: no-repeat; background-size: cover; background-attachment: fixed; background-position-x: center; } /*主列表夜间模式透明，50%这数值是控制透明度大小的*/ .obj-box.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-iigjoxS-css { background-color: rgb(0 0 0 / 50%) !important; } /*readme夜间模式透明，50%这数值是控制透明度大小的*/ .hope-c-PJLV.hope-c-PJLV-iiuDLME-css { background-color: rgb(0 0 0 / 50%) !important; } /*主列表透明*/ .obj-box.hope-stack.hope-c-dhzjXW.hope-c-PJLV.hope-c-PJLV-igScBhH-css { background-color: rgba(255, 255, 255, 0.5) !important; } /*readme透明*/ .hope-c-PJLV.hope-c-PJLV-ikSuVsl-css { background-color: rgba(255, 255, 255, 0.5) !important; } /*顶部右上角切换按钮透明*/ .hope-c-ivMHWx-hZistB-cv.hope-icon-button { background-color: rgba(255, 255, 255, 0.3) !important; } /*右下角侧边栏按钮透明*/ .hope-c-PJLV-ijgzmFG-css { background-color: rgba(255, 255, 255, 0.5) !important; } /*白天模式代码块透明*/ .hope-ui-light pre { background-color: rgba(255, 255, 255, 0.1) !important; } /*夜间模式代码块透明*/ .hope-ui-dark pre { background-color: rgba(255, 255, 255, 0) !important; } /*底部CSS，.App .table这三个一起的*/ dibu { border-top: 0px; position: absolute; bottom: 0; width: 100%; margin: 0px; padding: 0px; } .App { min-height: 85vh; } .table { margin: auto; } /*去掉底部*/ .footer { display: none !important; } /*全局字体*/ * { font-family: LXGW WenKai } * { font-weight: bold } body { font-family: LXGW WenKai; } .aplayer.aplayer-withlist.aplayer-fixed.aplayer-narrow, .aplayer.aplayer-withlist.aplayer-fixed.aplayer-narrow .aplayer-body { left: -66px !important; } .aplayer.aplayer-withlist.aplayer-fixed.aplayer-narrow:hover .aplayer-body { left: 0 !important; } \u0026lt;/style\u0026gt; ","permalink":"https://waite.wang/posts/tools/alist-beautiful-guide/","summary":"\u003ch2 id=\"窗口透明\"\u003e窗口透明\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-javascript\" data-lang=\"javascript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nx\"\u003estyle\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehope\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eui\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003elight\u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eimage\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003eurl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;https://www.dmoe.cc/random.php\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003erepeat\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nx\"\u003eno\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003erepeat\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003esize\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nx\"\u003ecover\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eattachment\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nx\"\u003efixed\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eposition\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ex\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"nx\"\u003ecenter\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ebox\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nx\"\u003eborder\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eradius\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e15\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehope\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eui\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003elight\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eobj\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ebox\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecolor\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"err\"\u003e#\u003c/span\u003e\u003cspan class=\"nx\"\u003effffff70\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehope\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ePJLV\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehope\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ePJLV\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eikSuVsl\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecss\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003eborder\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eradius\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e15\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecolor\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"err\"\u003e#\u003c/span\u003e\u003cspan class=\"nx\"\u003effffff70\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehope\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ePJLV\u003c/span\u003e \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ehope\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ec\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ePJLV\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eibtHApG\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecss\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003eborder\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003eradius\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e15\u003c/span\u003e\u003cspan class=\"nx\"\u003epx\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003ebackground\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"nx\"\u003ecolor\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"err\"\u003e#\u003c/span\u003e\u003cspan class=\"nx\"\u003effffff70\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003eimportant\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"err\"\u003e/style\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"看板娘\"\u003e看板娘\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- 看板娘 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003elink\u003c/span\u003e \u003cspan class=\"na\"\u003erel\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;stylesheet\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003ehref\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"鼠标点击效果\"\u003e鼠标点击效果\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!--鼠标点击效果--\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@3.0.8/js/maodian.js\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"aplayermeting\"\u003eAplayer、Meting\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- aplayer、meting --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- require APlayer --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003elink\u003c/span\u003e \u003cspan class=\"na\"\u003erel\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;stylesheet\u0026#34;\u003c/span\u003e \u003cspan class=\"na\"\u003ehref\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- require MetingJS --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c\"\u003e\u0026lt;!-- 不显示歌词 --\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     \u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eremovelrc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e//检测是否存在歌词按钮\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003equerySelector\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;.aplayer-icon-lrc\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e//触发以后立刻移除监听\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eremoveEventListener\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;DOMNodeInserted\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"nx\"\u003eremovelrc\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"c1\"\u003e//稍作延时保证触发函数时存在按钮\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e            \u003cspan class=\"nx\"\u003esetTimeout\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e//以触发按钮的方式隐藏歌词，防止在点击显示歌词按钮时需要点击两次才能出现的问题\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e                \u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003equerySelector\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;.aplayer-icon-lrc\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"nx\"\u003eclick\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003econsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003elog\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;success\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nb\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eaddEventListener\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;DOMNodeInserted\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eremovelrc\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eMeting Body部分\u003c/strong\u003e\u003c/p\u003e","title":"Alist 美化指南"},{"content":"创建vite项目并安装vscode插件 Vite Vite 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动.通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目\n兼容性注意\nVite 需要 Node.js 版本 14.18+，16+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。\n使用 NPM: $ npm create vite@latest 使用 Yarn: $ yarn create vite 使用 PNPM: $ pnpm create vite 然后按照提示操作即可！\n你还可以通过附加的命令行选项直接指定项目名称和你想要使用的模板。例如，要构建一个 Vite + Vue 项目，运行:\n# npm 6.x npm create vite@latest my-vue-app --template vue # npm 7+, extra double-dash is needed: npm create vite@latest my-vue-app -- --template vue # yarn yarn create vite my-vue-app --template vue # pnpm pnpm create vite my-vue-app --template vue 查阅更多可以查看 Vite and Vue3 官网\n插件安装 Vue Language Features (Volar): VueLF 是一个专门为 Vue 3 构建的语言支持插件。它基于@vue/reactivity按需计算一切，实现原生 TypeScript 语言服务级别的性能。 Vue 3 Snippets: Vue 代码提示 WindiCSS IntelliSense Stylelint: 然后禁用项目的 css 和 scss 验证。 (ctrl+shift+p) 并搜索“设置 json” \u0026#34;scss.validate\u0026#34;: false \u0026#34;css.validate\u0026#34;: false 在项目根目录stylelint.config.js中创建 stylelint 插件配置文件, 添加以下内容以忽略规则apply, tailwind,etc: module.exports = { rules: { \u0026#39;at-rule-no-unknown\u0026#39;: [ true, { ignoreAtRules: [\u0026#39;tailwind\u0026#39;, \u0026#39;apply\u0026#39;, \u0026#39;variants\u0026#39;, \u0026#39;responsive\u0026#39;, \u0026#39;screen\u0026#39;] } ], \u0026#39;declaration-block-trailing-semicolon\u0026#39;: null, \u0026#39;no-descending-specificity\u0026#39;: null } } Element-plus https://element-plus.org/zh-CN/\n我们建议您使用包管理器（如 NPM、Yarn 或 pnpm）安装 Element Plus，然后您就可以使用打包工具，例如 Vite 或 webpack。\n# 选择一个你喜欢的包管理器 # NPM $ npm install element-plus --save # Yarn $ yarn add element-plus # pnpm $ pnpm install element-plus 用法 完整引入 如果你对打包后的文件大小不是很在乎，那么使用完整导入会更方便。\n// main.ts import { createApp } from \u0026#39;vue\u0026#39; import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) app.use(ElementPlus) app.mount(\u0026#39;#app\u0026#39;) Windi CSS https://cn.windicss.org/guide/\n安装相关包： npm i -D vite-plugin-windicss windicss 然后，在你的 Vite 配置中添加插件： // vite.config.js import WindiCSS from \u0026#39;vite-plugin-windicss\u0026#39; export default { plugins: [ WindiCSS(), ], } 最后，在你的 Vite 入口文件中导入 virtual:windi.css： import \u0026#39;virtual:windi.css\u0026#39; 使用及 @apply 简化代码 \u0026lt;script setup\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button class=\u0026#39;btn\u0026#39;\u0026gt; 按钮 \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .btn{ @apply bg-purple-500 text-indigo-50 px-4 py-2 rounded-full transition-all duration-500 hover:( bg-purple-900) focus:(ring-8 ring-purple-900); } \u0026lt;/style\u0026gt; Vue-router https://router.vuejs.org/zh/index.html\nnpm install vue-router@4 yarn add vue-router@4 /router/index.js import { createRouter, // 函数用来创建一个路由实例 createWebHashHistory // 用来创建一个基于哈希路由的历史对象 } from \u0026#39;vue-router\u0026#39; const routes = [{ path: \u0026#39;/\u0026#39;, name: \u0026#39;Home\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/Home.vue\u0026#39;) }] // 这段代码定义了一个路由器，该路由器使用createWebHashHistory()创建的历史记录对象和给定的路由（routes）来定义路由。 // createWebHashHistory()创建的历史记录对象会把URL的片段存储在window.location.hash中，以支持前进和后退按钮和书签。 const router = createRouter({ history: createWebHashHistory(), routes }) export default router main.js import router from \u0026#39;./router\u0026#39; const app = createApp(App) app.use(router) app.mount(\u0026#39;#app\u0026#39;) 捕获所有路由或 404 Not found 路由 常规参数只匹配 url 片段之间的字符，用 / 分隔。如果我们想匹配任意路径，我们可以使用自定义的 路径参数 正则表达式，在 路径参数 后面的括号中加入 正则表达式 :\nconst routes = [ // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下 { path: \u0026#39;/:pathMatch(.*)*\u0026#39;, name: \u0026#39;NotFound\u0026#39;, component: NotFound }, // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下 { path: \u0026#39;/user-:afterUser(.*)\u0026#39;, component: UserGeneric }, ] 登陆页面开发 ElementPlus_Layout 布局: 通过基础的 24 分栏，迅速简便地创建布局。 Flexbox: 使用 flex 创建一个块级 flex 容器。 Layout 响应式布局 参照了 Bootstrap 的 响应式设计，预设了五个响应尺寸：xs、sm、md、lg 和 xl。\n\u0026lt;template\u0026gt; \u0026lt;el-row :gutter=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;el-col :xs=\u0026#34;8\u0026#34; :sm=\u0026#34;6\u0026#34; :md=\u0026#34;4\u0026#34; :lg=\u0026#34;3\u0026#34; :xl=\u0026#34;1\u0026#34; \u0026gt;\u0026lt;div class=\u0026#34;grid-content ep-bg-purple\u0026#34; /\u0026gt;\u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;4\u0026#34; :sm=\u0026#34;6\u0026#34; :md=\u0026#34;8\u0026#34; :lg=\u0026#34;9\u0026#34; :xl=\u0026#34;11\u0026#34; \u0026gt;\u0026lt;div class=\u0026#34;grid-content ep-bg-purple-light\u0026#34; /\u0026gt;\u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;4\u0026#34; :sm=\u0026#34;6\u0026#34; :md=\u0026#34;8\u0026#34; :lg=\u0026#34;9\u0026#34; :xl=\u0026#34;11\u0026#34; \u0026gt;\u0026lt;div class=\u0026#34;grid-content ep-bg-purple\u0026#34; /\u0026gt;\u0026lt;/el-col\u0026gt; \u0026lt;el-col :xs=\u0026#34;8\u0026#34; :sm=\u0026#34;6\u0026#34; :md=\u0026#34;4\u0026#34; :lg=\u0026#34;3\u0026#34; :xl=\u0026#34;1\u0026#34; \u0026gt;\u0026lt;div class=\u0026#34;grid-content ep-bg-purple-light\u0026#34; /\u0026gt;\u0026lt;/el-col\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .el-col { border-radius: 4px; } .grid-content { border-radius: 4px; min-height: 36px; } \u0026lt;/style\u0026gt; xs \u0026lt;768px 响应式栅格数或者栅格属性对象 number / object sm ≥768px 响应式栅格数或者栅格属性对象 number / object md ≥992px 响应式栅格数或者栅格属性对象 number / object lg ≥1200px 响应式栅格数或者栅格属性对象 number / object xl ≥1920px 响应式栅格数或者栅格属性对象 number / object icon 图标引入 https://element-plus.gitee.io/zh-CN/component/icon.html\n# 选择一个你喜欢的包管理器 # NPM $ npm install @element-plus/icons-vue # Yarn $ yarn add @element-plus/icons-vue # pnpm $ pnpm install @element-plus/icons-vue 注册所有图标\n您需要从 @element-plus/icons-vue 中导入所有图标并进行全局注册。\n// main.ts // 如果您正在使用CDN引入，请删除下面一行。 import * as ElementPlusIconsVue from \u0026#39;@element-plus/icons-vue\u0026#39; const app = createApp(App) for (const [key, component] of Object.entries(ElementPlusIconsVue)) { app.component(key, component) } 使用(插槽)\n\u0026lt;el-input v-model=\u0026#34;form.username\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;\u0026gt; \u0026lt;template #prefix\u0026gt; \u0026lt;el-icon class=\u0026#34;el-input__icon\u0026#34;\u0026gt; \u0026lt;search /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-input\u0026gt; import { Calendar, Search } from \u0026#39;@element-plus/icons-vue\u0026#39; 外部 icon 阿里巴巴矢量图库iconfont\n选择图标加入购物车, 直接下载引用\n// mian.js import \u0026#39;./assets/icon/iconfont.css\u0026#39; \u0026lt;el-link type=\u0026#34;primary\u0026#34; class=\u0026#34;text-white\u0026#34; @click=\u0026#34;JumpToGithub\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;iconfont icon-icon_github mr-1\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Github \u0026lt;/el-link\u0026gt; setup 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的 语法，它具有更多优势：\n更少的样板内容，更简洁的代码。 能够使用纯 TypeScript 声明 props 和自定义事件。 更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。 更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。 普通的 只在组件被首次引入的时候执行一次不同， 中的代码会在每次组件实例被创建的时候执行。 当使用 的时候，任何在 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用 import 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 methods 选项来暴露它 \u0026lt;script setup\u0026gt; // 变量 const msg = \u0026#39;Hello!\u0026#39; // 函数 function log() { console.log(msg) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;log\u0026#34;\u0026gt;{{ msg }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { capitalize } from \u0026#39;./helpers\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ capitalize(\u0026#39;hello\u0026#39;) }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 以下为简单示例代码\n\u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ myref0 }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myref1 }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myref2 }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myref3 }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myrea0 }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myrea1 }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myrea2.age }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myrea3.user.name }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{ myrea4.one.three.age.four }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;el-button @click=\u0026#34;change\u0026#34;\u0026gt;change\u0026lt;/el-button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive } from \u0026#39;vue\u0026#39; export default { setup() { let myref0 = ref(1); let myref1 = ref(2); let myref2 = ref(true); let myref3 = ref(\u0026#39;myref3\u0026#39;) let myrea0 = reactive(0); let myrea1 = reactive(\u0026#39;myrea1\u0026#39;); let myrea2 = reactive({ age: 3 }) let myrea3 = reactive({ user: { name: \u0026#34;zs\u0026#34;, } }) let myrea4 = reactive({ top: \u0026#39;top\u0026#39;, one: { two: \u0026#34;two\u0026#34;, three: { name: \u0026#34;LS\u0026#34;, age: { four: \u0026#34;four\u0026#34; } }, } }) function change() { myref0 = 2; myref1.value++; myref2.value = false; myref3.value = \u0026#39;MyRef333\u0026#39; myrea0++; myrea1 = \u0026#39;myrea1111\u0026#39;; myrea2.age++; myrea3.user.name = \u0026#34;ww\u0026#34;; myrea4.one.three.age.four = \u0026#34;five\u0026#34;; console.log(myref0); console.log(myrea0); console.log(myrea1); } return { myref0, myrea0, myref1, myrea1, myref2, myrea2, myref3, myrea3, myrea4, change } } } \u0026lt;/script\u0026gt; 1 =\u0026gt; 1 2 =\u0026gt; 3 false =\u0026gt; flase MyRef3 =\u0026gt; MyRef333 0 =\u0026gt; 0 myrea1 =\u0026gt; myrea1 3 =\u0026gt; 4 zs =\u0026gt; ww four =\u0026gt; five ref包裹简单类型，可以响应数据变化。 reactive包裹简单类型，不可以响应数据变化。 在更改ref包裹的值时，需要加 .value 来触发响应。 在页面中使用，{{ }}进行文本插值时，即使使用ref包裹也不需要添加 .value 属性，得益于在检测到 __v_isRef:true 时，vue会帮我们添加。 登录表单校验 \u0026lt;el-form ref=\u0026#34;formRef\u0026#34; :model=\u0026#34;form\u0026#34; :rules=\u0026#34;rules\u0026#34; class=\u0026#34;w-2/4\u0026#34;\u0026gt; \u0026lt;el-form-item prop=\u0026#34;username\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.username\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;\u0026gt; \u0026lt;template #prefix\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;User /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item prop=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; show-password @keyup.enter.native=\u0026#34;onSubmit\u0026#34;\u0026gt; \u0026lt;template #prefix\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;Lock /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button round color=\u0026#34;#2563eb \u0026#34; class=\u0026#34;w-full\u0026#34; type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;登 录\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; import { reactive, ref } from \u0026#39;vue\u0026#39; // do not use same name with ref const form = reactive({ username: \u0026#34;\u0026#34;, password: \u0026#34;\u0026#34; }) const rules = { username: [ { required: true, message: \u0026#39;用户名不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; }, ], password: [ { required: true, message: \u0026#39;密码不能为空\u0026#39;, trigger: \u0026#39;blur\u0026#39; }, ] } const formRef = ref(null) const onSubmit = () =\u0026gt; { formRef.value.validate((valid) =\u0026gt; { if (!valid) { return false } console.log(\u0026#34;验证通过\u0026#34;); }) } Axios http://axios-js.com/\nnpm install axios // /src/axios.js import axios from \u0026#39;axios\u0026#39;; console.log(import.meta.env.VITE_APP_BASE_API); const instance = axios.create({ baseURL:import.meta.env.VITE_APP_BASE_API, }) export default instance; // vue.config.js import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import WindiCSS from \u0026#39;vite-plugin-windicss\u0026#39; import path from \u0026#39;path\u0026#39; // https://vitejs.dev/config/ export default defineConfig({ // 它将别名“~”映射到当前目录的“src”文件夹，因此在进行路径引用时，可以使用“~”，而不是使用相对路径。 resolve: { alias: { \u0026#39;~\u0026#39;: path.resolve(__dirname, \u0026#39;src\u0026#39;), }, }, plugins: [ vue(), WindiCSS() ], server: { cors: true, proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;https://ceshi13.dishait.cn\u0026#39;, changeOrigin: true, rewrite: (path) =\u0026gt; path.replace(/^\\/api/, \u0026#39;\u0026#39;), }, }, }, build: { sourcemap: false, // 消除打包大小超过500kb警告 chunkSizeWarningLimit: 4000 }, }) import axios from \u0026#39;~/axios\u0026#39;; // 通过 export 导出 export const login = (username, password) =\u0026gt; { return axios.post(\u0026#39;/admin/login\u0026#39;, { username, password }); }; Vueuse https://vueuse.org/\n把一些原本不支持响应式的 api 等 支持响应式\nuseCookies npm i @vueuse/integrations npm i universal-cookie \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-12\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;set(\u0026#39;test\u0026#39;, \u0026#39;test\u0026#39;)\u0026#34;\u0026gt;设置cookie\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;remove(\u0026#39;test\u0026#39;)\u0026#34;\u0026gt;删除cookie\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;get(\u0026#39;test\u0026#39;)\u0026#34;\u0026gt;读取cookie\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useCookies } from \u0026#34;@vueuse/integrations/useCookies\u0026#34;; const TokenKey = \u0026#34;admin-token\u0026#34;; const cookies = useCookies(); // 获取token export function getToken() { return cookies.get(TokenKey); } // 设置token export function setToken(token) { // token 有效期为 60 分钟 const expires = new Date(Date.now() + 60 * 60 * 1000); cookies.set(TokenKey, token, { expires }); } // 移除token export function removeToken() { return cookies.remove(TokenKey); } \u0026lt;/script\u0026gt; 拦截器 import { getToken} from \u0026#39;~/composables/auth\u0026#39; import { toast } from \u0026#39;~/composables/util\u0026#39; import axios from \u0026#39;axios\u0026#39;; // 创建axios实例 const instance = axios.create({ baseURL: import.meta.env.VITE_APP_BASE_API, }) // 添加请求拦截器 instance.interceptors.request.use(function (config) { // 在发送请求之前做些什么 const token = getToken(); if (token) { config.headers[\u0026#39;token\u0026#39;] = token; } return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 instance.interceptors.response.use(function (response) { // 对响应数据做点什么 return response.data.data; }, function (error) { // 对响应错误做点什么 toast(error.response.data.msg, \u0026#39;error\u0026#39;); return Promise.reject(error); }); export default instance; Vuex Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\nnpm install vuex@next --save // /store/index.js import { createStore } from \u0026#39;vuex\u0026#39; // 创建一个新的 store 实例 const store = createStore({ state() { return { // 用户信息 user: {} } }, mutations: { // 设置用户信息 SET_USER_INFO(state, user) { state.user = user } } }); export default store import { useStore } from \u0026#39;vuex\u0026#39; const store = useStore(); store.commit(\u0026#39;SET_USER_INFO\u0026#39;, res2); \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;about\u0026#34;\u0026gt; \u0026lt;h1\u0026gt; {{ $store.state.user }}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 具体使用看官方文档\n全局路由守卫 // /src/permission.js // 处理权限相关 import router from \u0026#39;~/router\u0026#39; import { getToken } from \u0026#39;~/composables/auth\u0026#39; import { toast } from \u0026#39;~/composables/util\u0026#39; // 全局前置守卫 router.beforeEach((to, from, next) =\u0026gt; { // 如果有token，就放行 const token = getToken(); // 如果没有token，就跳转到登录页 if (!token \u0026amp;\u0026amp; to.path !== \u0026#39;/login\u0026#39;) { toast(\u0026#34;请先登录\u0026#34;, \u0026#34;warning\u0026#34;); return next ({ path: \u0026#34;/login\u0026#34; }) }; // 防止重复登录 if (token \u0026amp;\u0026amp; to.path === \u0026#39;/login\u0026#39;) { toast(\u0026#34;请先退出登录\u0026#34;, \u0026#34;warning\u0026#34;); return next ({ path: from.path }) }; next() }) // mian.js import \u0026#34;./permission\u0026#34; app.use(store) 全局 loading // npm i nprogress // main.js import \u0026#34;nprogress/nprogress.css\u0026#34; // composable/util.js // 显示全屏loading export function showFullLoading() { nprogress.start() } // 隐藏全屏loading export function hideFullLoading() { nprogress.done() } // permission.js import { toast, showFullLoading, hideFullLoading } from \u0026#39;~/composables/util\u0026#39; // 全局前置守卫 router.beforeEach(async (to, from, next) =\u0026gt; { // 显示 loading showFullLoading(); } // 全局后置守卫 router.afterEach(() =\u0026gt; { // 隐藏 loading hideFullLoading(); }) 样式 #nprogress .bar { background: wheat !important; height: 3px !important; } 动态页面标题 // router/index.js { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39;, component: Login, meta: { title: \u0026#39;登录\u0026#39; } } // permission.js // 全局前置守卫 router.beforeEach(async (to, from, next) =\u0026gt; { // 设置页面标题 document.title = to.meta.title; } 后台 Layout 开发 组件引用 // /layout/admin.vue \u0026lt;template\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt; \u0026lt;f-header\u0026gt;\u0026lt;/f-header\u0026gt; \u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;f-menu\u0026gt;\u0026lt;/f-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;f-tag-list\u0026gt;\u0026lt;/f-tag-list\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;el-footer\u0026gt;Footer\u0026lt;/el-footer\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/template\u0026gt; import FHeader from \u0026#39;./components/FHeader.vue\u0026#39;; import FMenu from \u0026#39;./components/FMenu.vue\u0026#39;; import FTagList from \u0026#39;./components/FTagList.vue\u0026#39;; 头部代码 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;f-header\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;el-icon class=\u0026#34;mr-1\u0026#34;\u0026gt;\u0026lt;eleme-filled /\u0026gt;\u0026lt;/el-icon\u0026gt; 帝莎编程 \u0026lt;/span\u0026gt; \u0026lt;el-icon class=\u0026#34;icon-btn\u0026#34;\u0026gt; \u0026lt;fold /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;el-icon class=\u0026#34;icon-btn\u0026#34;\u0026gt; \u0026lt;refresh /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;div class=\u0026#34;ml-auto flex items-center\u0026#34;\u0026gt; \u0026lt;el-icon class=\u0026#34;icon-btn\u0026#34;\u0026gt;\u0026lt;full-screen /\u0026gt;\u0026lt;/el-icon\u0026gt; \u0026lt;el-dropdown class=\u0026#34;dropdown\u0026#34; @command=\u0026#34;handleCommand\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;flex items-center text-light-50\u0026#34;\u0026gt; \u0026lt;el-avatar class=\u0026#34;mr-2\u0026#34; :size=\u0026#34;25\u0026#34; :src=\u0026#34;$store.state.user.avatar\u0026#34; /\u0026gt; {{ $store.state.user.username }} \u0026lt;el-icon class=\u0026#34;el-icon--right\u0026#34;\u0026gt; \u0026lt;arrow-down /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;template #dropdown\u0026gt; \u0026lt;el-dropdown-menu\u0026gt; \u0026lt;el-dropdown-item command=\u0026#34;rePwd\u0026#34;\u0026gt;修改密码\u0026lt;/el-dropdown-item\u0026gt; \u0026lt;el-dropdown-item command=\u0026#34;logout\u0026#34;\u0026gt;退出登录\u0026lt;/el-dropdown-item\u0026gt; \u0026lt;/el-dropdown-menu\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-dropdown\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .f-header { @apply flex items-center bg-indigo-700 text-light-50 fixed top-0 left-0 right-0; height: 64px; } .logo { width: 250px; @apply flex justify-center items-center text-xl font-thin; } .icon-btn { @apply flex justify-center items-center; width: 42px; height: 64px; cursor: pointer; } .icon-btn:hover { @apply bg-indigo-600; } .f-header .dropdown { height: 64px; cursor: pointer; @apply flex justify-center items-center mx-5; } \u0026lt;/style\u0026gt; 下拉菜单事件绑定 \u0026lt;el-dropdown class=\u0026#34;dropdown\u0026#34; @command=\u0026#34;handleCommand\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;flex items-center text-light-50\u0026#34;\u0026gt; \u0026lt;el-avatar class=\u0026#34;mr-2\u0026#34; :size=\u0026#34;25\u0026#34; :src=\u0026#34;$store.state.user.avatar\u0026#34; /\u0026gt; {{ $store.state.user.username }} \u0026lt;el-icon class=\u0026#34;el-icon--right\u0026#34;\u0026gt; \u0026lt;arrow-down /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;template #dropdown\u0026gt; \u0026lt;el-dropdown-menu\u0026gt; \u0026lt;el-dropdown-item command=\u0026#34;rePwd\u0026#34;\u0026gt;修改密码\u0026lt;/el-dropdown-item\u0026gt; \u0026lt;el-dropdown-item command=\u0026#34;logout\u0026#34;\u0026gt;退出登录\u0026lt;/el-dropdown-item\u0026gt; \u0026lt;/el-dropdown-menu\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-dropdown\u0026gt; \u0026lt;script setup\u0026gt; const handleCommand = (command)=\u0026gt;{ console.log(command); } \u0026lt;/script\u0026gt; 页面刷新和全屏 https://vueuse.org/core/useFullscreen/#usefullscreen\nnpm i @vueuse/core \u0026lt;el-tooltip effect=\u0026#34;dark\u0026#34; content=\u0026#34;刷新\u0026#34; placement=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;el-icon class=\u0026#34;icon-btn\u0026#34; @click=\u0026#34;handleRefresh\u0026#34;\u0026gt; \u0026lt;refresh /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/el-tooltip\u0026gt; \u0026lt;el-tooltip effect=\u0026#34;dark\u0026#34; content=\u0026#34;全屏\u0026#34; placement=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;el-icon class=\u0026#34;icon-btn\u0026#34; @click=\u0026#34;toggle\u0026#34;\u0026gt; \u0026lt;full-screen v-if=\u0026#34;!isFullscreen\u0026#34; /\u0026gt; \u0026lt;aim v-else /\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;/el-tooltip\u0026gt; // full-screen v-if=\u0026#34;!isFullscreen\u0026#34;和aim v-else是两个自定义的组件，它们 // 分别代表全屏和非全屏状态下的图标。其中，v-if=\u0026#34;!isFullscreen\u0026#34;表示当 // isFullscreen为false时，显示full-screen组件，否则显示aim组件。 \u0026lt;script setup\u0026gt; import { useFullscreen } from \u0026#39;@vueuse/core\u0026#39; const handleRefresh = ()=\u0026gt;{ // router.go(0); location.reload(); } // const toggle = ()=\u0026gt;{ // if (document.fullscreenElement) { // document.exitFullscreen(); // } else { // document.documentElement.requestFullscreen(); // } // } const { isFullscreen, toggle } = useFullscreen() // isFullscreen 是否全屏 // toggle 切换全屏 \u0026lt;/script\u0026gt; 通用抽屉组件封装 defineExpose 使用 的组件是默认关闭的——即通过模板引用或者 $parent 链获取到的组件的公开实例，不会暴露任何在 中声明的绑定。\n可以通过 defineExpose 编译器宏来显式指定在 组件中要暴露出去的属性：\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const a = 1 const b = ref(2) defineExpose({ a, b }) \u0026lt;/script\u0026gt; 当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 { a: number, b: number } (ref 会和在普通实例中一样被自动解包)\n\u0026lt;template\u0026gt; \u0026lt;el-drawer v-model=\u0026#34;showDrawer\u0026#34; title=\u0026#34;修改密码\u0026#34; size=\u0026#34;45%\u0026#34; :close-on-click-modal=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;formDrawer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;actions\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;提交\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;default\u0026#34; @click=\u0026#34;close\u0026#34;\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-drawer\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#34;vue\u0026#34; const showDrawer = ref(false) // 打开 const open = ()=\u0026gt; showDrawer.value = true // 关闭 const close = ()=\u0026gt;showDrawer.value = false // 向父组件暴露以下方法 defineExpose({ open, close }) \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .formDrawer{ width: 100%; height: 100%; position: relative; @apply flex flex-col; } .formDrawer .body{ flex: 1; position: absolute; top: 0; left: 0; right: 0; bottom: 50px; overflow-y: auto; } .formDrawer .actions{ height: 50px; @apply mt-auto flex items-center; } \u0026lt;/style\u0026gt; defineProps() 和 defineEmits() 为了在声明 props 和 emits 选项时获得完整的类型推导支持，我们可以使用 defineProps 和 defineEmits API，它们将自动地在 中可用：\n\u0026lt;script setup\u0026gt; const props = defineProps({ foo: String }) const emit = defineEmits([\u0026#39;change\u0026#39;, \u0026#39;delete\u0026#39;]) // setup 代码 \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;el-drawer v-model=\u0026#34;showDrawer\u0026#34; :title=\u0026#34;title\u0026#34; :size=\u0026#34;size\u0026#34; :close-on-click-modal=\u0026#34;false\u0026#34; :destroy-on-close=\u0026#34;destroyOnClose\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;formDrawer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;actions\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;submit\u0026#34; :loading=\u0026#34;loading\u0026#34;\u0026gt;{{ submitText }}\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;default\u0026#34; @click=\u0026#34;close\u0026#34;\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/el-drawer\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // defineProps() 接收父组件传递的参数 const props = defineProps({ title: String, size: { type: String, default: \u0026#39;45%\u0026#39; }, // 控制是否在关闭 Drawer 之后将子元素全部销毁 destroyOnClose: { type: Boolean, default: true }, // 提交按钮的文字 submitText: { type: String, default: \u0026#39;提交\u0026#39; }, }) // 这段代码使用了 Vue 3 中的 defineEmits 函数来声明了一个名为 submit 的事件。然后在 submit 函数中，调用了 emit 函数并传入了 // 事件名称 \u0026#39;submit\u0026#39;，从而触发了名为 submit 的事件。这样做的好处是可以在组件的模板中使用 v-on:submit 或 @submit 来监听该事件 // 从而实现组件与父组件之间的通信。 const emit = defineEmits([\u0026#39;submit\u0026#39;]) const submit = () =\u0026gt; emit(\u0026#39;submit\u0026#39;) \u0026lt;script\u0026gt; \u0026lt;form-drawer ref=\u0026#34;formDrawerRef\u0026#34; title=\u0026#34;修改密码\u0026#34; size=\u0026#34;30%\u0026#34; destroy-on-close @submit=\u0026#34;onSubmit\u0026#34; /\u0026gt; 菜单栏 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;f-menu\u0026#34; :style=\u0026#34;{ width: $store.state.asideWidth }\u0026#34;\u0026gt; \u0026lt;el-menu :default-active=\u0026#34;defaultActive\u0026#34; unique-opened default-active=\u0026#34;2\u0026#34; class=\u0026#34;border-0\u0026#34; @select=\u0026#34;handleSelect\u0026#34; :collapse=\u0026#34;isCollapse\u0026#34; :collapse-transition=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;template v-for=\u0026#34;(item, index) in asideMenus\u0026#34; :key=\u0026#34;index\u0026#34;\u0026gt; \u0026lt;el-sub-menu v-if=\u0026#34;item.child \u0026amp;\u0026amp; item.child.length \u0026gt; 0\u0026#34; :index=\u0026#34;item.name\u0026#34;\u0026gt; \u0026lt;template #title\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;component :is=\u0026#34;item.icon\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;{{ item.name }}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;el-menu-item v-for=\u0026#34;(item2, index2) in item.child\u0026#34; :key=\u0026#34;index2\u0026#34; :index=\u0026#34;item2.frontpath\u0026#34;\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;component :is=\u0026#34;item2.icon\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;{{ item2.name }}\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-sub-menu\u0026gt; \u0026lt;el-menu-item v-else :index=\u0026#34;item.frontpath\u0026#34;\u0026gt; \u0026lt;el-icon\u0026gt; \u0026lt;component :is=\u0026#34;item.icon\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/el-icon\u0026gt; \u0026lt;span\u0026gt;{{ item.name }}\u0026lt;/span\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { useRouter, useRoute } from \u0026#39;vue-router\u0026#39;; import { computed, ref } from \u0026#39;vue\u0026#39;; import { useStore } from \u0026#39;vuex\u0026#39;; const store = useStore() const isCollapse = computed(() =\u0026gt; store.state.asideWidth != \u0026#34;250px\u0026#34;) // 默认选中当前路由路径 const route = useRoute() const defaultActive = ref(route.path) const router = useRouter() const asideMenus = [ { \u0026#34;name\u0026#34;: \u0026#34;后台面板\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;help\u0026#34;, \u0026#34;child\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;主控台\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;home-filled\u0026#34;, \u0026#34;frontpath\u0026#34;: \u0026#34;/\u0026#34;, }] }, { \u0026#34;name\u0026#34;: \u0026#34;商城管理\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;shopping-bag\u0026#34;, \u0026#34;child\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;shopping-cart-full\u0026#34;, \u0026#34;frontpath\u0026#34;: \u0026#34;/goods/list\u0026#34;, }], }, { \u0026#34;name\u0026#34;: \u0026#34;用户管理\u0026#34;, \u0026#34;icon\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;frontpath\u0026#34;: \u0026#34;/user/list\u0026#34; } ] const handleSelect = (e) =\u0026gt; { router.push(e) } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .f-menu { transition: all 0.2s; top: 64px; bottom: 0; left: 0; overflow-y: auto; overflow-x: hidden; @apply shadow-md fixed bg-light-50; } .f-menu::-webkit-scrollbar { width: 0px; } \u0026lt;/style\u0026gt; const store = createStore({ state() { return { // 用户信息 user: {}, // 侧边栏宽度 asideWidth: \u0026#34;250px\u0026#34;, } }, mutations: { // 设置用户信息 SET_USER_INFO(state, user) { state.user = user }, // 侧边栏展开 ASIDE_OPEN(state) { state.asideWidth = state.asideWidth == \u0026#34;250px\u0026#34; ? \u0026#34;64px\u0026#34; : \u0026#34;250px\u0026#34; } } }); Menu 属性名 说明 unique-opened 是否只保持一个子菜单的展开 default-active 页面加载时默认激活菜单的 index 根据菜单添加路由 check 路由 https://router.vuejs.org/zh/guide/advanced/dynamic-routing.html#%E6%9F%A5%E7%9C%8B%E7%8E%B0%E6%9C%89%E8%B7%AF%E7%94%B1\nVue Router 提供了两个功能来查看现有的路由：\nrouter.hasRoute()：检查路由是否存在。 router.getRoutes()：获取一个包含所有路由记录的数组。 hasRoute(name): boolean Checks if a route with a given name exists import { createRouter, // 函数用来创建一个路由实例 createWebHashHistory // 用来创建一个基于哈希路由的历史对象 } from \u0026#39;vue-router\u0026#39; import Index from \u0026#39;~/pages/index.vue\u0026#39; import NotFound from \u0026#39;~/pages/404.vue\u0026#39; import Admin from \u0026#39;~/layouts/admin.vue\u0026#39; import GoodList from \u0026#39;~/pages/goods/list.vue\u0026#39; import CategoryList from \u0026#39;~/pages/category/list.vue\u0026#39; import Login from \u0026#39;~/pages/login/login.vue\u0026#39; // 默认路由, 所有用户都可以访问 const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;Admin\u0026#39;, component: Admin, meta: { title: \u0026#39;后台首页\u0026#39; } }, { path: \u0026#39;/:pathMatch(.*)*\u0026#39;, name: \u0026#39;NotFound\u0026#39;, component: NotFound, meta: { title: \u0026#39;404\u0026#39; } }, { path: \u0026#39;/login\u0026#39;, name: \u0026#39;Login\u0026#39;, component: Login, meta: { title: \u0026#39;登录\u0026#39; } } ] // 动态路由, 用于匹配用户权限添加的路由 const asyncRoutes = [{ path: \u0026#34;/\u0026#34;, name: \u0026#34;/\u0026#34;, component: Index, meta: { title: \u0026#34;后台首页\u0026#34; } }, { path: \u0026#34;/goods/list\u0026#34;, name: \u0026#34;/goods/list\u0026#34;, component: GoodList, meta: { title: \u0026#34;商品管理\u0026#34; } }, { path: \u0026#34;/category/list\u0026#34;, name: \u0026#34;/category/list\u0026#34;, component: CategoryList, meta: { title: \u0026#34;分类列表\u0026#34; } }] // 这段代码定义了一个路由器，该路由器使用createWebHashHistory()创建的历史记录对象和给定的路由（routes）来定义路由。 // createWebHashHistory()创建的历史记录对象会把URL的片段存储在window.location.hash中，以支持前进和后退按钮和书签。 export const router = createRouter({ history: createWebHashHistory(), routes }) // 用于添加动态路由 export function addRoutes(menus) { // 是否有新的路由 let hasNewRoutes = false const findAndAddRoutesByMenu = (menuList) =\u0026gt; { menuList.forEach(menu =\u0026gt; { let item = asyncRoutes.find(item =\u0026gt; item.path == menu.frontpath) // 判断是否已经添加过路由 if (item \u0026amp;\u0026amp; !router.hasRoute(item.path)) { router.addRoute(\u0026#39;Admin\u0026#39;, item) hasNewRoutes = true } if (menu.child \u0026amp;\u0026amp; menu.child.length \u0026gt; 0) { findAndAddRoutesByMenu(menu.child) } }) } findAndAddRoutesByMenu(menus) return hasNewRoutes } 动态路由主要通过两个函数实现。router.addRoute() 和 router.removeRoute()。它们只注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 router.push() 或 router.replace() 来手动导航\n// 全局前置守卫 router.beforeEach(async (to, from, next) =\u0026gt; { // 如果用户登录了，自动获取用户信息，并存储在vuex当中 let hasNewRoutes = false if (token) { let { menus } = await store.dispatch(\u0026#34;getinfo\u0026#34;) // 动态添加路由 hasNewRoutes = addRoutes(menus); } // 设置页面标题 document.title = to.meta.title; hasNewRoutes ? next(to.fullPath) : next(); }) 标签导航方法 const tabList = ref([ { title: \u0026#39;后台首页\u0026#39;, path: \u0026#34;/\u0026#34; } ]) // 添加标签导航 const addTab = (tab) =\u0026gt; { // 判断是否存在 let notab = tabList.value.findIndex(item =\u0026gt; item.path == tab.path) == -1; if (notab) { tabList.value.push(tab); } cookies.set(\u0026#34;tabList\u0026#34;, tabList.value); } // 初始化标签导航列表 function initTabList() { let tbs = cookies.get(\u0026#34;tabList\u0026#34;); if (tbs) { tabList.value = tbs; } } initTabList() // onBeforeRouteUpdate 监听路由变化 onBeforeRouteUpdate((to, from) =\u0026gt; { activeTab.value = to.path; addTab({ title: to.meta.title, path: to.path }); }) // 页面切换 const changeTab = (t) =\u0026gt; { activeTab.value = t; router.push(t); } // 移除标签导航 const removeTab = (t) =\u0026gt; { let tabs = tabList.value let a = activeTab.value if (a == t) { tabs.forEach((tab, index) =\u0026gt; { if (tab.path == t) { const nextTab = tabs[index + 1] || tabs[index - 1] if (nextTab) { a = nextTab.path } } }) } activeTab.value = a; tabList.value = tabList.value.filter(tab =\u0026gt; tab.path != t); cookies.set(\u0026#34;tabList\u0026#34;, tabList.value); } Keep-alive 页面缓存 https://cn.vuejs.org/guide/built-ins/keep-alive.html#keepalive\n默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。\n在切换时创建新的组件实例通常是有意义的，但在这个例子中，我们的确想要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 内置组件将这些动态组件包装起来：\n\u0026lt;!-- 非活跃的组件将会被缓存！ --\u0026gt; \u0026lt;KeepAlive\u0026gt; \u0026lt;component :is=\u0026#34;activeComponent\u0026#34; /\u0026gt; \u0026lt;/KeepAlive\u0026gt; transition全局过渡动画 https://cn.vuejs.org/guide/built-ins/transition.html\n每个子页面只能有一个 根结点\nhttps://animate.style/ 动画效果！\nhttps://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.css\n权限控制 V-permission 自定义指令 // directives\\permission.js import store from \u0026#34;~/store\u0026#34; function hasPermission(value, el = false) { if (!Array.isArray(value)) { throw new Error(`需要配置权限，例如 v-permission=\u0026#34;[\u0026#39;getStatistics3,GET\u0026#39;]\u0026#34;`) } const hasAuth = value.findIndex(v =\u0026gt; store.state.ruleNames.includes(v)) != -1 if (el \u0026amp;\u0026amp; !hasAuth) { // 拿到当前元素的父元素，然后删除当前元素 el.parentNode \u0026amp;\u0026amp; el.parentNode.removeChild(el) } return hasAuth } export default { install(app) { app.directive(\u0026#34;permission\u0026#34;, { // el: 指令所绑定的元素，可以用来直接操作 DOM 。 // binding: 传递给指令的值，例如：v-my-directive=\u0026#34;1 + 1\u0026#34; 中，参数为 2。 mounted(el, binding) { hasPermission(binding.value, el) } }) } } // main.js import permission from \u0026#39;~/directives/permission\u0026#39; const app = createApp(App) app.use(permission) app.mount(\u0026#39;#app\u0026#39;) 运用\n// 直接调用 directives\\permission.js 中方法判断 不存在删除元素 \u0026lt;el-col v-permission=\u0026#34;[\u0026#39;getStatistics3,GET\u0026#39;]\u0026#34; :span=\u0026#34;12\u0026#34; :offset=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;IndexChart /\u0026gt; \u0026lt;/el-col\u0026gt; 统计面板 Element Plus 提示插件： Element Plus Snippets\nLayout 布局\n卡片\ntag 标签\n骨架屏组件 在需要等待加载内容的位置设置一个骨架屏，某些场景下比 Loading 的视觉效果更好。\n数字滚动动画 gsap\n封装组件 /components/CountTo.vue \u0026lt;template\u0026gt; \u0026lt;!-- toFix 保留两位 限制加载小数点过多 --\u0026gt; {{ d.num.toFixed(2) }} \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { reactive, watch } from \u0026#39;vue\u0026#39;; import gsap from \u0026#39;gsap\u0026#39; const props = defineProps({ value: { type: Number, default: 0 } }) const d = reactive({ num: 0 }) function AnimateToValue() { gsap.to(d, { duration: 0.5, num: props.value }) } AnimateToValue() // watch 是 Vue.js 3 中的一个 API，用于监听变量或者对象的变化，并在变化时执行回调函数。 watch(() =\u0026gt; props.value, () =\u0026gt; AnimateToValue() ) \u0026lt;/script\u0026gt; 应用以及使用 import CountTo from \u0026#34;~/components/CountTo.vue\u0026#34;; \u0026lt;span class=\u0026#34;text-3xl font-bold text-gray-500\u0026#34;\u0026gt; \u0026lt;CountTo :value=\u0026#34;item.value\u0026#34; /\u0026gt; \u0026lt;/span\u0026gt; Echarts 初步实现 \u0026lt;template\u0026gt; \u0026lt;el-card shadow=\u0026#34;never\u0026#34; class=\u0026#34;mt-5\u0026#34;\u0026gt; \u0026lt;template #header\u0026gt; \u0026lt;div class=\u0026#34;flex justify-between\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;text-sm\u0026#34;\u0026gt;订单统计\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; \u0026lt;el-check-tag v-for=\u0026#34;(item, index) in options\u0026#34; :key=\u0026#34;index\u0026#34; :checked=\u0026#34;current == item.value\u0026#34; style=\u0026#34;margin-right: 8px\u0026#34; @click=\u0026#34;handleChoose(item.value)\u0026#34;\u0026gt;{{ item.text }}\u0026lt;/el-check-tag\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;div id=\u0026#34;chart\u0026#34; style=\u0026#34;width: 100%;height: 300px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/el-card\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39;; import * as echarts from \u0026#39;echarts\u0026#39;; import { getStatistics3 } from \u0026#34;~/api/index.js\u0026#34; const current = ref(\u0026#34;week\u0026#34;) const options = [{ text: \u0026#34;近1个月\u0026#34;, value: \u0026#34;month\u0026#34; }, { text: \u0026#34;近1周\u0026#34;, value: \u0026#34;week\u0026#34; }, { text: \u0026#34;近24小时\u0026#34;, value: \u0026#34;hour\u0026#34; }] const handleChoose = (type) =\u0026gt; { current.value = type; getData(); } var myChart = null onMounted(() =\u0026gt; { var chartDom = document.getElementById(\u0026#39;chart\u0026#39;); myChart = echarts.init(chartDom); getData() }) function getData() { var option; option = { xAxis: { type: \u0026#39;category\u0026#39;, data: [] }, yAxis: { type: \u0026#39;value\u0026#39; }, series: [ { data: [], type: \u0026#39;bar\u0026#39;, showBackground: true, backgroundStyle: { color: \u0026#39;rgba(180, 180, 180, 0.2)\u0026#39; } } ] }; // option \u0026amp;\u0026amp; myChart.setOption(option); myChart.showLoading() getStatistics3(current.value).then(res=\u0026gt;{ option.xAxis.data = res.x option.series[0].data = res.y myChart.setOption(option) }).finally(()=\u0026gt;{ myChart.hideLoading() }) } \u0026lt;/script\u0026gt; loading 动画\nmyChart.showLoading() myChart.hideLoading() 在页面销毁之前释放图表 不然可能出现白屏现象\nhttps://echarts.apache.org/handbook/zh/concepts/chart-size/#%E5%AE%B9%E5%99%A8%E8%8A%82%E7%82%B9%E8%A2%AB%E9%94%80%E6%AF%81%E4%BB%A5%E5%8F%8A%E8%A2%AB%E9%87%8D%E5%BB%BA%E6%97%B6\n假设页面中存在多个标签页，每个标签页都包含一些图表。当选中一个标签页的时候，其他标签页的内容在 DOM 中被移除了。这样，当用户再选中这些标签页的时候，就会发现图表“不见”了。 本质上，这是由于图表的容器节点被移除导致的。即使之后该节点被重新添加，图表所在的节点也已经不存在了。 正确的做法是，在图表容器被销毁之后，调用 echartsInstance.dispose 销毁实例，在图表容器重新被添加后再次调用 echarts.init 初始化。 import { ref, onMounted, onBeforeUnmount } from \u0026#39;vue\u0026#39;; onBeforeUnmount(()=\u0026gt;{ if(myChart) echarts.dispose(myChart) }) 图表跟随画面变化 https://vueuse.org/core/useResizeObserver/#useresizeobserver https://echarts.apache.org/handbook/zh/concepts/chart-size/#%E4%B8%BA%E5%9B%BE%E8%A1%A8%E8%AE%BE%E7%BD%AE%E7%89%B9%E5%AE%9A%E7%9A%84%E5%A4%A7%E5%B0%8F \u0026lt;div ref=\u0026#34;el\u0026#34; id=\u0026#34;chart\u0026#34; style=\u0026#34;width: 100%;height: 300px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script setup\u0026gt; import { useResizeObserver } from \u0026#39;@vueuse/core\u0026#39;; const el = ref(null); useResizeObserver(el, (entries) =\u0026gt; { const entry = entries[0]; const { width, height } = entry.contentRect; myChart.resize({ width, height }); }); \u0026lt;/script\u0026gt; 页面变化监听 //使用防抖 (setTimeout定时器) const getWindowInfo = () =\u0026gt; { const windowInfo = { width: window.innerWidth, hight: window.innerHeight } }; const debounce = (fn, delay) =\u0026gt; { let timer; return function() { if (timer) { clearTimeout(timer); } timer = setTimeout(() =\u0026gt; { fn(); }, delay); } }; //触发事件 触发时间（指定时间内执行事件） const cancalDebounce = debounce(getWindowInfo, 500); window.addEventListener(\u0026#39;resize\u0026#39;, cancalDebounce); // vue3 使用生命周期销毁钩子 onUnmounted(() =\u0026gt; { console.log(\u0026#39;onUnmounted\u0026#39;,\u0026#39;打印是否生效\u0026#39;); //移除监听事件 window.removeEventListener(\u0026#39;resize\u0026#39;, cancalDebounce); }) 样例\n\u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;el\u0026#34;\u0026gt; \u0026lt;el-container class=\u0026#34;bg-white rounded\u0026#34; :style=\u0026#34;{ height: h + \u0026#39;px\u0026#39; }\u0026#34;\u0026gt; \u0026lt;el-header\u0026gt;Header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;Aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { watch, ref, onUnmounted } from \u0026#39;vue\u0026#39;; import { useResizeObserver } from \u0026#39;@vueuse/core\u0026#39;; // 获取屏幕高度 let windowHeight = window.innerHeight || document.documentElement.clientHeight // 计算表格高度: 屏幕高度 - 头部高度 - 页签高度 - padding const h = ref(windowHeight - 60 - 44 - 40); //使用防抖 (setTimeout定时器) const getWindowInfo = () =\u0026gt; { const windowInfo = { width: window.innerWidth, hight: window.innerHeight } // 改变 h 的值 h.value = windowInfo.hight - 60 - 44 - 40; }; const debounce = (fn, delay) =\u0026gt; { let timer; return function () { if (timer) { clearTimeout(timer); } timer = setTimeout(() =\u0026gt; { fn(); }, delay); } }; // 触发事件 触发时间（指定时间内执行事件） const cancalDebounce = debounce(getWindowInfo, 500); window.addEventListener(\u0026#39;resize\u0026#39;, cancalDebounce); // 销毁监听 onUnmounted(() =\u0026gt; { //移除监听事件 window.removeEventListener(\u0026#39;resize\u0026#39;, cancalDebounce); }); \u0026lt;/script\u0026gt; ","permalink":"https://waite.wang/posts/project/vite-shopmall-project-begin/","summary":"\u003ch2 id=\"创建vite项目并安装vscode插件\"\u003e创建vite项目并安装vscode插件\u003c/h2\u003e\n\u003ch3 id=\"vite\"\u003eVite\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eVite 是一个 web 开发构建工具，由于其原生 ES 模块导入方式，可以实现闪电般的冷服务器启动.通过在终端中运行以下命令，可以使用 Vite 快速构建 Vue 项目\u003c/strong\u003e\u003c/p\u003e","title":"Vite B端后台管理起始项"},{"content":"一、API V2 接口说明 接口基准地址：http://www.tangxiaoyang.vip:8888/api/v2/\n服务端已开启 CORS 跨域支持\nAPI V2 认证统一使用 Token 认证\n需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌\n使用 HTTP Status Code 标识状态\n数据返回格式统一使用 JSON\n1. 支持的请求方法 GET（SELECT）：从服务器取出资源（一项或多项）。\nPOST（CREATE）：在服务器新建一个资源。\nPUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\nPATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\nDELETE（DELETE）：从服务器删除资源。\nHEAD：获取资源的元数据。\nOPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n2. 通用返回状态说明 状态码 含义 说明 200 OK 请求成功 201 CREATED 创建成功 204 DELETED 删除成功 400 BAD REQUEST 请求的地址不存在或者包含不支持的参数 401 UNAUTHORIZED 未授权 403 FORBIDDEN 被禁止访问 404 NOT FOUND 请求的资源不存在 422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 内部错误 二、登录 1. 登录验证接口 请求路径：login\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名 不能为空 password 密码 不能为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 token 令牌 基于 jwt 的令牌 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 500, \u0026#34;rid\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@qq.com\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;登录成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 三、用户管理 1. 用户数据列表 请求路径：users\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总记录数 pagenum 当前页码 users 用户数据集合 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;pagenum\u0026#34;: 1, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: 25, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;13951783475\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;email\u0026#34;: \u0026#34;1049901079@qq.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-09T20:36:26.000Z\u0026#34;, \u0026#34;mg_state\u0026#34;: true, // 当前用户的状态 \u0026#34;role_name\u0026#34;: \u0026#34;超级管理员\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加用户 请求路径：users\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名称 不能为空 password 用户密码 不能为空 email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 28, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;openid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@test.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-10T03:47:13.533Z\u0026#34;, \u0026#34;modify_time\u0026#34;: null, \u0026#34;is_delete\u0026#34;: false, \u0026#34;is_active\u0026#34;: false }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;用户创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 修改用户状态 请求路径：users/:uId/state/:type\n请求方法：put\n请求参数\n参数名 参数说明 备注 uId 用户 ID 不能为空携带在url中 type 用户状态 不能为空携带在url中，值为 true 或者 false 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 566, \u0026#34;rid\u0026#34;: 30, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;bb@itany.com\u0026#34;, \u0026#34;mg_state\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置状态成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 根据 ID 查询用户信息 请求路径：users/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;00000\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;new@new.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;查询成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 编辑提交用户 请求路径：users/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空 参数是url参数:id email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 /* 200表示成功，500表示失败 */ { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;111\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@123.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 删除单个用户 请求路径：users/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空参数是url参数:id 响应参数\n响应数据\n{ \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 分配用户角色 请求路径：users/:id/role\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空参数是url参数:id rid 角色 id 不能为空参数body参数 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 508, \u0026#34;rid\u0026#34;: \u0026#34;30\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;asdf1\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;adfsa@qq.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置角色成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 四、权限管理 1. 所有权限列表 请求路径：rights/:type\n请求方法：get\n请求参数\n参数名 参数说明 备注 type 类型 值 list 或 tree , list 列表显示权限, tree 树状显示权限,参数是url参数:type 响应参数 参数名 参数说明 备注 id 权限 ID authName 权限说明 level 权限层级 pid 权限父 ID path 对应访问路径 响应数据 type=list { \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 102, \u0026#34;authName\u0026#34;: \u0026#34;订单管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取权限列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } type=tree\n{ data: [ { id: 101, authName: \u0026#39;商品管理\u0026#39;, path: null, pid: 0, children: [ { id: 104, authName: \u0026#39;商品列表\u0026#39;, path: null, pid: 101, children: [ { id: 105, authName: \u0026#39;添加商品\u0026#39;, path: null, pid: \u0026#39;104,101\u0026#39; } ] } ] } ], meta: { msg: \u0026#39;获取权限列表成功\u0026#39;, status: 200 } } 2. 左侧菜单权限 请求路径：menus\n请求方法：get\n响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [] } ] } \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取菜单列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 五、角色管理 1. 角色列表 请求路径：roles\n请求方法：get\n响应数据说明\n第一层为角色信息\n第二层开始为权限说明，权限一共有 3 层权限\n最后一层权限，不包含 children 属性\n响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 30, \u0026#34;roleName\u0026#34;: \u0026#34;主管\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;技术负责人\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加角色 请求路径：roles\n请求方法：post\n请求参数\n参数名 参数说明 备注 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 40, \u0026#34;roleName\u0026#34;: \u0026#34;admin2\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;admin2Desc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询角色 请求路径：roles/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试负责人\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交角色 请求路径：roles/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试角色描述\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除角色 请求路径：roles/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 角色授权 请求路径：roles/:roleId/rights\n请求方法：post\n请求参数：通过 请求体 发送给后端\n参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 rids 权限 ID 列表（字符串） 以 , 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点） 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 删除角色指定权限 请求路径：roles/:roleId/rights/:rightId\n请求方法：delete\n请求参数 参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 :rightId 权限 ID 不能为空携带在url中\n响应数据说明\n返回的data, 是当前角色下最新的权限数据 响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 116, \u0026#34;authName\u0026#34;: \u0026#34;修改\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;取消权限成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 六、商品分类管理 1. 商品分类数据列表 请求路径：categories\n请求方法：get\n请求参数\n参数名 参数说明 备注 type [1,2,3] 值：1，2，3 分别表示显示一层二层三层分类列表 【可选参数】如果不传递，则默认获取所有级别的分类 pagenum 当前页码值 【可选参数】如果不传递，则默认获取所有分类 pagesize 每页显示多少条数据 【可选参数】如果不传递，则默认获取所有分类 响应参数 参数名 参数说明 备注 cat_id 分类 ID cat_name 分类名称 cat_pid 分类父 ID cat_level 分类当前层级 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 1, \u0026#34;cat_name\u0026#34;: \u0026#34;大家电\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 1, \u0026#34;cat_level\u0026#34;: 1, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 6, \u0026#34;cat_name\u0026#34;: \u0026#34;曲面电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false }, { \u0026#34;cat_id\u0026#34;: 7, \u0026#34;cat_name\u0026#34;: \u0026#34;海信\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加分类 请求路径：categories\n请求方法：post\n请求参数\n参数名 参数说明 备注 cat_pid 分类父 ID 不能为空，如果要添加一级分类，则父分类Id应该设置为 0 cat_name 分类名称 不能为空 cat_level 分类层级 不能为空，0表示一级分类；1表示二级分类；2表示三级分类 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 62, \u0026#34;cat_name\u0026#34;: \u0026#34;相框\u0026#34;, \u0026#34;cat_pid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;cat_level\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 id 查询分类 请求路径：categories/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;厨卫电器\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交分类 请求路径：categories/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 cat_name 分类名称 不能为空【此参数，放到请求体中】 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 22, \u0026#34;cat_name\u0026#34;: \u0026#34;自拍杆\u0026#34;, \u0026#34;cat_pid\u0026#34;: 7, \u0026#34;cat_level\u0026#34;: 2 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除分类 请求路径：categories/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 七、分类参数管理 1. 参数列表 请求路径：categories/:id/attributes\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 sel many或only 不能为空，many表示动态参数，only表示静态参数（也称为静态属性） 响应参数 参数名 参数说明 备注 attr_id 分类参数 ID attr_name 分类参数名称 cat_id 分类参数所属分类 attr_sel 分类参数的类型，many表示动态参数，only表示静态属性 attr_write list表示从列表选择（动态参数），manual表示手工录入（静态属性） attr_vals 分类参数的明细，如果是动态参数，则该值是以空格分隔的字符串 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;4K高清 5K高清 6K高清\u0026#34; } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加动态参数或静态属性 请求路径：categories/:id/attributes\n请求方法：post\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 attr_name 参数名称 不能为空 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 44, \u0026#34;attr_name\u0026#34;: \u0026#34;测试参数\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;a,b,c\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询参数 请求路径：categories/:id/attributes/:attrId\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 属性 ID 不能为空携带在url中 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;ffff\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 更新参数及明细 请求路径：categories/:id/attributes/:attrId\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 参数 ID 不能为空携带在url中 attr_name 参数名称 不能为空，携带在请求体中 attr_sel many或only 不能为空，携带在请求体中 attr_vals 参数的明细 可选参数，携带在请求体中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 9, \u0026#34;attr_name\u0026#34;: \u0026#34;测试更新\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;43\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;abc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除参数 请求路径： categories/:id/attributes/:attrid\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrid 参数 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 八、商品管理 1. 商品列表数据 请求路径：goods\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 50, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 144, \u0026#34;goods_name\u0026#34;: \u0026#34;iphone\u0026#34;, \u0026#34;goods_price\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 1, \u0026#34;goods_weight\u0026#34;: 1, \u0026#34;goods_state\u0026#34;: null, \u0026#34;add_time\u0026#34;: 1512954923, \u0026#34;upd_time\u0026#34;: 1512954923, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加商品 请求路径：goods\n请求方法：post\n请求参数\n参数名 参数说明 备注 goods_name 商品名称 不能为空 goods_cat 以,逗号分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组），包含 动态参数 和 静态属性 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_cat\u0026#34;: \u0026#34;1,2,3\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;cat_id\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建商品成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询商品 请求路径：goods/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 goods_introduce 介绍 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交商品 请求路径：goods/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 goods_name 商品名称 不能为空 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组） 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新商品成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除商品 请求路径：goods/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品图片\n请求路径：goods/:id/pics\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 pics 商品图片集合 如果有 pics_id 字段会保留该图片，如果没有 pics_id 但是有 pic 字段就会新生成图片数据 请求数据 ;[ { pic: \u0026#39;tmp_uploads/db28f6316835836e97653b5c75e418be.png\u0026#39; }, { pics_id: 397, goods_id: 145, pics_big: \u0026#39;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_mid: \u0026#39;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_sma: \u0026#39;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品属性\n请求路径：goods/:id/attributes\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 请求数据 ;[ { attr_id: 15, attr_value: \u0026#39;ddd\u0026#39; }, { attr_id: 15, attr_value: \u0026#39;eee\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###商品图片处理必须安装 GraphicsMagick\nlinux apt-get install GraphicsMagick Mac OS X brew install GraphicsMagick Windows 点击下载 6. 图片上传 请求路径：upload\n请求方法：post\n请求参数\n参数名 参数说明 备注 file 上传文件 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;tmp_path\u0026#34;: \u0026#34;tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://127.0.0.1:8888tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;上传成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 九、订单管理 1. 订单数据列表 请求路径：orders\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 可以为空，默认为1 pagesize 每页显示条数 可以为空，省略时返回所有订单 user_id 用户 ID 可以为空 pay_status 支付状态 可以为空 is_send 是否发货 可以为空 order_fapiao_title [\u0026lsquo;个人\u0026rsquo;,\u0026lsquo;公司\u0026rsquo;] 可以为空 order_fapiao_company 公司名称 可以为空 order_fapiao_content 发票内容 可以为空 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;order_id\u0026#34;: 47, \u0026#34;user_id\u0026#34;: 133, \u0026#34;order_number\u0026#34;: \u0026#34;59e7502d7993d\u0026#34;, \u0026#34;order_price\u0026#34;: 322, \u0026#34;order_pay\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;是\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;办公用品\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;江苏省南京市秦淮区龙蟠中路666号\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;create_time\u0026#34;: 1508331565, \u0026#34;update_time\u0026#34;: 1508331565 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 修改订单状态 请求路径：orders/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 is_send 订单是否发货 1:已经发货，0:未发货 order_pay 订单支付 支付方式 0 未支付 1 支付宝 2 微信 3 银行卡 order_price 订单价格 order_number 订单数量 pay_status 支付状态 订单状态： 0 未付款、1 已付款 请求数据说明\n所有请求数据都是增量更新，如果参数不填写，就不会更新该字段 响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 3. 查看订单详情 请求路径：orders/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 修改地址 请求路径：orders/:id/address\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: {}, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;修改地址成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 查看物流信息 请求路径：/kuaidi/:id\n请求方法：get\n物流单号：815294206237577\n响应数据：\n{ \u0026#34;meta\u0026#34;:{ \u0026#34;status\u0026#34;:200, \u0026#34;message\u0026#34;:\u0026#34;获取物流信息成功！\u0026#34; }, \u0026#34;data\u0026#34;:[ { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已签收,签收人是 汤小洋 先生/女士，如有疑问请联系派件员阿奇(13805148888)，如您未收到此快递，请拨打投诉电话：15294207777，感谢使用申通快递，期待再次为您服务\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东寒亭营业厅-寒亭阿奇(13805148888)-派件中\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东寒亭公司\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏苏州转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏南京转运中心-已发往-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-城东汪小主宠物店-已收件\u0026#34;, \u0026#34;location\u0026#34;:null } ] } 一、API V2 接口说明 接口基准地址：http://www.tangxiaoyang.vip:8888/api/v2/\n服务端已开启 CORS 跨域支持\nAPI V2 认证统一使用 Token 认证\n需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌\n使用 HTTP Status Code 标识状态\n数据返回格式统一使用 JSON\n1. 支持的请求方法 GET（SELECT）：从服务器取出资源（一项或多项）。\nPOST（CREATE）：在服务器新建一个资源。\nPUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\nPATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\nDELETE（DELETE）：从服务器删除资源。\nHEAD：获取资源的元数据。\nOPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n2. 通用返回状态说明 状态码 含义 说明 200 OK 请求成功 201 CREATED 创建成功 204 DELETED 删除成功 400 BAD REQUEST 请求的地址不存在或者包含不支持的参数 401 UNAUTHORIZED 未授权 403 FORBIDDEN 被禁止访问 404 NOT FOUND 请求的资源不存在 422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 内部错误 二、登录 1. 登录验证接口 请求路径：login\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名 不能为空 password 密码 不能为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 token 令牌 基于 jwt 的令牌 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 500, \u0026#34;rid\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@qq.com\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;登录成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 三、用户管理 1. 用户数据列表 请求路径：users\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总记录数 pagenum 当前页码 users 用户数据集合 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;pagenum\u0026#34;: 1, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: 25, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;13951783475\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;email\u0026#34;: \u0026#34;1049901079@qq.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-09T20:36:26.000Z\u0026#34;, \u0026#34;mg_state\u0026#34;: true, // 当前用户的状态 \u0026#34;role_name\u0026#34;: \u0026#34;超级管理员\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加用户 请求路径：users\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名称 不能为空 password 用户密码 不能为空 email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 28, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;openid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@test.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-10T03:47:13.533Z\u0026#34;, \u0026#34;modify_time\u0026#34;: null, \u0026#34;is_delete\u0026#34;: false, \u0026#34;is_active\u0026#34;: false }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;用户创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 修改用户状态 请求路径：users/:uId/state/:type\n请求方法：put\n请求参数\n参数名 参数说明 备注 uId 用户 ID 不能为空携带在url中 type 用户状态 不能为空携带在url中，值为 true 或者 false 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 566, \u0026#34;rid\u0026#34;: 30, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;bb@itany.com\u0026#34;, \u0026#34;mg_state\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置状态成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 根据 ID 查询用户信息 请求路径：users/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;00000\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;new@new.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;查询成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 编辑提交用户 请求路径：users/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空 参数是url参数:id email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 /* 200表示成功，500表示失败 */ { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;111\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@123.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 删除单个用户 请求路径：users/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空参数是url参数:id 响应参数\n响应数据\n{ \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 分配用户角色 请求路径：users/:id/role\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空参数是url参数:id rid 角色 id 不能为空参数body参数 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 508, \u0026#34;rid\u0026#34;: \u0026#34;30\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;asdf1\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;adfsa@qq.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置角色成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 四、权限管理 1. 所有权限列表 请求路径：rights/:type\n请求方法：get\n请求参数\n参数名 参数说明 备注 type 类型 值 list 或 tree , list 列表显示权限, tree 树状显示权限,参数是url参数:type 响应参数 参数名 参数说明 备注 id 权限 ID authName 权限说明 level 权限层级 pid 权限父 ID path 对应访问路径 响应数据 type=list { \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 102, \u0026#34;authName\u0026#34;: \u0026#34;订单管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取权限列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } type=tree\n{ data: [ { id: 101, authName: \u0026#39;商品管理\u0026#39;, path: null, pid: 0, children: [ { id: 104, authName: \u0026#39;商品列表\u0026#39;, path: null, pid: 101, children: [ { id: 105, authName: \u0026#39;添加商品\u0026#39;, path: null, pid: \u0026#39;104,101\u0026#39; } ] } ] } ], meta: { msg: \u0026#39;获取权限列表成功\u0026#39;, status: 200 } } 2. 左侧菜单权限 请求路径：menus\n请求方法：get\n响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [] } ] } \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取菜单列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 五、角色管理 1. 角色列表 请求路径：roles\n请求方法：get\n响应数据说明\n第一层为角色信息\n第二层开始为权限说明，权限一共有 3 层权限\n最后一层权限，不包含 children 属性\n响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 30, \u0026#34;roleName\u0026#34;: \u0026#34;主管\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;技术负责人\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加角色 请求路径：roles\n请求方法：post\n请求参数\n参数名 参数说明 备注 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 40, \u0026#34;roleName\u0026#34;: \u0026#34;admin2\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;admin2Desc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询角色 请求路径：roles/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试负责人\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交角色 请求路径：roles/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试角色描述\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除角色 请求路径：roles/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 角色授权 请求路径：roles/:roleId/rights\n请求方法：post\n请求参数：通过 请求体 发送给后端\n参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 rids 权限 ID 列表（字符串） 以 , 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点） 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 删除角色指定权限 请求路径：roles/:roleId/rights/:rightId\n请求方法：delete\n请求参数 参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 :rightId 权限 ID 不能为空携带在url中\n响应数据说明\n返回的data, 是当前角色下最新的权限数据 响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 116, \u0026#34;authName\u0026#34;: \u0026#34;修改\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;取消权限成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 六、商品分类管理 1. 商品分类数据列表 请求路径：categories\n请求方法：get\n请求参数\n参数名 参数说明 备注 type [1,2,3] 值：1，2，3 分别表示显示一层二层三层分类列表 【可选参数】如果不传递，则默认获取所有级别的分类 pagenum 当前页码值 【可选参数】如果不传递，则默认获取所有分类 pagesize 每页显示多少条数据 【可选参数】如果不传递，则默认获取所有分类 响应参数 参数名 参数说明 备注 cat_id 分类 ID cat_name 分类名称 cat_pid 分类父 ID cat_level 分类当前层级 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 1, \u0026#34;cat_name\u0026#34;: \u0026#34;大家电\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 1, \u0026#34;cat_level\u0026#34;: 1, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 6, \u0026#34;cat_name\u0026#34;: \u0026#34;曲面电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false }, { \u0026#34;cat_id\u0026#34;: 7, \u0026#34;cat_name\u0026#34;: \u0026#34;海信\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加分类 请求路径：categories\n请求方法：post\n请求参数\n参数名 参数说明 备注 cat_pid 分类父 ID 不能为空，如果要添加一级分类，则父分类Id应该设置为 0 cat_name 分类名称 不能为空 cat_level 分类层级 不能为空，0表示一级分类；1表示二级分类；2表示三级分类 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 62, \u0026#34;cat_name\u0026#34;: \u0026#34;相框\u0026#34;, \u0026#34;cat_pid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;cat_level\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 id 查询分类 请求路径：categories/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;厨卫电器\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交分类 请求路径：categories/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 cat_name 分类名称 不能为空【此参数，放到请求体中】 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 22, \u0026#34;cat_name\u0026#34;: \u0026#34;自拍杆\u0026#34;, \u0026#34;cat_pid\u0026#34;: 7, \u0026#34;cat_level\u0026#34;: 2 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除分类 请求路径：categories/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 七、分类参数管理 1. 参数列表 请求路径：categories/:id/attributes\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 sel many或only 不能为空，many表示动态参数，only表示静态参数（也称为静态属性） 响应参数 参数名 参数说明 备注 attr_id 分类参数 ID attr_name 分类参数名称 cat_id 分类参数所属分类 attr_sel 分类参数的类型，many表示动态参数，only表示静态属性 attr_write list表示从列表选择（动态参数），manual表示手工录入（静态属性） attr_vals 分类参数的明细，如果是动态参数，则该值是以空格分隔的字符串 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;4K高清 5K高清 6K高清\u0026#34; } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加动态参数或静态属性 请求路径：categories/:id/attributes\n请求方法：post\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 attr_name 参数名称 不能为空 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 44, \u0026#34;attr_name\u0026#34;: \u0026#34;测试参数\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;a,b,c\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询参数 请求路径：categories/:id/attributes/:attrId\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 属性 ID 不能为空携带在url中 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;ffff\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 更新参数及明细 请求路径：categories/:id/attributes/:attrId\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 参数 ID 不能为空携带在url中 attr_name 参数名称 不能为空，携带在请求体中 attr_sel many或only 不能为空，携带在请求体中 attr_vals 参数的明细 可选参数，携带在请求体中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 9, \u0026#34;attr_name\u0026#34;: \u0026#34;测试更新\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;43\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;abc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除参数 请求路径： categories/:id/attributes/:attrid\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrid 参数 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 八、商品管理 1. 商品列表数据 请求路径：goods\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 50, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 144, \u0026#34;goods_name\u0026#34;: \u0026#34;iphone\u0026#34;, \u0026#34;goods_price\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 1, \u0026#34;goods_weight\u0026#34;: 1, \u0026#34;goods_state\u0026#34;: null, \u0026#34;add_time\u0026#34;: 1512954923, \u0026#34;upd_time\u0026#34;: 1512954923, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加商品 请求路径：goods\n请求方法：post\n请求参数\n参数名 参数说明 备注 goods_name 商品名称 不能为空 goods_cat 以,逗号分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组），包含 动态参数 和 静态属性 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_cat\u0026#34;: \u0026#34;1,2,3\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;cat_id\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建商品成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询商品 请求路径：goods/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 goods_introduce 介绍 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交商品 请求路径：goods/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 goods_name 商品名称 不能为空 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组） 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新商品成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除商品 请求路径：goods/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品图片\n请求路径：goods/:id/pics\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 pics 商品图片集合 如果有 pics_id 字段会保留该图片，如果没有 pics_id 但是有 pic 字段就会新生成图片数据 请求数据 ;[ { pic: \u0026#39;tmp_uploads/db28f6316835836e97653b5c75e418be.png\u0026#39; }, { pics_id: 397, goods_id: 145, pics_big: \u0026#39;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_mid: \u0026#39;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_sma: \u0026#39;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品属性\n请求路径：goods/:id/attributes\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 请求数据 ;[ { attr_id: 15, attr_value: \u0026#39;ddd\u0026#39; }, { attr_id: 15, attr_value: \u0026#39;eee\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###商品图片处理必须安装 GraphicsMagick\nlinux apt-get install GraphicsMagick Mac OS X brew install GraphicsMagick Windows 点击下载 6. 图片上传 请求路径：upload\n请求方法：post\n请求参数\n参数名 参数说明 备注 file 上传文件 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;tmp_path\u0026#34;: \u0026#34;tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://127.0.0.1:8888tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;上传成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 九、订单管理 1. 订单数据列表 请求路径：orders\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 可以为空，默认为1 pagesize 每页显示条数 可以为空，省略时返回所有订单 user_id 用户 ID 可以为空 pay_status 支付状态 可以为空 is_send 是否发货 可以为空 order_fapiao_title [\u0026lsquo;个人\u0026rsquo;,\u0026lsquo;公司\u0026rsquo;] 可以为空 order_fapiao_company 公司名称 可以为空 order_fapiao_content 发票内容 可以为空 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;order_id\u0026#34;: 47, \u0026#34;user_id\u0026#34;: 133, \u0026#34;order_number\u0026#34;: \u0026#34;59e7502d7993d\u0026#34;, \u0026#34;order_price\u0026#34;: 322, \u0026#34;order_pay\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;是\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;办公用品\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;江苏省南京市秦淮区龙蟠中路666号\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;create_time\u0026#34;: 1508331565, \u0026#34;update_time\u0026#34;: 1508331565 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 修改订单状态 请求路径：orders/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 is_send 订单是否发货 1:已经发货，0:未发货 order_pay 订单支付 支付方式 0 未支付 1 支付宝 2 微信 3 银行卡 order_price 订单价格 order_number 订单数量 pay_status 支付状态 订单状态： 0 未付款、1 已付款 请求数据说明\n所有请求数据都是增量更新，如果参数不填写，就不会更新该字段 响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 3. 查看订单详情 请求路径：orders/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 修改地址 请求路径：orders/:id/address\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: {}, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;修改地址成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 查看物流信息 请求路径：/kuaidi/:id\n请求方法：get\n物流单号：815294206237577\n响应数据：\n{ \u0026#34;meta\u0026#34;:{ \u0026#34;status\u0026#34;:200, \u0026#34;message\u0026#34;:\u0026#34;获取物流信息成功！\u0026#34; }, \u0026#34;data\u0026#34;:[ { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已签收,签收人是 汤小洋 先生/女士，如有疑问请联系派件员阿奇(13805148888)，如您未收到此快递，请拨打投诉电话：15294207777，感谢使用申通快递，期待再次为您服务\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东寒亭营业厅-寒亭阿奇(13805148888)-派件中\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东寒亭公司\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏苏州转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏南京转运中心-已发往-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-城东汪小主宠物店-已收件\u0026#34;, \u0026#34;location\u0026#34;:null } ] } 一、API V2 接口说明 接口基准地址：http://www.tangxiaoyang.vip:8888/api/v2/\n服务端已开启 CORS 跨域支持\nAPI V2 认证统一使用 Token 认证\n需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌\n使用 HTTP Status Code 标识状态\n数据返回格式统一使用 JSON\n1. 支持的请求方法 GET（SELECT）：从服务器取出资源（一项或多项）。\nPOST（CREATE）：在服务器新建一个资源。\nPUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\nPATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\nDELETE（DELETE）：从服务器删除资源。\nHEAD：获取资源的元数据。\nOPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n2. 通用返回状态说明 状态码 含义 说明 200 OK 请求成功 201 CREATED 创建成功 204 DELETED 删除成功 400 BAD REQUEST 请求的地址不存在或者包含不支持的参数 401 UNAUTHORIZED 未授权 403 FORBIDDEN 被禁止访问 404 NOT FOUND 请求的资源不存在 422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 内部错误 二、登录 1. 登录验证接口 请求路径：login\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名 不能为空 password 密码 不能为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 token 令牌 基于 jwt 的令牌 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 500, \u0026#34;rid\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@qq.com\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;登录成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 三、用户管理 1. 用户数据列表 请求路径：users\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总记录数 pagenum 当前页码 users 用户数据集合 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;pagenum\u0026#34;: 1, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: 25, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;13951783475\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;email\u0026#34;: \u0026#34;1049901079@qq.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-09T20:36:26.000Z\u0026#34;, \u0026#34;mg_state\u0026#34;: true, // 当前用户的状态 \u0026#34;role_name\u0026#34;: \u0026#34;超级管理员\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加用户 请求路径：users\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名称 不能为空 password 用户密码 不能为空 email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 28, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;openid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@test.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-10T03:47:13.533Z\u0026#34;, \u0026#34;modify_time\u0026#34;: null, \u0026#34;is_delete\u0026#34;: false, \u0026#34;is_active\u0026#34;: false }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;用户创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 修改用户状态 请求路径：users/:uId/state/:type\n请求方法：put\n请求参数\n参数名 参数说明 备注 uId 用户 ID 不能为空携带在url中 type 用户状态 不能为空携带在url中，值为 true 或者 false 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 566, \u0026#34;rid\u0026#34;: 30, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;bb@itany.com\u0026#34;, \u0026#34;mg_state\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置状态成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 根据 ID 查询用户信息 请求路径：users/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;00000\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;new@new.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;查询成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 编辑提交用户 请求路径：users/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空 参数是url参数:id email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 /* 200表示成功，500表示失败 */ { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;111\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@123.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 删除单个用户 请求路径：users/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空参数是url参数:id 响应参数\n响应数据\n{ \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 分配用户角色 请求路径：users/:id/role\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空参数是url参数:id rid 角色 id 不能为空参数body参数 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 508, \u0026#34;rid\u0026#34;: \u0026#34;30\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;asdf1\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;adfsa@qq.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置角色成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 四、权限管理 1. 所有权限列表 请求路径：rights/:type\n请求方法：get\n请求参数\n参数名 参数说明 备注 type 类型 值 list 或 tree , list 列表显示权限, tree 树状显示权限,参数是url参数:type 响应参数 参数名 参数说明 备注 id 权限 ID authName 权限说明 level 权限层级 pid 权限父 ID path 对应访问路径 响应数据 type=list { \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 102, \u0026#34;authName\u0026#34;: \u0026#34;订单管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取权限列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } type=tree\n{ data: [ { id: 101, authName: \u0026#39;商品管理\u0026#39;, path: null, pid: 0, children: [ { id: 104, authName: \u0026#39;商品列表\u0026#39;, path: null, pid: 101, children: [ { id: 105, authName: \u0026#39;添加商品\u0026#39;, path: null, pid: \u0026#39;104,101\u0026#39; } ] } ] } ], meta: { msg: \u0026#39;获取权限列表成功\u0026#39;, status: 200 } } 2. 左侧菜单权限 请求路径：menus\n请求方法：get\n响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [] } ] } \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取菜单列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 五、角色管理 1. 角色列表 请求路径：roles\n请求方法：get\n响应数据说明\n第一层为角色信息\n第二层开始为权限说明，权限一共有 3 层权限\n最后一层权限，不包含 children 属性\n响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 30, \u0026#34;roleName\u0026#34;: \u0026#34;主管\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;技术负责人\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加角色 请求路径：roles\n请求方法：post\n请求参数\n参数名 参数说明 备注 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 40, \u0026#34;roleName\u0026#34;: \u0026#34;admin2\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;admin2Desc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询角色 请求路径：roles/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试负责人\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交角色 请求路径：roles/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试角色描述\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除角色 请求路径：roles/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 角色授权 请求路径：roles/:roleId/rights\n请求方法：post\n请求参数：通过 请求体 发送给后端\n参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 rids 权限 ID 列表（字符串） 以 , 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点） 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 删除角色指定权限 请求路径：roles/:roleId/rights/:rightId\n请求方法：delete\n请求参数 参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 :rightId 权限 ID 不能为空携带在url中\n响应数据说明\n返回的data, 是当前角色下最新的权限数据 响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 116, \u0026#34;authName\u0026#34;: \u0026#34;修改\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;取消权限成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 六、商品分类管理 1. 商品分类数据列表 请求路径：categories\n请求方法：get\n请求参数\n参数名 参数说明 备注 type [1,2,3] 值：1，2，3 分别表示显示一层二层三层分类列表 【可选参数】如果不传递，则默认获取所有级别的分类 pagenum 当前页码值 【可选参数】如果不传递，则默认获取所有分类 pagesize 每页显示多少条数据 【可选参数】如果不传递，则默认获取所有分类 响应参数 参数名 参数说明 备注 cat_id 分类 ID cat_name 分类名称 cat_pid 分类父 ID cat_level 分类当前层级 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 1, \u0026#34;cat_name\u0026#34;: \u0026#34;大家电\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 1, \u0026#34;cat_level\u0026#34;: 1, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 6, \u0026#34;cat_name\u0026#34;: \u0026#34;曲面电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false }, { \u0026#34;cat_id\u0026#34;: 7, \u0026#34;cat_name\u0026#34;: \u0026#34;海信\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加分类 请求路径：categories\n请求方法：post\n请求参数\n参数名 参数说明 备注 cat_pid 分类父 ID 不能为空，如果要添加一级分类，则父分类Id应该设置为 0 cat_name 分类名称 不能为空 cat_level 分类层级 不能为空，0表示一级分类；1表示二级分类；2表示三级分类 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 62, \u0026#34;cat_name\u0026#34;: \u0026#34;相框\u0026#34;, \u0026#34;cat_pid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;cat_level\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 id 查询分类 请求路径：categories/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;厨卫电器\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交分类 请求路径：categories/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 cat_name 分类名称 不能为空【此参数，放到请求体中】 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 22, \u0026#34;cat_name\u0026#34;: \u0026#34;自拍杆\u0026#34;, \u0026#34;cat_pid\u0026#34;: 7, \u0026#34;cat_level\u0026#34;: 2 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除分类 请求路径：categories/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 七、分类参数管理 1. 参数列表 请求路径：categories/:id/attributes\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 sel many或only 不能为空，many表示动态参数，only表示静态参数（也称为静态属性） 响应参数 参数名 参数说明 备注 attr_id 分类参数 ID attr_name 分类参数名称 cat_id 分类参数所属分类 attr_sel 分类参数的类型，many表示动态参数，only表示静态属性 attr_write list表示从列表选择（动态参数），manual表示手工录入（静态属性） attr_vals 分类参数的明细，如果是动态参数，则该值是以空格分隔的字符串 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;4K高清 5K高清 6K高清\u0026#34; } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加动态参数或静态属性 请求路径：categories/:id/attributes\n请求方法：post\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 attr_name 参数名称 不能为空 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 44, \u0026#34;attr_name\u0026#34;: \u0026#34;测试参数\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;a,b,c\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询参数 请求路径：categories/:id/attributes/:attrId\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 属性 ID 不能为空携带在url中 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;ffff\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 更新参数及明细 请求路径：categories/:id/attributes/:attrId\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 参数 ID 不能为空携带在url中 attr_name 参数名称 不能为空，携带在请求体中 attr_sel many或only 不能为空，携带在请求体中 attr_vals 参数的明细 可选参数，携带在请求体中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 9, \u0026#34;attr_name\u0026#34;: \u0026#34;测试更新\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;43\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;abc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除参数 请求路径： categories/:id/attributes/:attrid\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrid 参数 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 八、商品管理 1. 商品列表数据 请求路径：goods\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 50, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 144, \u0026#34;goods_name\u0026#34;: \u0026#34;iphone\u0026#34;, \u0026#34;goods_price\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 1, \u0026#34;goods_weight\u0026#34;: 1, \u0026#34;goods_state\u0026#34;: null, \u0026#34;add_time\u0026#34;: 1512954923, \u0026#34;upd_time\u0026#34;: 1512954923, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加商品 请求路径：goods\n请求方法：post\n请求参数\n参数名 参数说明 备注 goods_name 商品名称 不能为空 goods_cat 以,逗号分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组），包含 动态参数 和 静态属性 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_cat\u0026#34;: \u0026#34;1,2,3\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;cat_id\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建商品成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询商品 请求路径：goods/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 goods_introduce 介绍 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交商品 请求路径：goods/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 goods_name 商品名称 不能为空 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组） 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新商品成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除商品 请求路径：goods/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品图片\n请求路径：goods/:id/pics\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 pics 商品图片集合 如果有 pics_id 字段会保留该图片，如果没有 pics_id 但是有 pic 字段就会新生成图片数据 请求数据 ;[ { pic: \u0026#39;tmp_uploads/db28f6316835836e97653b5c75e418be.png\u0026#39; }, { pics_id: 397, goods_id: 145, pics_big: \u0026#39;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_mid: \u0026#39;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_sma: \u0026#39;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品属性\n请求路径：goods/:id/attributes\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 请求数据 ;[ { attr_id: 15, attr_value: \u0026#39;ddd\u0026#39; }, { attr_id: 15, attr_value: \u0026#39;eee\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###商品图片处理必须安装 GraphicsMagick\nlinux apt-get install GraphicsMagick Mac OS X brew install GraphicsMagick Windows 点击下载 6. 图片上传 请求路径：upload\n请求方法：post\n请求参数\n参数名 参数说明 备注 file 上传文件 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;tmp_path\u0026#34;: \u0026#34;tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://127.0.0.1:8888tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;上传成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 九、订单管理 1. 订单数据列表 请求路径：orders\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 可以为空，默认为1 pagesize 每页显示条数 可以为空，省略时返回所有订单 user_id 用户 ID 可以为空 pay_status 支付状态 可以为空 is_send 是否发货 可以为空 order_fapiao_title [\u0026lsquo;个人\u0026rsquo;,\u0026lsquo;公司\u0026rsquo;] 可以为空 order_fapiao_company 公司名称 可以为空 order_fapiao_content 发票内容 可以为空 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;order_id\u0026#34;: 47, \u0026#34;user_id\u0026#34;: 133, \u0026#34;order_number\u0026#34;: \u0026#34;59e7502d7993d\u0026#34;, \u0026#34;order_price\u0026#34;: 322, \u0026#34;order_pay\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;是\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;办公用品\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;江苏省南京市秦淮区龙蟠中路666号\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;create_time\u0026#34;: 1508331565, \u0026#34;update_time\u0026#34;: 1508331565 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 修改订单状态 请求路径：orders/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 is_send 订单是否发货 1:已经发货，0:未发货 order_pay 订单支付 支付方式 0 未支付 1 支付宝 2 微信 3 银行卡 order_price 订单价格 order_number 订单数量 pay_status 支付状态 订单状态： 0 未付款、1 已付款 请求数据说明\n所有请求数据都是增量更新，如果参数不填写，就不会更新该字段 响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 3. 查看订单详情 请求路径：orders/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 修改地址 请求路径：orders/:id/address\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: {}, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;修改地址成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 查看物流信息 请求路径：/kuaidi/:id\n请求方法：get\n物流单号：815294206237577\n响应数据：\n{ \u0026#34;meta\u0026#34;:{ \u0026#34;status\u0026#34;:200, \u0026#34;message\u0026#34;:\u0026#34;获取物流信息成功！\u0026#34; }, \u0026#34;data\u0026#34;:[ { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已签收,签收人是 汤小洋 先生/女士，如有疑问请联系派件员阿奇(13805148888)，如您未收到此快递，请拨打投诉电话：15294207777，感谢使用申通快递，期待再次为您服务\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东寒亭营业厅-寒亭阿奇(13805148888)-派件中\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东寒亭公司\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏苏州转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏南京转运中心-已发往-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-城东汪小主宠物店-已收件\u0026#34;, \u0026#34;location\u0026#34;:null } ] } 一、API V2 接口说明 接口基准地址：http://www.tangxiaoyang.vip:8888/api/v2/\n服务端已开启 CORS 跨域支持\nAPI V2 认证统一使用 Token 认证\n需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌\n使用 HTTP Status Code 标识状态\n数据返回格式统一使用 JSON\n1. 支持的请求方法 GET（SELECT）：从服务器取出资源（一项或多项）。\nPOST（CREATE）：在服务器新建一个资源。\nPUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\nPATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\nDELETE（DELETE）：从服务器删除资源。\nHEAD：获取资源的元数据。\nOPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n2. 通用返回状态说明 状态码 含义 说明 200 OK 请求成功 201 CREATED 创建成功 204 DELETED 删除成功 400 BAD REQUEST 请求的地址不存在或者包含不支持的参数 401 UNAUTHORIZED 未授权 403 FORBIDDEN 被禁止访问 404 NOT FOUND 请求的资源不存在 422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 内部错误 二、登录 1. 登录验证接口 请求路径：login\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名 不能为空 password 密码 不能为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 token 令牌 基于 jwt 的令牌 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 500, \u0026#34;rid\u0026#34;: 0, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@qq.com\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;登录成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 三、用户管理 1. 用户数据列表 请求路径：users\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总记录数 pagenum 当前页码 users 用户数据集合 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 5, \u0026#34;pagenum\u0026#34;: 1, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: 25, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;13951783475\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;email\u0026#34;: \u0026#34;1049901079@qq.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-09T20:36:26.000Z\u0026#34;, \u0026#34;mg_state\u0026#34;: true, // 当前用户的状态 \u0026#34;role_name\u0026#34;: \u0026#34;超级管理员\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加用户 请求路径：users\n请求方法：post\n请求参数\n参数名 参数说明 备注 username 用户名称 不能为空 password 用户密码 不能为空 email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID rid 用户角色 ID username 用户名 mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 28, \u0026#34;username\u0026#34;: \u0026#34;tom\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;type\u0026#34;: 1, \u0026#34;openid\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;test@test.com\u0026#34;, \u0026#34;create_time\u0026#34;: \u0026#34;2020-11-10T03:47:13.533Z\u0026#34;, \u0026#34;modify_time\u0026#34;: null, \u0026#34;is_delete\u0026#34;: false, \u0026#34;is_active\u0026#34;: false }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;用户创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 修改用户状态 请求路径：users/:uId/state/:type\n请求方法：put\n请求参数\n参数名 参数说明 备注 uId 用户 ID 不能为空携带在url中 type 用户状态 不能为空携带在url中，值为 true 或者 false 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 566, \u0026#34;rid\u0026#34;: 30, \u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123456\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;bb@itany.com\u0026#34;, \u0026#34;mg_state\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置状态成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 根据 ID 查询用户信息 请求路径：users/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;00000\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;new@new.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;查询成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 编辑提交用户 请求路径：users/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空 参数是url参数:id email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 /* 200表示成功，500表示失败 */ { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 503, \u0026#34;username\u0026#34;: \u0026#34;admin3\u0026#34;, \u0026#34;role_id\u0026#34;: 0, \u0026#34;mobile\u0026#34;: \u0026#34;111\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;123@123.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 删除单个用户 请求路径：users/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 用户 id 不能为空参数是url参数:id 响应参数\n响应数据\n{ \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 分配用户角色 请求路径：users/:id/role\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 用户 ID 不能为空参数是url参数:id rid 角色 id 不能为空参数body参数 响应参数 参数名 参数说明 备注 id 用户 ID role_id 角色 ID mobile 手机号 email 邮箱 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 508, \u0026#34;rid\u0026#34;: \u0026#34;30\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;asdf1\u0026#34;, \u0026#34;mobile\u0026#34;: \u0026#34;123123\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;adfsa@qq.com\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;设置角色成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 四、权限管理 1. 所有权限列表 请求路径：rights/:type\n请求方法：get\n请求参数\n参数名 参数说明 备注 type 类型 值 list 或 tree , list 列表显示权限, tree 树状显示权限,参数是url参数:type 响应参数 参数名 参数说明 备注 id 权限 ID authName 权限说明 level 权限层级 pid 权限父 ID path 对应访问路径 响应数据 type=list { \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 102, \u0026#34;authName\u0026#34;: \u0026#34;订单管理\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;pid\u0026#34;: 0, \u0026#34;path\u0026#34;: null } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取权限列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } type=tree\n{ data: [ { id: 101, authName: \u0026#39;商品管理\u0026#39;, path: null, pid: 0, children: [ { id: 104, authName: \u0026#39;商品列表\u0026#39;, path: null, pid: 101, children: [ { id: 105, authName: \u0026#39;添加商品\u0026#39;, path: null, pid: \u0026#39;104,101\u0026#39; } ] } ] } ], meta: { msg: \u0026#39;获取权限列表成功\u0026#39;, status: 200 } } 2. 左侧菜单权限 请求路径：menus\n请求方法：get\n响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [] } ] } \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取菜单列表成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 五、角色管理 1. 角色列表 请求路径：roles\n请求方法：get\n响应数据说明\n第一层为角色信息\n第二层开始为权限说明，权限一共有 3 层权限\n最后一层权限，不包含 children 属性\n响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 30, \u0026#34;roleName\u0026#34;: \u0026#34;主管\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;技术负责人\u0026#34;, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加角色 请求路径：roles\n请求方法：post\n请求参数\n参数名 参数说明 备注 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 40, \u0026#34;roleName\u0026#34;: \u0026#34;admin2\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;admin2Desc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询角色 请求路径：roles/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 roleId 角色 ID roleName 角色名称 roleDesc 角色描述 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试负责人\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交角色 请求路径：roles/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;roleId\u0026#34;: 31, \u0026#34;roleName\u0026#34;: \u0026#34;测试角色\u0026#34;, \u0026#34;roleDesc\u0026#34;: \u0026#34;测试角色描述\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除角色 请求路径：roles/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 6. 角色授权 请求路径：roles/:roleId/rights\n请求方法：post\n请求参数：通过 请求体 发送给后端\n参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 rids 权限 ID 列表（字符串） 以 , 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点） 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 7. 删除角色指定权限 请求路径：roles/:roleId/rights/:rightId\n请求方法：delete\n请求参数 参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 :rightId 权限 ID 不能为空携带在url中\n响应数据说明\n返回的data, 是当前角色下最新的权限数据 响应数据\n{ \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 101, \u0026#34;authName\u0026#34;: \u0026#34;商品管理\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 104, \u0026#34;authName\u0026#34;: \u0026#34;商品列表\u0026#34;, \u0026#34;path\u0026#34;: null, \u0026#34;children\u0026#34;: [ { \u0026#34;id\u0026#34;: 105, \u0026#34;authName\u0026#34;: \u0026#34;添加商品\u0026#34;, \u0026#34;path\u0026#34;: null }, { \u0026#34;id\u0026#34;: 116, \u0026#34;authName\u0026#34;: \u0026#34;修改\u0026#34;, \u0026#34;path\u0026#34;: null } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;取消权限成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 六、商品分类管理 1. 商品分类数据列表 请求路径：categories\n请求方法：get\n请求参数\n参数名 参数说明 备注 type [1,2,3] 值：1，2，3 分别表示显示一层二层三层分类列表 【可选参数】如果不传递，则默认获取所有级别的分类 pagenum 当前页码值 【可选参数】如果不传递，则默认获取所有分类 pagesize 每页显示多少条数据 【可选参数】如果不传递，则默认获取所有分类 响应参数 参数名 参数说明 备注 cat_id 分类 ID cat_name 分类名称 cat_pid 分类父 ID cat_level 分类当前层级 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 1, \u0026#34;cat_name\u0026#34;: \u0026#34;大家电\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 1, \u0026#34;cat_level\u0026#34;: 1, \u0026#34;cat_deleted\u0026#34;: false, \u0026#34;children\u0026#34;: [ { \u0026#34;cat_id\u0026#34;: 6, \u0026#34;cat_name\u0026#34;: \u0026#34;曲面电视\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false }, { \u0026#34;cat_id\u0026#34;: 7, \u0026#34;cat_name\u0026#34;: \u0026#34;海信\u0026#34;, \u0026#34;cat_pid\u0026#34;: 3, \u0026#34;cat_level\u0026#34;: 2, \u0026#34;cat_deleted\u0026#34;: false } ] } ] } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加分类 请求路径：categories\n请求方法：post\n请求参数\n参数名 参数说明 备注 cat_pid 分类父 ID 不能为空，如果要添加一级分类，则父分类Id应该设置为 0 cat_name 分类名称 不能为空 cat_level 分类层级 不能为空，0表示一级分类；1表示二级分类；2表示三级分类 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 62, \u0026#34;cat_name\u0026#34;: \u0026#34;相框\u0026#34;, \u0026#34;cat_pid\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;cat_level\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 id 查询分类 请求路径：categories/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 3, \u0026#34;cat_name\u0026#34;: \u0026#34;厨卫电器\u0026#34;, \u0026#34;cat_pid\u0026#34;: 0, \u0026#34;cat_level\u0026#34;: 0 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交分类 请求路径：categories/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 cat_name 分类名称 不能为空【此参数，放到请求体中】 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;cat_id\u0026#34;: 22, \u0026#34;cat_name\u0026#34;: \u0026#34;自拍杆\u0026#34;, \u0026#34;cat_pid\u0026#34;: 7, \u0026#34;cat_level\u0026#34;: 2 }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除分类 请求路径：categories/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 七、分类参数管理 1. 参数列表 请求路径：categories/:id/attributes\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 sel many或only 不能为空，many表示动态参数，only表示静态参数（也称为静态属性） 响应参数 参数名 参数说明 备注 attr_id 分类参数 ID attr_name 分类参数名称 cat_id 分类参数所属分类 attr_sel 分类参数的类型，many表示动态参数，only表示静态属性 attr_write list表示从列表选择（动态参数），manual表示手工录入（静态属性） attr_vals 分类参数的明细，如果是动态参数，则该值是以空格分隔的字符串 响应数据 { \u0026#34;data\u0026#34;: [ { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;4K高清 5K高清 6K高清\u0026#34; } ], \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加动态参数或静态属性 请求路径：categories/:id/attributes\n请求方法：post\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 attr_name 参数名称 不能为空 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 44, \u0026#34;attr_name\u0026#34;: \u0026#34;测试参数\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;a,b,c\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询参数 请求路径：categories/:id/attributes/:attrId\n请求方法：get\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 属性 ID 不能为空携带在url中 attr_sel many或only 不能为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 1, \u0026#34;attr_name\u0026#34;: \u0026#34;cpu\u0026#34;, \u0026#34;cat_id\u0026#34;: 22, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;ffff\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 更新参数及明细 请求路径：categories/:id/attributes/:attrId\n请求方法：put\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 参数 ID 不能为空携带在url中 attr_name 参数名称 不能为空，携带在请求体中 attr_sel many或only 不能为空，携带在请求体中 attr_vals 参数的明细 可选参数，携带在请求体中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;attr_id\u0026#34;: 9, \u0026#34;attr_name\u0026#34;: \u0026#34;测试更新\u0026#34;, \u0026#34;cat_id\u0026#34;: \u0026#34;43\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;only\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;manual\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;abc\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除参数 请求路径： categories/:id/attributes/:attrid\n请求方法：delete\n请求参数\n参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrid 参数 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 八、商品管理 1. 商品列表数据 请求路径：goods\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 50, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 144, \u0026#34;goods_name\u0026#34;: \u0026#34;iphone\u0026#34;, \u0026#34;goods_price\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 1, \u0026#34;goods_weight\u0026#34;: 1, \u0026#34;goods_state\u0026#34;: null, \u0026#34;add_time\u0026#34;: 1512954923, \u0026#34;upd_time\u0026#34;: 1512954923, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 添加商品 请求路径：goods\n请求方法：post\n请求参数\n参数名 参数说明 备注 goods_name 商品名称 不能为空 goods_cat 以,逗号分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组），包含 动态参数 和 静态属性 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_cat\u0026#34;: \u0026#34;1,2,3\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;cat_id\u0026#34;: 1, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;创建商品成功\u0026#34;, \u0026#34;status\u0026#34;: 201 } } 3. 根据 ID 查询商品 请求路径：goods/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 goods_introduce 介绍 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 编辑提交商品 请求路径：goods/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 goods_name 商品名称 不能为空 goods_cat 以为\u0026rsquo;,\u0026lsquo;分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组） 可以为空 请求数据 { \u0026#34;goods_name\u0026#34;:\u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;:20, \u0026#34;goods_number\u0026#34;:30, \u0026#34;goods_weight\u0026#34;:40, \u0026#34;goods_introduce\u0026#34;:\u0026#34;abc\u0026#34;, \u0026#34;pics\u0026#34;:[ {\u0026#34;pic\u0026#34;:\u0026#34;/tmp_uploads/30f08d52c551ecb447277eae232304b8\u0026#34;} ], \u0026#34;attrs\u0026#34;:[ { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;ddd\u0026#34; }, { \u0026#34;attr_id\u0026#34;:15, \u0026#34;attr_value\u0026#34;:\u0026#34;eee\u0026#34; } ] } 响应参数 参数名 参数说明 备注 total 总共商品条数 pagenum 当前商品页数 goods_id 商品 ID goods_name 商品名称 goods_price 价格 goods_number 数量 goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间 upd_time 更新时间 hot_mumber 热销品数量 is_promote 是否是热销品 pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;goods_name\u0026#34;: \u0026#34;test_goods_name2\u0026#34;, \u0026#34;goods_price\u0026#34;: 20, \u0026#34;goods_number\u0026#34;: 30, \u0026#34;goods_weight\u0026#34;: 40, \u0026#34;goods_introduce\u0026#34;: \u0026#34;abc\u0026#34;, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;goods_state\u0026#34;: 1, \u0026#34;add_time\u0026#34;: 1512962370, \u0026#34;upd_time\u0026#34;: 1512962370, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 397, \u0026#34;goods_id\u0026#34;: 145, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 145, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新商品成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 删除商品 请求路径：goods/:id\n请求方法：delete\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: null, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;删除成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品图片\n请求路径：goods/:id/pics\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 pics 商品图片集合 如果有 pics_id 字段会保留该图片，如果没有 pics_id 但是有 pic 字段就会新生成图片数据 请求数据 ;[ { pic: \u0026#39;tmp_uploads/db28f6316835836e97653b5c75e418be.png\u0026#39; }, { pics_id: 397, goods_id: 145, pics_big: \u0026#39;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_mid: \u0026#39;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8\u0026#39;, pics_sma: \u0026#39;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###同步商品属性\n请求路径：goods/:id/attributes\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 请求数据 ;[ { attr_id: 15, attr_value: \u0026#39;ddd\u0026#39; }, { attr_id: 15, attr_value: \u0026#39;eee\u0026#39; } ] 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_name\u0026#34;: \u0026#34;iphoneXX\u0026#34;, \u0026#34;goods_price\u0026#34;: 2, \u0026#34;goods_number\u0026#34;: 22, \u0026#34;goods_weight\u0026#34;: 22, \u0026#34;goods_introduce\u0026#34;: null, \u0026#34;goods_big_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_small_logo\u0026#34;: \u0026#34;./uploads/goods/20201113/small_483a3b8e99e534ec3e4312dbbaee7c9d.jpg\u0026#34;, \u0026#34;goods_state\u0026#34;: 0, \u0026#34;is_del\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;add_time\u0026#34;: 1510045904, \u0026#34;upd_time\u0026#34;: 1512635159, \u0026#34;delete_time\u0026#34;: 1512635159, \u0026#34;hot_mumber\u0026#34;: 0, \u0026#34;is_promote\u0026#34;: false, \u0026#34;pics\u0026#34;: [ { \u0026#34;pics_id\u0026#34;: 383, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;pics_big\u0026#34;: \u0026#34;uploads/goodspics/big_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_mid\u0026#34;: \u0026#34;uploads/goodspics/mid_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34;, \u0026#34;pics_sma\u0026#34;: \u0026#34;uploads/goodspics/sma_6f5750132abd3f5b2b93dd722fcde653.jpg\u0026#34; } ], \u0026#34;attrs\u0026#34;: [ { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;eee\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;goods_id\u0026#34;: 96, \u0026#34;attr_id\u0026#34;: 15, \u0026#34;attr_value\u0026#34;: \u0026#34;ddd\u0026#34;, \u0026#34;add_price\u0026#34;: null, \u0026#34;attr_name\u0026#34;: \u0026#34;fffffff\u0026#34;, \u0026#34;attr_sel\u0026#34;: \u0026#34;many\u0026#34;, \u0026#34;attr_write\u0026#34;: \u0026#34;list\u0026#34;, \u0026#34;attr_vals\u0026#34;: \u0026#34;\u0026#34; } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;更新成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } ###商品图片处理必须安装 GraphicsMagick\nlinux apt-get install GraphicsMagick Mac OS X brew install GraphicsMagick Windows 点击下载 6. 图片上传 请求路径：upload\n请求方法：post\n请求参数\n参数名 参数说明 备注 file 上传文件 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;tmp_path\u0026#34;: \u0026#34;tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://127.0.0.1:8888tmp_uploads/ccfc5179a914e94506bcbb7377e8985f.png\u0026#34; }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;上传成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 九、订单管理 1. 订单数据列表 请求路径：orders\n请求方法：get\n请求参数\n参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 可以为空，默认为1 pagesize 每页显示条数 可以为空，省略时返回所有订单 user_id 用户 ID 可以为空 pay_status 支付状态 可以为空 is_send 是否发货 可以为空 order_fapiao_title [\u0026lsquo;个人\u0026rsquo;,\u0026lsquo;公司\u0026rsquo;] 可以为空 order_fapiao_company 公司名称 可以为空 order_fapiao_content 发票内容 可以为空 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;total\u0026#34;: 1, \u0026#34;pagenum\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;goods\u0026#34;: [ { \u0026#34;order_id\u0026#34;: 47, \u0026#34;user_id\u0026#34;: 133, \u0026#34;order_number\u0026#34;: \u0026#34;59e7502d7993d\u0026#34;, \u0026#34;order_price\u0026#34;: 322, \u0026#34;order_pay\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;是\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;办公用品\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;江苏省南京市秦淮区龙蟠中路666号\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;create_time\u0026#34;: 1508331565, \u0026#34;update_time\u0026#34;: 1508331565 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 2. 修改订单状态 请求路径：orders/:id\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 is_send 订单是否发货 1:已经发货，0:未发货 order_pay 订单支付 支付方式 0 未支付 1 支付宝 2 微信 3 银行卡 order_price 订单价格 order_number 订单数量 pay_status 支付状态 订单状态： 0 未付款、1 已付款 请求数据说明\n所有请求数据都是增量更新，如果参数不填写，就不会更新该字段 响应数据\n{ \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 3. 查看订单详情 请求路径：orders/:id\n请求方法：get\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 响应数据 { \u0026#34;data\u0026#34;: { \u0026#34;order_id\u0026#34;: 67, \u0026#34;user_id\u0026#34;: 1, \u0026#34;order_number\u0026#34;: \u0026#34;itany-g7kmck71vjaujfgoi\u0026#34;, \u0026#34;order_price\u0026#34;: 20, \u0026#34;order_pay\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;is_send\u0026#34;: \u0026#34;否\u0026#34;, \u0026#34;trade_no\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_title\u0026#34;: \u0026#34;个人\u0026#34;, \u0026#34;order_fapiao_company\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;order_fapiao_content\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;consignee_addr\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pay_status\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;create_time\u0026#34;: 1512533560, \u0026#34;update_time\u0026#34;: 1512533560, \u0026#34;goods\u0026#34;: [ { \u0026#34;id\u0026#34;: 82, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 96, \u0026#34;goods_price\u0026#34;: 333, \u0026#34;goods_number\u0026#34;: 2, \u0026#34;goods_total_price\u0026#34;: 999 }, { \u0026#34;id\u0026#34;: 83, \u0026#34;order_id\u0026#34;: 67, \u0026#34;goods_id\u0026#34;: 95, \u0026#34;goods_price\u0026#34;: 666, \u0026#34;goods_number\u0026#34;: 5, \u0026#34;goods_total_price\u0026#34;: 999 } ] }, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;获取成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 4. 修改地址 请求路径：orders/:id/address\n请求方法：put\n请求参数\n参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 consignee_addr 收货地址 可以为空 响应数据 { \u0026#34;data\u0026#34;: {}, \u0026#34;meta\u0026#34;: { \u0026#34;msg\u0026#34;: \u0026#34;修改地址成功\u0026#34;, \u0026#34;status\u0026#34;: 200 } } 5. 查看物流信息 请求路径：/kuaidi/:id\n请求方法：get\n物流单号：815294206237577\n响应数据：\n{ \u0026#34;meta\u0026#34;:{ \u0026#34;status\u0026#34;:200, \u0026#34;message\u0026#34;:\u0026#34;获取物流信息成功！\u0026#34; }, \u0026#34;data\u0026#34;:[ { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 12:39:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已签收,签收人是 汤小洋 先生/女士，如有疑问请联系派件员阿奇(13805148888)，如您未收到此快递，请拨打投诉电话：15294207777，感谢使用申通快递，期待再次为您服务\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:46:54\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东寒亭营业厅-寒亭阿奇(13805148888)-派件中\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 08:38:57\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-15 06:38:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东寒亭营业厅\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:56:45\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东寒亭公司\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 20:52:44\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 17:43:48\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:53:46\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;上海浦东转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 10:43:31\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:43:20\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏苏州转运中心-已发往-上海浦东转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-14 02:41:40\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;已到达-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 16:28:13\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;江苏南京转运中心-已发往-江苏苏州转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 15:03:30\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:47:56\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-已发往-江苏南京转运中心\u0026#34;, \u0026#34;location\u0026#34;:null }, { \u0026#34;time\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;ftime\u0026#34;:\u0026#34;2020-11-13 14:37:06\u0026#34;, \u0026#34;context\u0026#34;:\u0026#34;南京IT教育公司-城东汪小主宠物店-已收件\u0026#34;, \u0026#34;location\u0026#34;:null } ] } ","permalink":"https://waite.wang/posts/project/shop-mall-api-docs/","summary":"\u003ch2 id=\"一api-v2-接口说明\"\u003e一、API V2 接口说明\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e接口基准地址：\u003ccode\u003ehttp://www.tangxiaoyang.vip:8888/api/v2/\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e服务端已开启 CORS 跨域支持\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAPI V2 认证统一使用 Token 认证\u003c/p\u003e","title":"电商后台管理系统后端api接口文档"},{"content":"VueCLI https://cli.vuejs.org/zh/\n什么是Vue脚手架？\n我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的webpack配置，这样显示开发的效率会大大的降低； 所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架； 脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架； 我们可以通过CLI选择项目的配置和创建出我们的项目； Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置； Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：\n通过 @vue/cli 实现的交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。\nVue CLI 安装 Node 版本要求\nVue CLI 4.x 需要 Node.js v8.9 或更高版本 (推荐 v10 以上)。你可以使用 n，nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。\n可以使用下列任一命令安装这个新的包： npm install -g @vue/cli ## OR yarn global add @vue/cli 安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。你还可以用这个命令来检查其版本是否正确： vue --version 如需升级全局的 Vue CLI 包，请运行： npm update -g @vue/cli ## 或者 yarn global upgrade --latest @vue/cli 上面列出来的命令是用于升级全局的 Vue CLI。如需升级项目中的 Vue CLI 相关模块（以 @vue/cli-plugin- 或 vue-cli-plugin- 开头），请在项目目录下运行 vue upgrade： 用法： upgrade [options] [plugin-name] （试用）升级 Vue CLI 服务及插件 选项： -t, --to \u0026lt;version\u0026gt; 升级 \u0026lt;plugin-name\u0026gt; 到指定的版本 -f, --from \u0026lt;version\u0026gt; 跳过本地版本检测，默认插件是从此处指定的版本升级上来 -r, --registry \u0026lt;url\u0026gt; 使用指定的 registry 地址安装依赖 --all 升级所有的插件 --next 检查插件新版本时，包括 alpha/beta/rc 版本在内 -h, --help 输出帮助内容 创建一个项目 运行以下命令来创建一个新项目：\nvue create hello-world 选择预设 Default ([Vue 3] babel, eslint): 选择 Vue3 版本, 并且默认选择 babel, eslint Default ([Vue 2] babel, eslint): 选择 Vue2 版本, 并且默认选择 babel, eslint Manually select features: 手动选择需要获取的特性 我们选择 Manually select features Babel: Babel是一个JavaScript编译器，用于将新版本的JavaScript代码转换为向后兼容的旧版本，以便在不同浏览器和环境中运行。 TypeScript: TypeScript是一种静态类型的JavaScript超集，它添加了类型注解和其他特性，以提供更强大的开发工具和更可靠的代码。 Progressive Web App (PWA) Support: PWA是一种使用现代Web技术构建的应用程序，可以在各种设备和平台上提供类似原生应用的体验。 Router: Vue Router是Vue.js官方提供的路由管理器，用于实现单页面应用程序（SPA）中的导航和路由功能。 Vuex: Vuex是Vue.js官方提供的状态管理库，用于在大型应用程序中管理和共享状态。 CSS Pre-processors: CSS预处理器（如Sass、Less）允许您在编写CSS时使用变量、嵌套规则、函数等高级功能，以提高样式表的可维护性和可重用性。 Linter / Formatter: 代码检查工具（如ESLint）用于强制执行一致的代码风格和检测潜在的错误。代码格式化工具（如Prettier）可自动格式化代码，使其符合统一的样式规范。 Unit Testing: 单元测试是一种软件测试方法，用于验证应用程序中各个部分的功能是否按预期工作。 E2E Testing: 端到端（End-to-End）测试是一种测试方法，用于模拟用户在应用程序中执行的实际操作，以验证整个应用程序的功能和流程。 选择 Vue 版本 Pick a linter / formatter config: 选择的代码检查和格式化配置\nESLint with error prevention only：仅使用ESLint进行错误检查，不应用其他格式化规则。 ESLint + Airbnb config：使用ESLint进行错误检查，并应用Airbnb JavaScript风格指南的格式化规则。 ESLint + Standard config：使用ESLint进行错误检查，并应用JavaScript Standard风格的格式化规则。 ESLint + Prettier：使用ESLint进行错误检查，并与Prettier代码格式化工具集成，以实现一致的代码样式 Pick additional lint features: 可供选择的附加代码检查功能\nLint on save：在保存文件时运行代码检查，以及在编辑器中进行实时错误检测和提示。 Lint and fix on commit：在提交代码时运行代码检查，并自动修复一些常见的问题，以确保提交的代码符合规范。 Where do you prefer placing config for Babel, ESLint, etc.? 配置文件位置选择\nIn dedicated config files：将Babel、ESLint等配置信息分别保存在它们各自的配置文件中（如.babelrc、.eslintrc等。 In package.json：将Babel、ESLint等配置信息保存在package.json文件的特定字段中，如babel、eslintConfig等。 Save this as a preset for future projects? (y/N) 这是一个保存预设供以后使用的选项，如果您希望将当前配置保存为预设，以便在将来的项目中重用，可以选择“y”，否则选择“N”。\n您还可以使用图形界面使用以下vue ui命令创建和管理项目：\nvue ui 项目结构 |-node_modules -- 所有的项目依赖包都放在这个目录下 |-public -- 公共文件夹 ---|favicon.ico -- 网站的显示图标 ---|index.html -- 入口的html文件 |-src -- 源文件目录，编写的代码基本都在这个目录下 ---|assets -- 放置静态文件的目录，比如logo.png就放在这里 ---|components -- Vue的组件文件，自定义的组件都会放到这 ---|App.vue -- 根组件，这个在Vue2中也有 ---|main.ts -- 入口文件，因为采用了TypeScript所以是ts结尾 ---|shims-vue.d.ts -- 类文件(也叫定义文件)，因为.vue结尾的文件在ts中不认可，所以要有定义文件 |-.browserslistrc -- 在不同前端工具之间公用目标浏览器和node版本的配置文件，作用是设置兼容性 |-.eslintrc.js -- Eslint的配置文件，不用作过多介绍 |-.gitignore -- 用来配置那些文件不归git管理 |-package.json -- 命令配置和包管理文件 |-README.md -- 项目的说明文件，使用markdown语法进行编写 |-tsconfig.json -- 关于TypeScript的配置文件 |-yarn.lock -- 使用yarn后自动生成的文件，由Yarn管理，安装yarn包时的重要信息存储到yarn.lock文件中 在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令。\n\u0026#34;scripts\u0026#34;: { \u0026#34;serve\u0026#34;: \u0026#34;vue-cli-service serve\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-cli-service build\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;vue-cli-service lint\u0026#34; } 你可以通过 npm 或 Yarn 调用这些 script：\nnpm run serve ## OR yarn serve 如果你可以使用 npx (最新版的 npm 应该已经自带)，也可以直接这样调用命令：\nnpx vue-cli-service serve vue-cli-service serve 用法：vue-cli-service serve [options] [entry] 选项： --open 在服务器启动时打开浏览器 --copy 在服务器启动时将 URL 复制到剪切版 --mode 指定环境模式 (默认值：development) --host 指定 host (默认值：0.0.0.0) --port 指定 port (默认值：8080) --https 使用 https (默认值：false) vue-cli-service serve 命令会启动一个开发服务器 (基于 webpack-dev-server) 并附带开箱即用的模块热重载 (Hot-Module-Replacement)。\n除了通过命令行参数，你也可以使用 vue.config.js 里的 devServer 字段配置开发服务器。\n命令行参数 [entry] 将被指定为唯一入口 (默认值：src/main.js，TypeScript 项目则为 src/main.ts)，而非额外的追加入口。尝试使用 [entry] 覆盖 config.pages 中的 entry 将可能引发错误。\nvue-cli-service build 用法：vue-cli-service build [options] [entry|pattern] 选项： --mode 指定环境模式 (默认值：production) --dest 指定输出目录 (默认值：dist) --modern 面向现代浏览器带自动回退地构建应用 --target app | lib | wc | wc-async (默认值：app) --name 库或 Web Components 模式下的名字 (默认值：package.json 中的 \u0026#34;name\u0026#34; 字段或入口文件名) --no-clean 在构建项目之前不清除目标目录的内容 --report 生成 report.html 以帮助分析包内容 --report-json 生成 report.json 以帮助分析包内容 --watch 监听文件变化 vue-cli-service build 会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。它的 chunk manifest 会内联在 HTML 里。\n这里还有一些有用的命令参数：\n--modern 使用现代模式构建应用，为现代浏览器交付原生支持的 ES2015 代码，并生成一个兼容老浏览器的包用来自动回退。 --target 允许你将项目中的任何组件以一个库或 Web Components 组件的方式进行构建。更多细节请查阅构建目标。 --report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小。 vue-cli-service inspect 用法：vue-cli-service inspect [options] [...paths] 选项： --mode 指定环境模式 (默认值：development) 如果你想要设置 inspect 命令的选项，可以在命令后面添加对应的参数。例如，如果你想要查看生产环境的 webpack 配置，可以运行以下命令：vue-cli-service inspect --mode production\n你也可以通过在 vue.config.js 文件中配置 configureWebpack 选项来修改 webpack 配置。这个选项允许你返回一个对象或函数来修改默认的 webpack 配置。例如：\nmodule.exports = { configureWebpack: { plugins: [ // 添加一个插件 ] } } 你可以使用 vue-cli-service inspect 来审查一个 Vue CLI 项目的 webpack config。更多细节请查阅审查 webpack config。\nWebpack 认识webpack 事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：\n比如开发过程中我们需要通过模块化的方式来开发； 比如也会使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑， 通过sass、less等方式来编写 css 样式代码； 比如开发过程中，我们还希望实时的监听文件的变化来并且反映到浏览器上，提高开发的效率； 比如开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化； 但是对于很多的前端开发者来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：\n这是因为目前前端开发我们通常都会直接使用三大框架来开发：Vue、React、Angular； 但是事实上，这三大框架的创建过程我们都是借助于脚手架（CLI）的； 事实上Vue-CLI、create-react-app、Angular-CLI都是基于webpack来帮助我们支持模块化、less、 TypeScript、打包优化等的； Webpack到底是什么呢？ https://webpack.docschina.org/\n本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。\n打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具 模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等； Vue项目加载的文件有哪些呢？ JavaScript的打包： 将ES6转换成ES5的语法； TypeScript的处理，将其转换成JavaScript； Css的处理： CSS文件模块的加载、提取； Less、Sass等预处理器的处理； 资源文件img、font： 图片img文件的加载； 字体font文件的加载； HTML资源的处理： 打包HTML资源文件； 处理vue项目的SFC文件.vue文件 Webpack的使用 webpack的官方文档是webpack webpack的中文官方文档是webpack Webpack的运行是依赖Node环境的，所以我们电脑上必须有Node环境 所以我们需要先安装Node.js，并且同时会安装npm； Node官方网站：Node.js Webpack的安装 webpack的安装目前分为两个：webpack、webpack-cli 执行webpack命令，会执行node_modules下的.bin目录下的webpack； webpack在执行时是依赖webpack-cli的，如果没有安装就会报错； 而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程； 所以在安装webpack时，我们需要同时安装webpack-cli（第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自 己的vue-service-cli的东西） Webpack的默认打包 ES6、CommonJS等模块化语法在浏览器中是不被直接识别的，但是通过使用Webpack的打包功能，可以将这些语法转换为浏览器可以识别的语法。Webpack可以将多个模块打包成一个或多个浏览器可识别的文件，使得在浏览器中可以正常运行这些模块化代码。\n我们可以通过webpack进行打包，之后运行打包之后的代码\n在目录下直接执行 webpack 命令 webpack 生成一个 dist 文件夹，里面存放一个main.js的文件，就是我们打包之后的文件：\n这个文件中的代码被压缩和丑化了； 另外我们发现代码中依然存在ES6的语法，比如箭头函数、const等，这是因为默认情况下webpack并不清楚我们打包后的文 件是否需要转成ES5之前的语法，后续我们需要通过babel来进行转换和设置； 我们发现是可以正常进行打包的，但是有一个问题，webpack是如何确定我们的入口的呢？\n事实上，当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口； 所以，如果当前项目中没有存在 src/index.js 文件，那么会报错； 当然，我们也可以通过配置来指定入口和出口\nnpx webpack --entry ./src/main.js --output-path ./build webpack 局部安装 版本控制：通过在项目中局部安装Webpack，可以确保每个项目使用的Webpack版本是一致的，避免不同项目之间的版本冲突。 简化部署：将Webpack安装在项目的本地目录中，可以简化项目的部署过程。只需要将整个项目目录复制到其他环境中，不需要再次安装全局的Webpack。 隔离环境：每个项目可以拥有自己独立的Webpack配置和插件，不会受到其他项目的影响。这样可以更灵活地根据项目需求进行定制和配置。 可移植性：通过局部安装Webpack，可以将整个项目打包成一个可移植的文件夹，方便在不同环境中进行迁移和共享。 第一步：创建package.json文件，用于管理项目的信息、库依赖等 npm init 第二步：安装局部的webpack npm install webpack webpack-cli --save-dev // -D(--save-dev) 开发依赖 第三步：使用局部的webpack npx webpack 第四步：在 package.json 中创建scripts脚本，执行脚本打包即可 ## package \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; } ## cmd npm run build Webpack配置 Webpack 配置文件 在通常情况下，webpack需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然 是不可以的。 我们可以在根目录下创建一个webpack.config.js文件，来作为webpack的配置文件： const path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#34;./src/main.js\u0026#34;, output: { path: path.resolve(__dirname, \u0026#34;./build\u0026#34;), filename: \u0026#34;bundle.js\u0026#34; } } 继续执行webpack命令，依然可以正常打包 npm run build 指定配置文件 但是如果我们的配置文件并不是webpack.config.js的名字，而是其他的名字呢？\n比如我们将webpack.config.js修改成了 wk.config.js； 这个时候我们可以通过 \u0026ndash;config 来指定对应的配置文件； webpack --config wk.config.js 但是每次这样执行命令来对源码进行编译，会非常繁琐，所以我们可以在package.json中增加一个新的脚本： \u0026#34;build\u0026#34;: \u0026#34;webpack --config wk.config.js\u0026#34; 之后我们执行 npm run build来打包即可。 Webpack的依赖 Webpack通过以下步骤对项目进行打包：\n配置：创建一个Webpack配置文件（通常命名为webpack.config.js），在其中定义打包的入口文件、输出文件的路径、加载器和插件等。 入口：在配置文件中指定打包的入口文件，可以是单个文件或多个文件, 从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如 js 文件、css 文件、图片、字体等), 然后遍历图结构，打包一个个模块（根据文件的不同使用不同的loader来解析）； 加载器：根据需要，配置加载器来处理不同类型的文件。例如，使用babel-loader来转换ES6+代码，使用 css-loader 和 style-loader 来处理CSS文件。 插件：根据需要，配置插件来执行额外的任务。例如，使用html-webpack-plugin生成HTML文件，使用mini-css-extract-plugin提取CSS文件。 输出：在配置文件中指定打包输出的路径和文件名。 运行：在命令行中运行webpack命令，Webpack将根据配置文件进行打包，并生成输出文件。 在运行Webpack命令时，可以使用不同的参数和选项来控制打包的行为。例如，使用\u0026ndash;mode参数指定打包的模式（开发模式或生产模式），使用\u0026ndash;watch选项启用监听模式等。\nloader的使用 https://webpack.docschina.org/loaders/\n在 Webpack5 以后会采用 asset module type 来替代 loader\n在Webpack中，Loader是用于对不同类型的文件进行转换和处理的模块。它们作为Webpack的一部分，用于在打包过程中对文件进行预处理。\nLoader可以将不同类型的文件（如JavaScript、CSS、图片等）转换为模块，以便在应用程序中使用。它们可以执行各种任务，例如将ES6+代码转换为ES5语法、处理CSS文件中的样式、压缩和优化图像等。\nLoader通常以链式调用的方式使用，可以根据需要配置多个Loader来处理文件。每个Loader都会对文件进行一次转换，并将转换后的结果传递给下一个Loader，直到最后一个Loader将最终的结果返回给Webpack进行打包。\nLoader的配置是通过Webpack的配置文件（通常是webpack.config.js）中的module.rules字段来完成。在这个字段中，可以指定不同类型文件的匹配规则和对应的Loader。\ncss-loader 的使用 对于加载css文件来说，我们需要一个可以读取css文件的loader； 这个loader最常用的是css-loader； css-loader的安装： npm install css-loader -D npm install css-loader --save-dev 如何使用这个loader来加载css文件呢？有三种方式： 内联方式； CLI方式（webpack5中不再使用）； 配置方式； 内联方式：内联方式使用较少，因为不方便管理；\n在引入的样式前加上使用的loader，并且使用 ! 分割； import \u0026#34;css-loader!../css/style.css\u0026#34; 配置方式 配置方式表示的意思是在我们的webpack.config.js文件中写明配置信息： module.rules中允许我们配置多个loader（因为我们也会继续使用其他的loader，来完成其他文件的加载) 这种方式可以更好的表示loader的配置，也方便后期的维护，同时也让你对各个Loader有一个全局的概览 module.rules的配置如下： rules属性对应的值是一个数组：[Rule] 数组中存放的是一个个的Rule，Rule是一个对象，对象中可以设置多个属性： test属性：用于对 resource（资源）进行匹配的，通常会设置成正则表达式； use属性：对应的值时一个数组：[UseEntry] UseEntry是一个对象，可以通过对象的属性来设置一些其他属性 loader：必须有一个 loader属性，对应的值是一个字符串； options：可选的属性，值是一个字符串或者对象，值会被传入到loader中； query：目前已经使用options来替代； 传递字符串（如：use: [ \u0026lsquo;style-loader\u0026rsquo; ]）是 loader 属性的简写方式（如：use: [ { loader: \u0026lsquo;style-loader\u0026rsquo;} ]）； loader属性： Rule.use: [ { loader } ] 的简写 module.exports = { // ... module: { rules: [ { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] } ] } }; style-loader 我们已经可以通过css-loader来加载css文件了\n但是你会发现这个css在我们的代码中并没有生效（页面没有效果）。 因为css-loader只是负责将.css文件进行解析，并不会将解析之后的css插入到页面中；\n如果我们希望再完成插入style的操作，那么我们还需要另外一个loader，就是style-loader；\n安装style-loader：\nnpm install style-loader -D 那么我们应该如何使用style-loader： 在配置文件中，添加style-loader； 注意：因为loader的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将style-loader写到 css-loader 的前面； use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] Less工具处理 我们可以使用less工具来完成它的编译转换： npm install less -D 执行如下命令： npm install less -D npx lessc ./src/css/title.less title.css less-loader处理 但是在项目中我们会编写大量的css，它们如何可以自动转换呢？\n这个时候我们就可以使用less-loader，来自动使用less工具转换less到css； npm install less-loader -D { test: /\\.less$/, use: [ \u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;, \u0026#34;less-loader\u0026#34; ] } postcss-loader(认识) 什么是PostCSS呢？ PostCSS是一个通过JavaScript来转换样式的工具； 这个工具可以帮助我们进行一些CSS的转换和适配，比如自动添加浏览器前缀、css样式的重置； p但是实现这些功能，我们需要借助于PostCSS对应的插件； 如何使用PostCSS呢？主要就是两个步骤： 第一步：查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader； 第二步：选择可以添加你需要的PostCSS相关的插件； 命令行使用postcss 安装一下它们：postcss、postcss-cli npm install postcss postcss-cli -D 我们编写一个需要添加前缀的css： Autoprefixer CSS online 我们可以在上面的网站中查询一些添加css属性的样式； 在Webpack中，PostCSS通常用于对CSS文件进行预处理和后处理。您可以使用PostCSS来编写现代CSS语法，然后使用各种插件对其进行处理，例如自动添加CSS前缀、压缩CSS等。 插件autoprefixer 因为我们需要添加前缀，所以要安装autoprefixer： npm install autoprefixer -D 直接使用使用postcss工具，并且制定使用autoprefixer npx postcss --use autoprefixer -o end.css ./src/css/style.css 转化的结果如下\n.title { user-select: none; } .title { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } /*## sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0VBQ0UseUJBQWlCO0tBQWpCLHNCQUFpQjtNQUFqQixxQkFBaUI7VUFBakIsaUJBQWlCO0FBQ25CIiwiZmlsZSI6ImRlbW8uY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLnRpdGxlIHtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG59Il19 */ postcss-loader 真实开发中我们必然不会直接使用命令行工具来对css进行处理，而是可以借助于构建工具：\n在webpack中使用postcss就是使用postcss-loader来处理的； 我们来安装postcss-loader：\nnpm install postcss-loader -D 因为postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin； use: [ { loading: \u0026#34;postcss-loader\u0026#34;, options: { postcssOptions: { plugins: [ require(\u0026#39;autoprefixer\u0026#39;) ] } } } ] 我们可以将 postcss 配置分离, 根目录下新建 postcss.config.js module.exports = { plugins: [ require(\u0026#34;postcss-preset-env\u0026#34;) ] } 这样在 webpack.config 中只需要 添加 postcss-loader 即可 postcss-preset-env postcss-preset-env 是一个 PostCSS 插件，它允许您使用最新的 CSS 特性，同时它会根据您的目标环境自动添加必要的回退。\n这个插件包含了 autoprefixer（自动添加浏览器前缀），cssnano（压缩 CSS），以及一些其他的 PostCSS 插件。这意味着您可以在 CSS 中使用最新的特性，例如 CSS Grid，CSS Variables，等等，而不需要担心兼容性问题。\n在您的 postcss.config.js 文件中，您已经将 postcss-preset-env 添加为一个插件，这意味着当您运行 PostCSS 时，它将使用 postcss-preset-env 来处理您的 CSS 文件。\n事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer。\n我们可以使用另外一个插件：postcss-preset-env\npostcss-preset-env也是一个postcss的插件； 它可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环境 添加所需的polyfill； 也包括会自动帮助我们添加 autoprefixer（所以相当于已经内置了 autoprefixer）； 首先，我们需要安装 postcss-preset-env：\nnpm install postcss-preset-env -D 之后，我们直接修改掉之前的 autoprefixer 即可; file-loader 要处理jpg、png等格式的图片，我们也需要有对应的loader：file-loader\nfile-loader的作用就是帮助我们处理import/require()方式引入的一个文件资源，并且会将它放到我们输出的文件夹中； 当然我们待会儿可以学习如何修改它的名字和所在文件夹； 安装file-loader：\nnpm install file-loader -D 配置处理图片的Rule： { test: /\\.(jpe?g|png|gif|svg)$/, type: \u0026#34;asset\u0026#34;, generator: { filename: \u0026#34;img/[name]_[hash:6][ext]\u0026#34; }, parser: { dataUrlCondition: { maxSize: 100 * 1024 } } } url-loader url-loader和file-loader的工作方式是相似的，但是可以将较小的文件，转成base64的URI。\n安装url-loader：\nurl-loader npm install url-loader -D 显示结果是一样的，并且图片可以正常显示； 但是在dist文件夹中，我们会看不到图片文件： 这是因为我的两张图片的大小分别是38kb和295kb； 默认情况下url-loader会将所有的图片文件转成base64编码 { test: /\\.(jpe?g|png|gif|svg)$/, use: { loader: \u0026#34;url-loader\u0026#34;, options: { // outputPath: \u0026#34;img\u0026#34;, name: \u0026#34;img/[name]_[hash:6].[ext]\u0026#34;, limit: 100 * 1024 } } } url-loader的limit 但是开发中我们往往是小的图片需要转换，但是大的图片直接使用图片即可 这是因为小的图片转换base64之后可以和页面一起被请求，减少不必要的请求过程； 而大的图片也进行转换，反而会影响页面的请求速度； 那么，我们如何可以限制哪些大小的图片转换和不转换呢？ url-loader有一个options属性limit，可以用于设置转换的限制； 下面的代码38kb的图片会进行base64编码，而295kb的不会； 字体文件加载 { test: /\\.(eot|ttf|woff2?)$/, use: { loader: \u0026#34;file-loader\u0026#34;, options: { // outputPath: \u0026#34;font\u0026#34;, name: \u0026#34;font/[name]_[hash:6].[ext]\u0026#34; } } }, { test: /\\.(eot|ttf|woff2?)$/, type: \u0026#34;asset/resource\u0026#34;, generator: { filename: \u0026#34;font/[name]_[hash:6][ext]\u0026#34; } } 文件命名规则 有时候我们处理后的文件名称按照一定的规则进行显示： 比如保留原来的文件名、扩展名，同时为了防止重复，包含一个hash值等； 这个时候我们可以使用PlaceHolders来完成，webpack给我们提供了大量的PlaceHolders来显示不同的内容： https://webpack.js.org/loaders/file-loader/#placeholders 我们这里介绍几个最常用的placeholder： [ext]： 处理文件的扩展名； [name]：处理文件的名称； [hash]：文件的内容，使用MD4的散列函数处理，生成的一个128位的hash值（32个十六进制）； [contentHash]：在file-loader中和[hash]结果是一致的（在webpack的一些其他地方不一样，后面会讲到）； [hash:\u0026lt;length\u0026gt;]：截图hash的长度，默认32个字符太长了； [path]：文件相对于webpack配置文件的路径； 设置文件名称 那么我们可以按照如下的格式编写： 这个也是vue的写法； 设置文件的存放路径 刚才通过 img/ 已经设置了文件夹，这个也是vue、react脚手架中常见的设置方式 其实按照这种设置方式就可以了； 当然我们也可以通过outputPath来设置输出的文件夹； asset module type 我们当前使用的webpack版本是webpack5： 在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader； 在webpack5开始，我们可以直接使用资源模块类型（asset module type），来替代上面的这些loader； 资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader： asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现； asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现； asset/source 导出资源的源代码。之前通过使用 raw-loader 实现； asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现； asset module type的使用 比如加载图片，我们可以使用下面的方式： { test: /\\.(jpe?g|png|gif|svg)$/, type: \u0026#34;asset\u0026#34;, // 自定义文件的输出路径和文件名 generator: { filename: \u0026#34;img/[name]_[hash:6][ext]\u0026#34; }, parser: { dataUrlCondition: { maxSize: 100 * 1024 } } } Plugin Loader是用于特定的模块类型进行转换； Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等； CleanWebpackPlugin 每次修改了一些配置，重新打包时，都需要手动删除dist文件夹： 我们可以借助于一个插件来帮助我们完成，这个插件就是CleanWebpackPlugin； 首先，我们先安装这个插件： npm install clean-webpack-plugin -D 之后在插件中配置： const { CleanWebpackPlugin } = require(\u0026#34;clean-webpack-plugin\u0026#34;); module.exports = { plugins: [ new CleanWebpackPlugin(); ] }; HtmlWebpackPlugin 我们的HTML文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。\n在进行项目部署的时，必然也是需要有对应的入口文件index.html；\n所以我们也需要对index.html进行打包处理；\n对HTML进行打包处理我们可以使用另外一个插件：HtmlWebpackPlugin；\nnpm install html-webpack-plugin -D 自定义HTML模板 如果我们想在自己的模块中加入一些比较特别的内容：\n比如添加一个noscript标签，在用户的JavaScript被关闭时，给予响应的提示； 比如在开发vue或者react项目时，我们需要一个可以挂载后续组件的根标签 这个我们需要一个属于自己的index.html模块：\npublic/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;\u0026lt;%= BASE_URL %\u0026gt;favicon.ico\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;%= htmlWebpackPlugin.options.title %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;strong\u0026gt;We\u0026#39;re sorry but \u0026lt;%= htmlWebpackPlugin.options.title %\u0026gt; doesn\u0026#39;t work properly without JavaScript enabled. Please enable it to continue.\u0026lt;/strong\u0026gt; \u0026lt;/noscript\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- built files will be auto injected --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的代码中，会有一些类似这样的语法\u0026lt;% 变量 %\u0026gt;，这个是EJS模块填充数据的方式。 在配置 HtmlWebpackPlugin 时，我们可以添加如下配置： template：指定我们要使用的模块所在的路径； title：在进行 htmlWebpackPlugin.options.title 读取时，就会读到该信息； const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); module.exports = { plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./public/index.html\u0026#34;, title: \u0026#34;哈哈哈哈\u0026#34; }) ] }; DefinePlugin https://github.com/jantimon/html-webpack-plugin\n因为在模板中使用了 BASE_URL, 但是我们并没有设置过这个常量值，所以会出现没有定义的错误 - BASE_URL is not defined 这个时候我们可以使用DefinePlugin插件 DefinePlugin允许在编译时创建配置的全局常量，是一个webpack内置的插件（不需要单独安装）： const { DefinePlugin } = require(\u0026#34;webpack\u0026#34;); module.exports = { plugins: [ new DefinePlugin({ BASE_URL: \u0026#34;\u0026#39;./\u0026#39;\u0026#34; }) ] }; CopyWebpackPlugin CopyWebpackPlugin 是一个用于 webpack 的插件，它的主要功能是将单个文件或整个目录复制到构建目录。\n这个插件在以下情况下非常有用：\n当你有一些静态资源（例如图片、字体或公共库）需要包含在你的构建中，但是这些资源并不需要通过 webpack 处理时。 当你需要将一些文件复制到构建目录，以便在部署应用程序时使用 安装CopyWebpackPlugin插件：\nnpm install copy-webpack-plugin -D 接下来配置CopyWebpackPlugin即可： 复制的规则在patterns中设置； from：设置从哪一个源中开始复制； to：复制到的位置，可以省略，会默认复制到打包的目录下； globOptions：设置一些额外的选项，其中可以编写需要忽略的文件： .DS_Store：mac目录下回自动生成的一个文件； index.html：也不需要复制，因为我们已经通过HtmlWebpackPlugin完成了index.html的生成； const CopyWebpackPlugin = require(\u0026#39;copy-webpack-plugin\u0026#39;); new CopyWebpackPlugin({ patterns: [ { from: \u0026#34;public\u0026#34;, to: \u0026#34;./\u0026#34;, globOptions: { ignore: [ \u0026#34;**/index.html\u0026#34; ] } } ] }) Mode配置列表 module.exports = { // 设置模式 // development 开发阶段, 会设置development // production 准备打包上线的时候, 设置production mode: \u0026#34;development\u0026#34;, // 设置source-map, 建立js映射文件, 方便调试代码和错误 devtool: \u0026#34;source-map\u0026#34; } Vite https://cn.vitejs.dev/guide/\n什么是 Vite Vite（法语意为 \u0026ldquo;快速的\u0026rdquo;，发音 /vit/，发音同 \u0026ldquo;veet\u0026rdquo;）是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成： 一个开发服务器(dev server)，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。 Vite 是一种具有明确建议的工具，具备合理的默认设置。您可以在 功能指南 中了解 Vite 的各种可能性。通过 插件，Vite 支持与其他框架或工具的集成。如有需要，您可以通过 配置部分 自定义适应你的项目。 Vite 还提供了强大的扩展性，可通过其 插件 API 和 JavaScript API 进行扩展，并提供完整的类型支持。 Vite作为一个基于浏览器原生ESM的构建工具，它省略了开发环境的打包过程，利用浏览器去解析imports，在服务端按需编译返回。同时，在开发环境拥有速度快到惊人的模块热更新，且热更新的速度不会随着模块增多而变慢。因此，使用Vite进行开发，至少会比Webpack快10倍左右。 你可以在 为什么选 Vite 部分深入了解该项目的设计理念。 Vite的主要特性 Instant Server Start —— 即时服务启动 Lightning Fast HMR —— 闪电般快速的热更新 Rich Features —— 丰富的功能 Optimized Build —— 经过优化的构建 Universal Plugin Interface —— 通用的Plugin接口 Fully Typed APIs —— 类型齐全的API 主流构建工具对比 Browserify\n预编译模块化方案（文件打包工具）\nBrowserify基于流方式干净灵活 遵循commonJS规范打包JS 可引入插件打包CSS等其他资源（非原生能力） Gulp\n基于流的自动化构建工具（工程化） 配置复杂度高，偏向编程式，需要定义task处理构建 支持监听读写文件 可搭配Browserify等模块化工具来使用 Parcel\n极速打包（工程化：极速0配置） 零配置，但造成了配置不灵活，内置常见场景的构建方案及其依赖，无需再次安装（babel等） 以html入口，自动检测和打包依赖 不支持SourceMap 无法Tree-shaking Webpack\n预编译模块化方案（工程化：大而全） 通过配置文件达到一站式配置 loader进行资源转换，功能全面（css+js+icon+front） 插件丰富，灵活扩展 社群庞大 大型项目构建慢 Rollup\n基于ES6打包（模块打包工具） Tree-shaking 打包文件小且干净，执行效率更高 更专注于JS打包 Snowpack\n基于ESM运行时编译（工程化：ESM运行时） 无需递归循环依赖组装依赖树 默认输出单独的构建模块（未打包），可选择不同打包器（webpack、rollup等） Vite\n基于ESM运行时打包 借鉴了Snowpack 生产环境使用Rollup，集成度更高，相比Snowpack支持多页面、库模式、动态导入自动polyfill等 为什么使用 Vite 开发环境⚡️速度的提升 使用JS开发的工具通常需要很长的时间才能启动开发服务器，且这个启动时间与代码量、代码复杂度正相关。即使使用HMR，文件修改后的效果也要几秒钟才能在浏览器中反应出来，代表如Webpack。那么Vite是如何解决如Webpack这样的构建工具一样，在复杂、多模块项目开发中启动慢、HMR慢的问题呢？ 我们详细对比了开发环境中的Vite和Webpack，发现主要有如下不同： Webpack Vite 先打包生成bundle，再启动开发服务器 先启动开发服务器，利用新一代浏览器的ESM能力，无需打包，直接请求所需模块并实时编译 HMR时需要把改动模块及相关依赖全部编译 HMR时只需让浏览器重新请求该模块，同时利用浏览器的缓存（源码模块协商缓存，依赖模块强缓存）来优化请求 内存高效利用 - 因此，针对开发环境中的启动慢问题，Vite开发环境冷启动无需打包，无需分析模块之间的依赖，同时也无需在启动开发服务器前进行编译，启动时还会使用 esbuild 来进行预构建。而Webpack 启动后会做一堆事情，经历一条很长的编译打包链条，从入口开始需要逐步经历语法解析、依赖收集、代码转译、打包合并、代码优化，最终将高版本的、离散的源码编译打包成低版本、高兼容性的产物代码; 针对HMR慢，即使只有很小的改动，Webpack依然需要构建完整的模块依赖图，并根据依赖图来进行转换。而Vite利用了ESM和浏览器缓存技术，更新速度与项目复杂度无关。可以看到，如Snowpack、Vite这类面相非打包的构建工具，在开发环境启动时只需要启动两个Server，一个用于页面加载，一个用于HMR的Websocket。当浏览器发出原生的ESM请求，Server收到请求只需要编译当前文件后返回给浏览器，不需要管理依赖。 使用简单，开箱即用 相比Webpack需要对entry、loader、plugin等进行诸多配置，Vite的使用可谓是相当简单了。只需执行初始化命令，就可以得到一个预设好的开发环境，开箱即获得一堆功能，包括：CSS预处理、html预处理、异步加载、分包、压缩、HMR等。他使用复杂度介于Parcel和Webpack的中间，只是暴露了极少数的配置项和plugin接口，既不会像Parcel一样配置不灵活，又不会像Webpack一样需要了解庞大的loader、plugin生态，灵活适中、复杂度适中。适合前端新手。\nVite 的安装与使用 安装 Vite 需要 Node.js 版本 18+，20+。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。\n首先，我们安装一下vite工具：\nnpm install vite –g ## 全局安装 npm install vite –D ## 局部安装 12 通过vite来启动项目：\nnpx vite Vite构建Vue3项目 使用 NPM:\nnpm create vite@latest 使用 Yarn:\nyarn create vite Need to install the following packages: create-vite@4.2.0 Ok to proceed? (y) y ✔ Project name: … vite-vue3 ? Select a framework: › - Use arrow-keys. Return to submit. Vanilla （如果你要使用Vue2可以用这个方式，然后再自己配置一下vite-plugin-vue2插件） ❯ Vue （默认是Vue3项目） React （React项目） Preact （比React项目轻量级的Preact项目） Lit Svelte Others 因为我们要构建Vue3的项目，所以这里我们选择Vue就行了，然后下一步选择开发语言\n✔ Project name: … vite-vue3 ✔ Select a framework: › Vue ? Select a variant: › - Use arrow-keys. Return to submit. ❯ JavaScript TypeScript Customize with create-vue ↗ Nuxt ↗ cd 进项目路径, npm install, 然后 npm run dev 运行即可\nVite 支持 Css 支持 vite可以直接支持css的处理\n直接导入css即可； vite可以直接支持css预处理器，比如less\n直接导入less； 之后安装less编译器； npm install less -D vite直接支持postcss的转换： 只需要安装postcss，并且配置 postcss.config.js 的配置文件即可； npm install postcss postcss-preset-env -D // 在项目中创建 postcss.config.ts const postcssPresetEnv = require(\u0026#39;postcss-preset-env\u0026#39;); module.exports = { // 安装了一个预设 预设就是相当于最佳实践，已经帮你安装好了很多东西 plugin: [postcssPresetEnv(/* pluginOptions */)] } 全局导入 // vite.config.js import { defineConfig } from \u0026#39;vite\u0026#39;; export default defineConfig({ // 其他配置项... css: { preprocessorOptions: { scss: { additionalData: ` @import \u0026#34;@/style/globalVar.scss\u0026#34;; `, }, }, }, }); 别名 // vite.config.js import { defineConfig } from \u0026#39;vite\u0026#39;; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; export default defineConfig({ // 其他配置项... resolve: { alias: { \u0026#39;@\u0026#39;: \u0026#39;/src\u0026#39; } }, plugins: [vue()] }); Ts 支持 vite对TypeScript是原生支持的，它会直接使用ESBuild来完成编译： 只需要直接导入即可； 如果我们查看浏览器中的请求，会发现请求的依然是ts的代码： 这是因为vite中的服务器Connect会对我们的请求进行转发； 获取ts编译后的代码，给浏览器返回，浏览器可以直接进行解析； vue支持 vite对vue提供第一优先级支持：\nVue 3 单文件组件支持：@vitejs/plugin-vue Vue 3 JSX 支持：@vitejs/plugin-vue-jsx Vue 2 支持：underfin/vite-plugin-vue2 安装支持vue的插件：\nnpm install @vitejs/plugin-vue -D 在vite.config.js中配置插件\nconst vue = require(\u0026#39;@vitejs/plugin-vue\u0026#39;) module.exports = { plugins: [ vue() ] } Vite 原理 ESM\u0026amp;esbuild ESM 在ES6没有出现之前，随着js代码日益膨胀，往往会对资源模块化来提效，这也就出现了多个模块化方案。如CommonJS常用于服务端，AMD、CMD规范常用在客户端。ES6出现后，紧接着出现了ESM。ESM是浏览器支持的一种模块化方案，允许在浏览器实现模块化。\nCommonJS：模块同步，如Browserify会对代码进行解析，整理出代码中的所有模块依赖关系，然后把nodejs的模块编译成浏览器可用的模块，相关的模块代码都打包在一起，形成一个完整的JS文件，这个文件中不会存在 require 这类的模块化语法，变成可以在浏览器中运行的普通JS，运行时加载 AMD：模块异步，依赖前置，是requireJS在推广过程中对模块定义的规范化产出，加载完依赖后立即执行依赖模块，依赖加载成功后执行回调 CMD：模块异步，延迟执行，是seaJS在推广过程中对模块定义的规范化产出，就近依赖，先加载所有依赖模块，运行时才执行require内容，按顺序执行 与CommonJS、AMD不同，ESM的对外接口只是一种静态定义，为编译时加载，遇到模块加载命令import，就会生成一个只读引用。等脚本真正执行时，再根据这个只读引用，到被加载的那个模块内取值。由于ESM编译时就能确定模块的依赖关系，因此能够只包含要运行的代码，可以显著减少文件体积，降低浏览器压力。\n由于ESM是一个比较新的模块化方案，目前其浏览器能力支持如下：\n可以看到，除了IE、Opera等，新一代浏览器中绝大部分都已支持。\n接下来以Vite创建的模板为例，看一下ESM的解析过程：\n\u0026lt;template\u0026gt; \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34; /\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Hello Vue 3.0 + Vite\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld } } \u0026lt;/script\u0026gt; 当浏览器解析 import HelloWorld from \u0026lsquo;./components/HelloWorld.vue\u0026rsquo; 时，会向当前域名发送一个请求获取对应的资源（ESM支持解析相对路径） 浏览器下载对应的文件，然后解析成模块记录。接下来会进行实例化，为模块分配内存，然后按照导入、导出语句建立模块和内存的映射关系。最后，运行上述代码，把内存空间填充为真实的值。 esbuild ESBuild的特点： 超快的构建速度，并且不需要缓存； 支持ES6和CommonJS的模块化； 支持ES6的Tree Shaking； 支持Go、JavaScript的API； 支持TypeScript、JSX等语法编译； 支持SourceMap； 支持代码压缩； 支持扩展其他插件； ESBuild的构建速度和其他构建工具速度对比： ESBuild为什么这么快呢？ 使用Go语言编写的，可以直接转换成机器代码，而无需经过字节码； ESBuild可以充分利用CPU的多内核，尽可能让它们饱和运行； ESBuild的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题； 依赖处理 Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。依赖 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。\n依赖解析 以 Vite 官方 demo 为例，当我们请求 localhost:3000 时，Vite 默认返回 localhost:3000/index.html 的代码。而后发送请求 src/main.js。\nmain.js 代码如下：\nimport { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import \u0026#39;./index.css\u0026#39; createApp(App).mount(\u0026#39;#app\u0026#39;) 可以观察到浏览器请求 vue.js 时， 请求路径是 @modules/vue.js。在 Vite 中约定若 path 的请求路径满足 /^/@modules// 格式时，被认为是一个 node_modules 模块。\n平时开发中，webpack \u0026amp; rollup(rollup有对应插件) 等打包工具会帮我们找到模块的路径，但浏览器只能通过相对路径去寻找，而如果是直接使用模块名比如：import vue from \u0026lsquo;vue\u0026rsquo;，浏览器就会报错，这个时候就需要一个三方包进行处理。Vite 对ESM形式的 js 文件模块使用了 ES Module Lexer 处理。Lexer 会找到代码中以 import 语法导入的模块并以数组形式返回。Vite 通过该数组的值获取判断是否为一个 node_modules 模块。若是则进行对应改写成 @modules/:id 的写法。\n重写完路径后，浏览器会发送 path 为 /@modules/:id 的对应请求，接下来会被 Vite 客户端做一层拦截来解析模块的真实位置。\n首先正则匹配请求路径，如果是/@modules开头就进行后续处理，否则就跳过。若是，会设置响应类型为js，读取真实模块路径内容，返回给客户端。\n客户端注入本质上是创建一个script标签（type=\u0026lsquo;module\u0026rsquo;），然后将其插入到head中，这样客户端在解析html是就可以执行代码了\nexport const moduleRE = /^\\/@modules\\// // plugin for resolving /@modules/:id requests. app.use(async (ctx, next) =\u0026gt; { if (!moduleRE.test(ctx.path)) { return next() } // path maybe contain encode chars const id = decodeURIComponent(ctx.path.replace(moduleRE, \u0026#39;\u0026#39;)) ctx.type = \u0026#39;js\u0026#39; const serve = async (id: string, file: string, type: string) =\u0026gt; { // 在代码中做一个缓存，下次访问相同路径直接从 map 中获取 304 返回 moduleIdToFileMap.set(id, file) moduleFileToIdMap.set(file, ctx.path) debug(`(${type}) ${id} -\u0026gt; ${getDebugPath(root, file)}`) await ctx.read(file) return next() } } // 兼容 alias 情况 const importerFilePath = importer ? resolver.requestToFile(importer) : root const nodeModulePath = resolveNodeModuleFile(importerFilePath, id) // 如果是个 node_modules 的模块，读取文件。 if (nodeModulePath) { return serve(id, nodeModulePath, \u0026#39;node_modules\u0026#39;) } }) 依赖预构建 依赖预构建主要有两个目的：\nCommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。 性能： Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。 Vite使用esbuild在初次启动开发服务器前把检测到的依赖进行预构建。Vite 基于ESM，在使用某些模块时，由于模块依赖了另一些模块，依赖的模块又基于另一些模块。会出现页面初始化时一次发送数百个模块请求的情况。\n以 lodash-es 为例，代码中以 import { debounce } from \u0026rsquo;lodash\u0026rsquo; 导入一个命名函数时候，并不是只下载包含这个函数的文件，而是有一个依赖图。\nVite 为了优化请求数量和速度，利用esbuild在启动的时候预先把debounce用到的所有内部模块全部打包成一个bundle，这样就浏览器在请求debounce时，便只需要发送一次请求了\n静态资源加载 当请求的路径符合 imageRE, mediaRE, fontsRE 或 JSON 格式，会被认为是一个静态资源。静态资源将处理成ESM模块返回。\n// src/node/utils/pathUtils.ts const imageRE = /\\.(png|jpe?g|gif|svg|ico|webp)(\\?.*)?$/ const mediaRE = /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/ const fontsRE = /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i export const isStaticAsset = (file: string) =\u0026gt; { return imageRE.test(file) || mediaRE.test(file) || fontsRE.test(file) } // src/node/server/serverPluginAssets.ts app.use(async (ctx, next) =\u0026gt; { if (isStaticAsset(ctx.path) \u0026amp;\u0026amp; isImportRequest(ctx)) { ctx.type = \u0026#39;js\u0026#39; ctx.body = export default ${JSON.stringify(ctx.path)} // 输出是path return } return next() }) export const jsonPlugin: ServerPlugin = ({ app }) =\u0026gt; { app.use(async (ctx, next) =\u0026gt; { await next() // handle .json imports // note ctx.body could be null if upstream set status to 304 if (ctx.path.endsWith(\u0026#39;.json\u0026#39;) \u0026amp;\u0026amp; isImportRequest(ctx) \u0026amp;\u0026amp; ctx.body) { ctx.type = \u0026#39;js\u0026#39; ctx.body = dataToEsm(JSON.parse((await readBody(ctx.body))!), { namedExports: true, preferConst: true }) } }) } vue文件缓存 当 Vite 遇到一个 .vue 后缀的文件时。由于 .vue 模板文件的特殊性，它被拆分成 template, css, script 模块三个模块进行分别处理。最后会对 script, template, css 发送多个请求获取\njs/ts处理 Vite使用esbuild将ts转译到js，约是tsc速度的20～30倍，同时HMR更新反应到浏览器的时间会小于50ms。但是，由于esbuild转换ts到js对于类型操作仅仅是擦除，所以完全保证不了类型正确，因此需要额外校验类型，比如使用tsc \u0026ndash;noEmit。\n将ts转换成js后，浏览器便可以利用ESM直接拿到js资源。\n热更新原理 Vite 的热加载原理，其实就是在客户端与服务端建立了一个 websocket 连接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。\n服务端：服务端做的就是监听代码文件的改变，在合适的时机向客户端发送 websocket 信息通知客户端去请求新的模块代码。 客户端：Vite 中客户端的 websocket 相关代码在处理 html 中时被写入代码中。可以看到在处理 html 时，vite/client 的相关代码已经被插入。 export const clientPublicPath = `/vite/client` const devInjectionCode = `\\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt;import \u0026#34;${clientPublicPath}\u0026#34;\u0026lt;/script\u0026gt;\\n` async function rewriteHtml(importer: string, html: string) { return injectScriptToHtml(html, devInjectionCode) } 当request.path 路径是 /vite/client 时，请求获取已经提前写好的关于 websocket 的代码。因此在客户端中我们创建了一个 websocket 服务并与服务端建立了连接。\nVite 会接受到来自客户端的消息。通过不同的消息触发一些事件。做到浏览器端的即时热模块更换（热更新）。包括 connect、vue-reload、vue-rerender 等事件，分别触发组件vue 的重新加载，render等。\n// Listen for messages socket.addEventListener(\u0026#39;message\u0026#39;, async ({ data }) =\u0026gt; { const payload = JSON.parse(data) as HMRPayload | MultiUpdatePayload if (payload.type === \u0026#39;multi\u0026#39;) { payload.updates.forEach(handleMessage) } else { handleMessage(payload) } }) async function handleMessage(payload: HMRPayload) { const { path, changeSrcPath, timestamp } = payload as UpdatePayload console.log(path) switch (payload.type) { case \u0026#39;connected\u0026#39;: console.log(`[vite] connected.`) break case \u0026#39;vue-reload\u0026#39;: queueUpdate( import(`${path}?t=${timestamp}`) .catch((err) =\u0026gt; warnFailedFetch(err, path)) .then((m) =\u0026gt; () =\u0026gt; { __VUE_HMR_RUNTIME__.reload(path, m.default) console.log(`[vite] ${path} reloaded.`) }) ) break case \u0026#39;vue-rerender\u0026#39;: const templatePath = `${path}?type=template` import(`${templatePath}\u0026amp;t=${timestamp}`).then((m) =\u0026gt; { __VUE_HMR_RUNTIME__.rerender(path, m.render) console.log(`[vite] ${path} template updated.`) }) break case \u0026#39;style-update\u0026#39;: // check if this is referenced in html via \u0026lt;link\u0026gt; const el = document.querySelector(`link[href*=\u0026#39;${path}\u0026#39;]`) if (el) { el.setAttribute( \u0026#39;href\u0026#39;, `${path}${path.includes(\u0026#39;?\u0026#39;) ? \u0026#39;\u0026amp;\u0026#39; : \u0026#39;?\u0026#39;}t=${timestamp}` ) break } const importQuery = path.includes(\u0026#39;?\u0026#39;) ? \u0026#39;\u0026amp;import\u0026#39; : \u0026#39;?import\u0026#39; await import(`${path}${importQuery}\u0026amp;t=${timestamp}`) console.log(`[vite] ${path} updated.`) break case \u0026#39;js-update\u0026#39;: queueUpdate(updateModule(path, changeSrcPath, timestamp)) break case \u0026#39;custom\u0026#39;: const cbs = customUpdateMap.get(payload.id) if (cbs) { cbs.forEach((cb) =\u0026gt; cb(payload.customData)) } break case \u0026#39;full-reload\u0026#39;: if (path.endsWith(\u0026#39;.html\u0026#39;)) { // if html file is edited, only reload the page if the browser is // currently on that page. const pagePath = location.pathname if ( pagePath === path || (pagePath.endsWith(\u0026#39;/\u0026#39;) \u0026amp;\u0026amp; pagePath + \u0026#39;index.html\u0026#39; === path) ) { location.reload() } return } else { location.reload() } } } Webpack-Babel 什么是 Babel? https://babeljs.io/\nBabel 是一个 JavaScript 编译器，可以将 ECMAScript 2015+ 代码转换为向后兼容的 JavaScript 版本，以便在当前和旧版浏览器或环境中运行。它还支持将 JSX 转换为普通 JavaScript 代码。Babel 是一个非常流行的工具，许多现代的 JavaScript 应用程序都使用它来构建和部署。 事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分： 开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要； 以下是一个使用 Babel 的示例： 假设我们有一个使用箭头函数和 const 声明的简单 JavaScript 模块： const greet = (name) =\u0026gt; { console.log(`Hello, ${name}!`); } export default greet; 如果我们想要在旧版浏览器中运行它，我们可以使用 Babel 将其转换为 ES5： \u0026#34;use strict\u0026#34;; Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); exports.default = void 0; var greet = function greet(name) { console.log(\u0026#34;Hello, \u0026#34;.concat(name, \u0026#34;!\u0026#34;)); }; var _default = greet; exports.default = _default; 这个转换过的代码可以在大多数浏览器中运行，即使它们不支持箭头函数或 const 声明。 Babel 命令行使用 babel本身可以作为一个独立的工具（和postcss一样），不和webpack等构建工具配置来单独使用。 如果我们希望在命令行尝试使用babel，需要安装如下库： @babel/core：babel的核心代码，必须安装； @babel/cli：可以让我们在命令行使用babel； npm install @babel/cli @babel/core -D 使用babel来处理我们的源代码： src：是源文件的目录； –out-dir：指定要输出的文件夹dist； \u0026ndash;out-file: 指定要输出的文件dist； npx babel src --out-dir dist npx babel src --out-file dist 插件 Babel 的插件是用于转换 JavaScript 代码的小型程序，可以添加到 Babel 配置中。Babel 插件可以执行各种任务，例如：\n转换语法：将新的 ECMAScript 特性转换为向后兼容的代码。 转换 API：将使用新 API 的代码转换为旧 API。 转换 JSX：将 JSX 转换为普通的 JavaScript 代码。 以下是一些常见的 Babel 插件：\n@babel/plugin-transform-arrow-functions: 将箭头函数转换为普通函数。 @babel/plugin-transform-block-scoping: 将 let 和 const 声明转换为 var 声明。 @babel/plugin-transform-classes: 将类转换为 ES5 构造函数。 @babel/plugin-transform-destructuring: 将解构赋值转换为普通赋值。 @babel/plugin-transform-object-assign: 将 Object.assign() 转换为 ES5 兼容的代码。 @babel/plugin-transform-react-jsx: 将 JSX 转换为普通的 JavaScript 代码。 @babel/plugin-transform-runtime: 避免在每个文件中重复使用 Babel 运行时代码。 如何使用?\n比如我们需要转换箭头函数, const 转成 var，那么我们就可以使用箭头函数转换相关的插件： npm install @babel/plugin-transform-arrow-functions -D npm install @babel/plugin-transform-block-scoping -D npx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping ,@babel/plugin-transform-arrow-functions 预设 preset Babel 的预设（preset）是一组预先配置的转换规则，用于将特定版本的 JavaScript 代码转换为向后兼容的旧版本。以下是一些常用的 Babel 预设：\n@babel/preset-env: 根据目标环境自动确定需要的转换规则。它根据你在 .babelrc 或 babel.config.js 文件中的配置来确定需要转换的 JavaScript 特性。 @babel/preset-react: 用于转换 React JSX 语法的预设。它可以将 JSX 转换为普通的 JavaScript 代码。 @babel/preset-typescript: 用于转换 TypeScript 代码的预设。它可以将 TypeScript 的类型注解和其他特定语法转换为普通的 JavaScript 代码。 @babel/preset-flow: 用于转换 Flow 类型注解的预设。它可以将 Flow 的类型注解转换为普通的 JavaScript 代码。 这些预设可以根据你的项目需求进行选择和配置。你可以在 .babelrc 或 babel.config.js 文件中指定所需的预设，例如：\nmodule.exports = { presets: [ \u0026#34;@babel/preset-env\u0026#34; ] } 也可以\nnpm install @babel/preset-env -D npx babel src --out-dir dist --presets=@babel/preset-env 原理 底层原理 babel是如何做到将我们的一段代码（ES6、TypeScript、React）转成另外一段代码（ES5）的呢？\n从一种源代码（原生语言）转换成另一种源代码（目标语言），这是什么的工作呢？ 就是编译器，事实上我们可以将babel看成就是一个编译器。 Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码； Babel也拥有编译器的工作流程：\n解析（Parsing）：Babel首先将输入的JavaScript代码解析成抽象语法树（Abstract Syntax Tree，AST）。AST是一个用于表示代码结构的树状数据结构，它能够准确地描述代码的语法和语义。 转换（Transformation）：在AST的基础上，Babel会应用一系列的插件和预设来进行代码转换。这些插件和预设可以执行各种转换操作，例如语法转换、代码优化、添加兼容性处理等。每个插件都负责处理AST中的特定节点，并根据需要进行修改或替换。 生成（Generation）：转换完成后，Babel会将修改后的AST重新生成为JavaScript代码。这些生成的代码可以是与输入代码相同的版本，也可以是经过转换后的新代码。 https://github.com/jamiebuilds/the-super-tiny-compiler: 非常简单的编译器实现，旨在教授编译器原理和实践。\n执行原理 Babel的执行阶段\n词法分析（Lexing）：将输入的源代码字符串转换为一个令牌（Token）序列。每个令牌代表源代码中的一个语法单元，例如标识符、运算符、括号等。 语法分析（Parsing）：将令牌序列转换为抽象语法树（AST）。AST是一个用于描述代码结构的树状数据结构，它能够准确地描述源代码的语法和语义。 转换（Transformation）：在AST的基础上，应用一系列的转换规则，以修改和优化AST。这些规则可以执行各种操作，例如语法转换、代码优化、添加兼容性处理等。 代码生成（Code Generation）：将修改后的AST转换为目标语言的代码。在\u0026quot;The Super Tiny Compiler\u0026quot;中，目标语言是JavaScript。 输出：输出生成的目标代码。 babel-loader babel-loader是一个用于在Webpack构建过程中将JavaScript代码转换的加载器（loader）。它是与Babel配合使用的常用工具之一。 通过配置Webpack的规则，使用babel-loader可以将指定的JavaScript文件传递给Babel进行转换。Babel会根据配置的插件和预设，将源代码转换为目标浏览器或环境所支持的语法。 指定使用的插件 presets 预设: 如果我们一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个 preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。以下使用 @babel/preset-env\nenv react TypeScript 使用 babel-loader 的一般步骤如下：\n安装 babel-loader 和相关的Babel插件和预设： npm install --save-dev babel-loader @babel/core @babel/preset-env webpack webpack.config.js，在其中配置 babel-loader： module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: \u0026#39;bundle.js\u0026#39;, path: __dirname + \u0026#39;/dist\u0026#39; }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: \u0026#39;babel-loader\u0026#39;, options: { presets: [\u0026#39;@babel/preset-env\u0026#39;] } } } ] } }; 配置文件 我们可以将babel的配置信息放到一个独立的文件中，babel给我们提供了两种配置文件的编写： babel.config.json（或者.js，.cjs，.mjs）文件； babelrc.json（或者.babelrc，.js，.cjs，.mjs）文件； 它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel本身、element-plus、umi等）； .babelrc.json：早期使用较多的配置方式，但是对于配置Monorepos项目是比较麻烦的； babel.config.json（babel7）：可以直接作用于Monorepos项目的子包，更加推荐； 补充: Monorepo 是一种项目代码管理方式,指单个仓库中管理多个项目,有助于简化代码共享、版本控制、构建和部署等方面的复杂性,并提供更好的可重用性和协作性, 类似 @babel/preset-env 这种写法大概率就是 Monorepo 以下为 babel.config.js module.exports = { presets: [ \u0026#34;@babel/preset-env\u0026#34; ] } 这样在 webpack.config.js 中只需要 { test: /\\.js$/, loader: \u0026#34;babel-loader\u0026#34; } 在 Webpack 中使用 Vue npm install vue import { createApp } from \u0026#39;vue\u0026#39;; createApp({ template: \u0026#34;\u0026lt;h2\u0026gt;{{title}} - {{message}}\u0026lt;/h2\u0026gt;\u0026#34;, components: { }, data() { return { title: \u0026#34;Hello World\u0026#34;, message: \u0026#34;哈哈哈\u0026#34; } } }).mount(\u0026#34;#app\u0026#34;); 此时重新 build 运行后不显示, 报错如下\nruntime-core.esm-bundler.js:38 [Vue warn]: Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias \u0026quot;vue\u0026quot; to \u0026quot;vue/dist/vue.esm-bundler.js\u0026quot; at \u0026lt;App\u0026gt; -\u0026gt; runtime-core.esm-bundler.js:38\n这个错误是因为 Vue 3 默认不包含模板编译器，所以当你试图在组件中使用 template 选项时，你会看到这个警告。\n要解决这个问题，你需要在 webpack 配置中添加一个别名，将 \u0026ldquo;vue\u0026rdquo; 指向 \u0026ldquo;vue/dist/vue.esm-bundler.js\u0026rdquo;。这个版本的 Vue 包含了模板编译器。\n// 在 main.js 中更改应用, 重新部署即可 import { createApp } from \u0026#39;vue/dist/vue.esm-bundler.js\u0026#39;; Vue打包后不同版本解析\nvue(.runtime).global(.prod).js 是用于直接在浏览器中引入的全局版本，可以通过 \u0026lt;script\u0026gt; 标签来使用。 + 我们之前通过CDN引入和下载的Vue版本就是这个版本； + 会暴露一个全局的Vue来使用； vue(.runtime).esm-browser(.prod).js 是用于原生 ES 模块导入的版本，在支持 ES 模块的浏览器中可以使用 \u0026lt;script type='module'\u0026gt; 来引入。 vue(.runtime).esm-bundler.js 是用于构建工具（如webpack、rollup、parcel等）的版本，默认情况下会使用 vue.runtime.esm-bundler.js。如果需要解析模板（template），则需要手动指定 vue.esm-bundler.js。 vue.cjs(.prod).js 是用于服务器端渲染的版本，在 Node.js 中可以使用 require() 来引入。 require 是 Node.js 中用于导入模块的函数。它是 CommonJS 模块系统的一部分，这是 Node.js 的默认模块系统。以下是一个 require 的基本用法示例：const fs = require('fs');在这个例子中，我们导入了 Node.js 的内置 fs（文件系统）模块。 require 函数也可以用来导入你自己的模块。例如，如果你有一个名为 myModule.js 的文件，你可以这样导入它：const myModule = require('./myModule.js'); 注意，当导入自己的模块时，你需要提供模块的相对路径（以 ./ 开头）。 然而，require 并不是 ECMAScript（JavaScript 的标准化规范）的一部分，因此它在浏览器环境中通常不可用。在浏览器环境中，你通常会使用 ECMAScript 的 import 和 export 语句来导入和导出模块。 接下来我们把 main.js 中的 vue 代码抽离为单文件组件(SFC) \u0026lt;!-- /vue/App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;我是Vue渲染出来的\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{title}}\u0026lt;/h2\u0026gt; \u0026lt;hello-world\u0026gt;\u0026lt;/hello-world\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./HelloWorld.vue\u0026#39;; export default { components: { HelloWorld }, data() { return { title: \u0026#34;Hello World\u0026#34;, message: \u0026#34;哈哈哈\u0026#34; } }, methods: { } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; h2 { color: red; } \u0026lt;/style\u0026gt; 重新打包, 报错：我们需要合适的Loader来处理文件。 npm install vue-loader -D 配置 webpack.config.js { test: /\\.vue$/, loader: \u0026#34;vue-loader\u0026#34; } 重新 build 仍然报错 Error:vue-loader requires @vue/compiler present the dependency tree, 打包依然会报错，这是因为我们必须添加@vue/compiler-sfc来对template进行解析：\nnpm install @vue/compiler-sfc -D 重新打包即可支持App.vue的写法\n补充 当然此时控制台还有如下报错 You are running the csm-bundler bu1ld of Vue, It is recommended to contigure your bundler to expl1citly roplace featur flag globals with boolean literals to get proper tree-shaking in the fina bundle, See http://link,yuejs.org/feature-flags for more details.\n在官方解释如下: https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags\nBundler Build Feature Flags是构建工具（Bundler）中的一种特性标志，用于控制Vue框架的不同特性的开启和关闭。从Vue 3.0.0-rc.3版本开始，esm-bundler构建工具现在公开了全局特性标志，可以在编译时进行覆盖。其中两个重要的特性标志包括： VUE_OPTIONS_API：启用/禁用Options API支持，默认为true。 VUE_PROD_DEVTOOLS：启用/禁用生产环境下的devtools支持，默认为false。 在没有配置这些特性标志的情况下，构建工具仍然可以正常工作，但强烈建议正确配置它们以便在最终的打包文件中实现正确的树摇效果。要配置这些特性标志： https://webpack.js.org/plugins/define-plugin/ module.exports = { plugins: [ new DefinePlugin({ BASE_URL: \u0026#34;\u0026#39;./\u0026#39;\u0026#34;, __VUE_OPTIONS_API__: true, __VUE_PROD_DEVTOOLS__: false }) ] } 开启Bundler Build Feature Flags的好处在于能够更好地控制Vue框架的特性和功能，从而有效地减少最终打包文件的大小。通过正确配置特性标志，可以实现树摇（tree-shaking）效果，即只包含应用程序实际使用的代码，而不包含未使用的代码。这将有助于提高应用程序的性能和加载速度，并减少资源消耗。此外，通过禁用不需要的特性，还可以减少应用程序的复杂性，并提高代码的可维护性。因此，建议开发人员在使用Vue框架时正确配置Bundler Build Feature Flags，以获得更好的开发和部署体验。\nWebpack-dev-server devServer 是指开发服务器，通常用于前端开发环境。在前端开发中，开发者通常需要一个本地服务器来运行他们的应用程序，以便进行测试和调试。Webpack是一个流行的前端构建工具，而devServer就是Webpack提供的一个功能，用于在开发过程中提供一个简单的服务器。\ndevServer 可以帮助开发者在本地启动一个服务器，监视文件的变化，并在文件发生更改时自动重新加载页面，以提高开发效率。此外，它还支持一些其他功能，比如模块热替换（Hot Module Replacement），允许在不刷新整个页面的情况下更新部分模块。\n在使用Webpack配置文件时，你可以配置 devServer 的各种选项，以满足你的开发需求。这包括设置服务器的端口、指定静态资源的路径、配置代理等。\n目前我们开发的代码，为了运行需要有两个操作： 操作一：npm run build，编译相关的代码； 操作二：通过live server或者直接通过浏览器，打开index.html代码，查看效果； 这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示； 为了完成自动编译，webpack提供了几种可选的方式： webpack watch mode：在文件发生变化时，Webpack会自动重新编译代码。 webpack-dev-server（常用）：提供了一个开发服务器，可以在本地运行你的应用程序，并且在文件发生变化时自动重新加载页面。 webpack-dev-middleware：结合其他服务器框架使用，将Webpack与服务器集成，实现在文件发生变化时自动重新编译 Webpack watch webpack给我们提供了watch模式：\n在该模式下，webpack依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译； 我们不需要手动去运行 npm run build指令了； 开启watch模式有两种方式：\n通过在命令行中使用\u0026ndash;watch参数来开启watch模式。例如，运行webpack --watch命令即可开启watch模式。 // package.json \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --watch\u0026#34; } 在Webpack配置文件中添加``watch: true`选项来开启watch模式。例如，在Webpack配置文件中添加以下代码： // webpack.config.js module.exports = { watch: true } webpack-dev-server 上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的： 当然，目前我们可以在 VSCode 中使用 live-server 来完成这样的功能； 但是，我们希望在不适用live-server的情况下，可以具备live reloading（实时重新加载）的功能； 安装webpack-dev-server npm install webpack-dev-server -D 修改配置文件 // package.json \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;webpack serve\u0026#34; } 运行 npm run serve, 在本地配置一个服务器, 使用 webpack cli 解析/ 启动本地服务 在运行 npm run serve 命令时，如果没有指定输出目录，webpack会默认将打包后的文件输出到内存中，而不是硬盘上的某个目录中。因此即使没有指定输出目录，该命令仍然可以正常运行。这种方式称为内存编译，可以提高开发效率，因为不需要每次修改代码后都重新编译和写入磁盘。 使用 memfs 这一个库实现;\n认识模块热替换（HMR） 什么是HMR呢？ HMR的全称是Hot Module Replacement，翻译为模块热替换； 模块热替换是指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面； HMR通过如下几种方式，来提高开发的速度： 不重新加载整个页面，这样可以保留某些应用程序的状态不丢失； 只更新需要变化的内容，节省开发的时间； 修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式； 如何使用HMR呢？ 默认情况下，webpack-dev-server已经支持HMR，我们只需要开启即可； 在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading； 开启 HMR 修改webpack的配置： // webpack.config.js module.exports = { // target 用来指定打包后的代码在哪个环境下运行 target: \u0026#34;web\u0026#34;, devServer: { // 1. static: 用来指定静态资源的根目录 // 如果有的资源没有在 Webpack 中加载, 那么就会去 static 中查找加载 static: \u0026#34;./public\u0026#34;, // 2. hot: 是否开启热更新 hot: true } } 指定哪些模块发生更新时，进行HMR； if(module.hot) { // module.hot.accept(moduleName, callback) module.hot.accept(\u0026#34;./js/element\u0026#34;, () =\u0026gt; { console.log(\u0026#34;element模块发生了变化\u0026#34;); }) } 框架 的 HMR 大多数主流框架（如React、Vue和Angular）都对模块热替换（HMR）提供了内置的支持，以便在开发过程中实现更快的热更新。\n具体而言，这些框架通常会提供开发服务器或开发工具，用于在开发过程中启用HMR功能。通过使用这些工具，你可以在修改代码时实时查看更新后的效果，而无需手动刷新页面。\n以下是一些常见的框架的HMR支持方式：\nReact：React 框架通常使用Webpack的 react-hot-loader 插件来实现HMR功能。你可以在Webpack配置文件中配置该插件，然后在开发服务器中启用HMR。 Vue：Vue 框架内置了对HMR的支持。你可以使用 vue-loader 和 vue-style-loader 等相关插件，以及在Webpack配置文件中配置HMR选项，来启用Vue的HMR功能。 Angular：Angular 框架使用Webpack的 @angular-builders/custom-webpack 插件来实现HMR功能。你可以在Angular项目的配置文件中进行相应的配置，以启用HMR。 请注意，每个框架的具体配置方式可能会有所不同。建议查阅相应框架的官方文档或社区资源，以获取更详细的关于HMR的配置和使用说明。\nHMR的原理 HMR（Hot Module Replacement）的原理是通过在应用程序运行时，通过开发服务器向客户端发送更新的模块代码，然后使用热更新运行时（Hot Update Runtime）来替换旧的模块代码，从而实现模块的热替换，而无需重新加载整个页面。\nwebpack-dev-server会创建两个服务：提供静态资源的服务（express）和Socket服务（net.Socket）； HMR Socket Server，是一个socket的长连接： 长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）； 当服务器监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）； 通过长连接，可以直接将这两个文件主动发送给客户端（浏览器）； 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新； Webpack-dev-server使用Node.js内置的net模块提供WebSocket服务。该服务与静态资源服务配合使用，用于与客户端进行实时通信。当客户端连接到WebSocket服务时，Webpack-dev-server会将更新的模块代码发送到客户端，并触发模块热替换（HMR）功能。客户端接收到更新后，会通过WebSocket与Webpack-dev-server建立连接，并将更新的模块代码应用到正在运行的应用程序中。 express server负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）； Webpack-dev-server使用express框架提供静态资源服务。该服务可以将Webpack打包后的静态资源文件（如HTML、CSS、JavaScript等）提供给浏览器访问。同时，该服务还支持一些特殊的路由，如/__webpack_hmr，用于与客户端建立WebSocket通信。 具体而言，HMR的原理可以分为以下几个步骤：\n构建过程中的注入：在Webpack构建过程中，会将特殊的HMR运行时代码注入到应用程序中的每个模块中。这些HMR运行时代码负责与开发服务器建立连接，并接收来自服务器的更新通知。 开发服务器的更新通知：开发服务器会监视文件的变化，并在文件发生更改时，向连接的客户端发送更新通知。这些更新通知包含了被修改的模块的更新代码。 客户端接收更新：当客户端接收到更新通知时，它会根据更新代码进行处理。这些更新代码会被热更新运行时处理，并将其应用于相应的模块。 模块的热替换：热更新运行时会将新的模块代码与旧的模块代码进行比较，并尽可能地将新代码应用于正在运行的应用程序。如果新代码可以被成功替换，应用程序会保持运行状态，同时显示更新后的效果。 总结起来，HMR利用了Webpack的构建能力和热更新运行时，使得在开发过程中可以实时地修改代码并查看更新后的效果，从而提高开发效率。\ndevServer 配置信息 // webpack.config.js module.exports = { // target 用来指定打包后的代码在哪个环境下运行 target: \u0026#34;web\u0026#34;, devServer: { // 1. contentBase: 用来指定静态资源的根目录 static: \u0026#34;./public\u0026#34;, // 2. hot: 是否开启热更新 hot: true, // 3. host: 指定服务器的ip地址, 默认是localhost host: \u0026#34;0.0.0.0\u0026#34;, port: 7777, // 4. open: 是否自动打开浏览器 open: true, // 5. compress: 是否启动gzip压缩 // compress: true, // 6. proxy: 用来配置代理 proxy: { \u0026#34;/api\u0026#34;: { target: \u0026#34;http://localhost:8888\u0026#34;, pathRewrite: { \u0026#34;^/api\u0026#34;: \u0026#34;\u0026#34; }, secure: false, changeOrigin: true } } } } hotOnly、host 配置 host设置主机地址：\n默认值是localhost； 如果希望其他地方也可以访问，可以设置为 0.0.0.0； localhost 和 0.0.0.0 的区别：\nlocalhost：localhost是一个主机名，表示本地计算机或设备自身。它通常映射到回环地址（loopback address）``127.0.0.1，也可以是IPv6的::1。当应用程序绑定到localhost`时，它只能通过本地计算机或设备上的回环接口进行访问。这意味着只有本地计算机或设备上的进程可以访问该应用程序，其他计算机或设备无法直接访问。 0.0.0.0：0.0.0.0是一个特殊的IP地址，表示任意主机或所有主机。当应用程序绑定到0.0.0.0时，它将监听所有可用的网络接口，包括本地计算机上的回环接口和其他网络接口。这意味着其他计算机或设备可以通过网络访问该应用程序，前提是网络连接和防火墙允许。 简而言之，localhost指的是本地计算机或设备自身，只能通过本地访问。而0.0.0.0表示任意主机或所有主机，可以通过网络访问。在开发过程中，通常将应用程序绑定到localhost以进行本地开发和测试，而将其绑定到0.0.0.0可以使其在局域网或公共网络上可访问。\nport、open、compress port设置监听的端口，默认情况下是8080 这个选项用于指定Webpack开发服务器的端口号。通过设置port选项，你可以指定应用程序在开发服务器上监听的端口。 open是否打开浏览器： 默认值是false，设置为true会打开浏览器； 这个选项用于指定是否在启动Webpack开发服务器后自动打开浏览器。通过设置open选项为true，开发服务器将在启动后自动打开默认浏览器，并加载应用程序 也可以设置为类似于 Google Chrome等值； compress是否为静态文件开启gzip compression： 默认值是false，可以设置为true； 这个选项用于指定是否启用gzip压缩。通过设置compress选项为true，开发服务器将对传输到浏览器的资源进行gzip压缩，以减小文件大小，提高传输速度。 module.exports = { // ... devServer: { port: 8080, // 指定端口号为8080 open: true, // 自动打开浏览器 compress: true, // 启用gzip压缩 }, }; Proxy https://webpack.docschina.org/configuration/dev-server#devserverproxy\nproxy是我们开发中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题：\n比如我们的一个api请求是 http://localhost:3000但是本地启动服务器的域名是 http://localhost:8000，这 个时候发送网络请求就会出现跨域的问题； 那么我们可以将请求先发送到一个代理服务器，代理服务器和API服务器没有跨域的问题，就可以解决我们的跨域问题了 代理（Proxy）是一种常见的网络应用程序架构，它可以将客户端的请求转发到另一个服务器进行处理。在开发环境中，我们通常会将应用程序和API服务分开部署，这时就需要使用代理将客户端的API请求转发到后端API服务器上。\n在 Webpack 的 devServer 中，可以使用proxy选项来配置代理设置。proxy选项可以是一个对象，也可以是一个函数。对象方式的proxy选项可以指定一个或多个代理规则，每个规则包含了要转发的请求路径和目标服务器地址。例如：\nmodule.exports = { // ... devServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, // 目标服务器地址 changeOrigin: true, // 改变请求头中的Origin字段 pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39;, // 将/api前缀替换为空 }, }, }, }, }; 在这个示例中，我们将所有以/api开头的请求转发到http://localhost:3000服务器上。同时，我们还设置了changeOrigin选项为true，以改变请求头中的Origin字段，并使用pathRewrite选项将请求路径中的/api前缀替换为空。 当 changeOrigin设置为 true 时，代理服务器会将请求头中的 Origin 字段替换为目标服务器的地址，这样目标服务器就可以正确识别请求来源。否则，目标服务器可能会拒绝请求或返回错误的响应。 除了对象方式的proxy选项外，还可以使用函数方式的proxy选项来进行更灵活的配置。例如： module.exports = { // ... devServer: { proxy: (req, res, proxyOptions) =\u0026gt; { const target = \u0026#39;http://localhost:3000\u0026#39;; if (req.url.startsWith(\u0026#39;/api\u0026#39;)) { return { target, changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39;, }, }; } }, }, }; 在这个示例中，我们使用函数方式的proxy选项来动态配置代理规则。如果请求路径以/api开头，则将其转发到http://localhost:3000服务器上，并使用相应的选项进行配置。\n默认情况下，将不接受在 HTTPS 上运行且证书无效的后端服务器。 如果需要，可以这样修改配置：\nmodule.exports = { //... devServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;https://other-server.example.com\u0026#39;, secure: false, }, }, }, }; historyApiFallback historyApiFallback是 webpack-dev-server的一个配置项，用于控制当使用 HTML5 History API 时，如果找不到对应的资源应该返回什么页面。\n当浏览器使用 HTML5 History API 进行前端路由跳转时，例如从/home 跳转到 /about，浏览器会向服务器发送一个 GET 请求，但是服务器上并没有对应的 /about 路径和资源，此时会返回 404 错误。为了避免这种情况，historyApiFallback 可以设置一个默认的页面，用于代替 404 错误页面。\n例如，设置 historyApiFallback: true 后，当访问一个不存在的路由时，webpack-dev-server 会返回一个默认的 HTML 页面，通常是 index.html。这个页面会包含前端路由所需的 JavaScript 和 CSS 资源，从而保证前端路由跳转的正常运行。\n需要注意的是，在生产环境中，historyApiFallback 应该由服务器来处理，而不是由前端框架或工具来处理。\nhttps://webpack.docschina.org/configuration/dev-server/#devserverhistoryapifallback\nmodule.exports = { // ...其他配置项 devServer: { port: 8080, proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://localhost:3000\u0026#39;, changeOrigin: true } }, historyApiFallback: true } } 要将 404 错误跳转到一个名为 404.html的页面，你可以通过 historyApiFallback的 rewrites选项来实现。以下是一个示例配置： module.exports = { //... devServer: { historyApiFallback: { rewrites: [ { from: /^\\/$/, to: \u0026#39;/views/landing.html\u0026#39; }, { from: /^\\/subpage/, to: \u0026#39;/views/subpage.html\u0026#39; }, { from: /./, to: \u0026#39;/views/404.html\u0026#39; }, ], }, }, }; 在上述配置中，我们使用了 rewrites数组来定义重写规则。第一个规则 { from: /^\\/$/, to: '/index.html' } 将根路径 /重写到 index.html 页面，这样确保了默认路径的正确加载。第二个规则 { from: /./, to: '/404.html' }将所有其他路径都重写到 404.html 页面，实现了将 404 错误跳转到指定页面的效果。 resolve模块解析 https://webpack.docschina.org/configuration/resolve\nresolve是 webpack 中的一个配置选项，用于配置模块解析的规则。 在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库； resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码； webpack 使用 enhanced-resolve 来解析文件路径； extensions extensions用于配置在导入模块时可以省略的文件扩展名。例如，配置了 extensions: ['.js', '.jsx'] 后，当导入模块时可以省略文件扩展名，如 import MyComponent from './MyComponent'，webpack 会自动尝试解析 MyComponent.js 或 MyComponent.jsx。\nalias alias用于创建模块的别名，可以简化模块导入的路径。例如，配置了 alias: { '@': path.resolve(__dirname, 'src') }后，可以使用import MyComponent from '@/components/MyComponent'来导入位于 src/components/MyComponent 的模块。\nmodules modules用于配置 webpack在解析模块时搜索的目录。默认情况下，webpack只会搜索 node_modules 目录。通过配置 modules，可以告诉 webpack在其他目录中查找模块。例如，配置了 modules: ['src', 'node_modules'] 后，webpack会先在 src目录中查找模块，然后再在 node_modules目录中查找。\nmainFields mainFields用于配置在导入模块时，webpack优先使用的字段。当导入一个模块时，它可能在 package.json 文件中定义了多个入口字段（如 main, module, browser 等）。通过配置 mainFields，可以告诉 webpack 使用哪个字段作为模块的主入口。例如，配置了 mainFields: ['browser', 'module', 'main'] 后，webpack 会优先使用 browser 字段，然后是 module字段，最后是 main字段。\nmodule.exports = { // ...其他配置项 resolve: { extensions: [\u0026#39;.js\u0026#39;, \u0026#39;.jsx\u0026#39;], alias: { // alias：创建了一个别名 @，指向项目根目录下的 src 目录。 \u0026#39;@\u0026#39;: path.resolve(__dirname, \u0026#39;src\u0026#39;) }, modules: [\u0026#39;src\u0026#39;, \u0026#39;node_modules\u0026#39;], mainFields: [\u0026#39;browser\u0026#39;, \u0026#39;module\u0026#39;, \u0026#39;main\u0026#39;] } } webpack能解析三种文件路径： 绝对路径 由于已经获得文件的绝对路径，因此不需要再做进一步解析。 相对路径 在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录； 在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径； 模块路径 在 resolve.modules中指定的所有目录检索模块； 默认值是 [‘node_modules’]，所以默认会从node_modules中查找文件； 我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解alias的配置； 区分开发/ 生产环境 目前我们所有的webpack配置信息都是放到一个配置文件中的：webpack.config.js 当配置越来越多时，这个文件会变得越来越不容易维护； 并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环 境都会使用的； 所以，我们最好对配置进行划分，方便我们维护和管理； 方案一：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可； // package.json \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --config ./config/webpack.prod.config.js\u0026#34;, \u0026#34;serve\u0026#34;: \u0026#34;webpack serve --config ./config/webpack.dev.config.js\u0026#34; } const { merge } = require(\u0026#39;webpack-merge\u0026#39;); const commonConfig = require(\u0026#39;./webpack.comm.config\u0026#39;); module.exports = merge(commonConfig, { mode: \u0026#34;development\u0026#34;, devtool: \u0026#34;source-map\u0026#34;, devServer: { contentBase: \u0026#34;./public\u0026#34;, hot: true, // host: \u0026#34;0.0.0.0\u0026#34;, port: 7777, open: true, // compress: true, proxy: { \u0026#34;/api\u0026#34;: { target: \u0026#34;http://localhost:8888\u0026#34;, pathRewrite: { \u0026#34;^/api\u0026#34;: \u0026#34;\u0026#34; }, secure: false, changeOrigin: true } } }, }) 方式二：使用相同的一个入口配置文件，通过设置参数来区分它们； const path = require(\u0026#39;path\u0026#39;); module.exports = (env, argv) =\u0026gt; { const isDev = argv.mode === \u0026#39;development\u0026#39;; return { mode: argv.mode, entry: \u0026#39;./src/index.js\u0026#39;, output: { filename: isDev ? \u0026#39;bundle.js\u0026#39; : \u0026#39;bundle.[contenthash].js\u0026#39;, path: path.resolve(__dirname, \u0026#39;dist\u0026#39;) }, devtool: isDev ? \u0026#39;eval-source-map\u0026#39; : \u0026#39;source-map\u0026#39;, optimization: { minimize: !isDev }, // ...其他配置项 }; }; 在命令行中，可以通过 --mode 参数来指定 webpack 的构建模式。例如： webpack --mode development ","permalink":"https://waite.wang/posts/vue/system-learn-vue-3-cli/","summary":"\u003ch2 id=\"vuecli\"\u003eVueCLI\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://cli.vuejs.org/zh/\"\u003ehttps://cli.vuejs.org/zh/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e什么是Vue脚手架？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成 所有的webpack配置，这样显示开发的效率会大大的降低；\u003c/li\u003e\n\u003cli\u003e所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架；\u003c/li\u003e\n\u003cli\u003e脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架；\u003c/li\u003e\n\u003cli\u003e我们可以通过CLI选择项目的配置和创建出我们的项目；\u003c/li\u003e\n\u003cli\u003eVue CLI已经内置了webpack相关的配置，我们不需要从零来配置；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eVue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供：\u003c/p\u003e","title":"系统学习 Vue -- 3-脚手架学习"},{"content":"Vue 过渡与动画初体验 认识动画 在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验： React框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group； Vue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果； 我们来看一个案例： Hello World的显示和隐藏； 通过下面的代码实现，是不会有任何动画效果的； \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;显示/隐藏\u0026lt;/button\u0026gt; \u0026lt;h2 v-if=\u0026#34;show\u0026#34;\u0026gt;App组件\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { show: true } }, methods: { toggle() { this.show = !this.show; } } } \u0026lt;/script\u0026gt; 没有动画的情况下，整个内容的显示和隐藏会非常的生硬： 如果我们希望给单元素或者组件实现过渡动画，可以使用 transition内置组件来完成动画； Vue的 transition 动画 https://cn.vuejs.org/guide/built-ins/transition.html#transition\n\u0026lt;Transition\u0026gt; 会在一个元素或组件进入和离开 DOM 时应用动画。\n\u0026lt;Transition\u0026gt; 是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上。进入或离开可以由以下的条件之一触发：\n由 v-if 所触发的切换 由 v-show 所触发的切换 由特殊元素 \u0026lt;component\u0026gt; 切换的动态组件 改变特殊的 key 属性 以下是最基本用法的示例：\n\u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;Transition\u0026gt; \u0026lt;p v-if=\u0026#34;show\u0026#34;\u0026gt;hello\u0026lt;/p\u0026gt; \u0026lt;/Transition\u0026gt; /* 下面我们会解释这些 class 是做什么的 */ .v-enter-active, .v-leave-active { transition: opacity 0.5s ease; } .v-enter-from, .v-leave-to { opacity: 0; } \u0026lt;Transition\u0026gt; 仅支持单个元素或组件作为其插槽内容。如果内容是一个组件，这个组件必须仅有一个根元素。\n当一个 \u0026lt;Transition\u0026gt; 组件中的元素被插入或移除时，会发生下面这些事情：\nVue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡 class 会在适当的时机被添加和移除。 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。 如果没有探测到 CSS 过渡或动画、也没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧后执行。 基于 CSS 的过渡效果 CSS 过渡 class 一共有 6 个应用于进入与离开过渡效果的 CSS class。\nv-enter-from：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。 v-enter-active：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。 v-enter-to：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除。 v-leave-from：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。 v-leave-active：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。 v-leave-to：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除。 为过渡效果命名 我们可以给 \u0026lt;Transition\u0026gt; 组件传一个 name prop 来声明一个过渡效果名：\n\u0026lt;Transition name=\u0026#34;fade\u0026#34;\u0026gt; ... \u0026lt;/Transition\u0026gt; 对于一个有名字的过渡效果，对它起作用的过渡 class 会以其名字而不是 v 作为前缀。比如，上方例子中被应用的 class 将会是 fade-enter-active 而不是 v-enter-active。这个“fade”过渡的 class 应该是这样：\n.fade-enter-active, .fade-leave-active { transition: opacity 0.5s ease; } .fade-enter-from, .fade-leave-to { opacity: 0; } CSS 的 transition \u0026lt;Transition\u0026gt; 一般都会搭配原生 CSS 过渡一起使用，正如你在上面的例子中所看到的那样。这个 transition CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和速度曲线。\n下面是一个更高级的例子，它使用了不同的持续时间和速度曲线来过渡多个属性：\n\u0026lt;Transition name=\u0026#34;slide-fade\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;show\u0026#34;\u0026gt;hello\u0026lt;/p\u0026gt; \u0026lt;/Transition\u0026gt; /* 进入和离开动画可以使用不同 持续时间和速度曲线。 */ .slide-fade-enter-active { transition: all 0.3s ease-out; } .slide-fade-leave-active { transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1); } .slide-fade-enter-from, .slide-fade-leave-to { transform: translateX(20px); opacity: 0; } CSS 的 animation 帧动画, 可以指定在什么时间是什么状态!\n原生 CSS 动画和 CSS transition 的应用方式基本上是相同的，只有一点不同，那就是 *-enter-from 不是在元素插入后立即移除，而是在一个 animationend 事件触发时被移除。\n对于大多数的 CSS 动画，我们可以简单地在 *-enter-active 和 *-leave-active class 下声明它们。下面是一个示例：\n\u0026lt;Transition name=\u0026#34;bounce\u0026#34;\u0026gt; \u0026lt;p v-if=\u0026#34;show\u0026#34; style=\u0026#34;text-align: center;\u0026#34;\u0026gt; Hello here is some bouncy text! \u0026lt;/p\u0026gt; \u0026lt;/Transition\u0026gt; .bounce-enter-active { animation: bounce-in 0.5s; } .bounce-leave-active { animation: bounce-in 0.5s reverse; } @keyframes bounce-in { 0% { transform: scale(0); } 50% { transform: scale(1.25); } 100% { transform: scale(1); } } 自定义过渡 class 你也可以向 \u0026lt;Transition\u0026gt; 传递以下的 props 来指定自定义的过渡 class：\nenter-from-class enter-active-class enter-to-class leave-from-class leave-active-class leave-to-class 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css.\n你传入的这些 class 会覆盖相应阶段的默认 class 名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如 Animate.css：\n\u0026lt;script\u0026gt; export default { data() { return { show: true } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;show = !show\u0026#34;\u0026gt;Toggle\u0026lt;/button\u0026gt; \u0026lt;Transition name=\u0026#34;custom-classes\u0026#34; enter-active-class=\u0026#34;animate__animated animate__tada\u0026#34; leave-active-class=\u0026#34;animate__animated animate__bounceOutRight\u0026#34; \u0026gt; \u0026lt;p v-if=\u0026#34;show\u0026#34;\u0026gt;hello\u0026lt;/p\u0026gt; \u0026lt;/Transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; @import \u0026#34;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css\u0026#34;; \u0026lt;/style\u0026gt; 同时设置过渡和动画 Vue为了知道过渡的完成，内部是在监听 transitionend或 animationend，到底使用哪一个取决于元素应用的 CSS规则： 如果我们只是使用了其中的一个，那么Vue能自动识别类型并设置监听； 但是如果我们同时使用了过渡和动画呢？ 并且在这个情况下可能某一个动画执行结束时，另外一个动画还没有结束； 在这种情况下，我们可以设置 type 属性为 animation 或者 transition 来明确的告知Vue监听的类型； \u0026lt;Transition type=\u0026#34;animation\u0026#34;\u0026gt;...\u0026lt;/Transition\u0026gt; 深层级过渡与显式过渡时长 尽管过渡 class 仅能应用在 \u0026lt;Transition\u0026gt; 的直接子元素上，我们还是可以使用深层级的 CSS 选择器，在深层级的元素上触发过渡效果。\n\u0026lt;Transition name=\u0026#34;nested\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;show\u0026#34; class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; Hello \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/Transition\u0026gt; /* 应用于嵌套元素的规则 */ .nested-enter-active .inner, .nested-leave-active .inner { transition: all 0.3s ease-in-out; } .nested-enter-from .inner, .nested-leave-to .inner { transform: translateX(30px); opacity: 0; } /* ... 省略了其他必要的 CSS */ 我们甚至可以在深层元素上添加一个过渡延迟，从而创建一个带渐进延迟的动画序列：\n/* 延迟嵌套元素的进入以获得交错效果 */ .nested-enter-active .inner { transition-delay: 0.25s; } 然而，这会带来一个小问题。默认情况下，\u0026lt;Transition\u0026gt; 组件会通过监听过渡根元素上的第一个 transitionend 或者 animationend 事件来尝试自动判断过渡何时结束。而在嵌套的过渡中，期望的行为应该是等待所有内部元素的过渡完成。\n在这种情况下，你可以通过向 \u0026lt;Transition\u0026gt; 组件传入 duration prop 来显式指定过渡的持续时间 (以毫秒为单位)。总持续时间应该匹配延迟加上内部元素的过渡持续时间：\n\u0026lt;Transition :duration=\u0026#34;550\u0026#34;\u0026gt;...\u0026lt;/Transition\u0026gt; 如果有必要的话，你也可以用对象的形式传入，分开指定进入和离开所需的时间：\n\u0026lt;Transition :duration=\u0026#34;{ enter: 500, leave: 800 }\u0026#34;\u0026gt;...\u0026lt;/Transition\u0026gt; 过渡模式 在之前的例子中，进入和离开的元素都是在同时开始动画的，因此我们不得不将它们设为 position: absolute 以避免二者同时存在时出现的布局问题。\n然而，很多情况下这可能并不符合需求。我们可能想要先执行离开动画，然后在其完成之后再执行元素的进入动画。手动编排这样的动画是非常复杂的，好在我们可以通过向 \u0026lt;Transition\u0026gt; 传入一个 mode prop 来实现这个行为：\n\u0026lt;Transition mode=\u0026#34;out-in\u0026#34;\u0026gt; ... \u0026lt;/Transition\u0026gt; \u0026lt;Transition\u0026gt; 也支持 mode=\u0026quot;in-out\u0026quot;，虽然这并不常用。\n\u0026lt;Transition\u0026gt; 也可以作用于动态组件之间的切换：\n\u0026lt;Transition name=\u0026#34;fade\u0026#34; mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;activeComponent\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/Transition\u0026gt; 出现时过渡 如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 appear prop：\n\u0026lt;Transition appear\u0026gt; ... \u0026lt;/Transition\u0026gt; 元素间过渡 除了通过 v-if / v-show 切换一个元素，我们也可以通过 v-if / v-else / v-else-if 在几个组件间进行切换，只要确保任一时刻只会有一个元素被渲染即可：\n\u0026lt;Transition\u0026gt; \u0026lt;button v-if=\u0026#34;docState === \u0026#39;saved\u0026#39;\u0026#34;\u0026gt;Edit\u0026lt;/button\u0026gt; \u0026lt;button v-else-if=\u0026#34;docState === \u0026#39;edited\u0026#39;\u0026#34;\u0026gt;Save\u0026lt;/button\u0026gt; \u0026lt;button v-else-if=\u0026#34;docState === \u0026#39;editing\u0026#39;\u0026#34;\u0026gt;Cancel\u0026lt;/button\u0026gt; \u0026lt;/Transition\u0026gt; 示例 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;isShow = !isShow\u0026#34;\u0026gt;显示/隐藏\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;transition name=\u0026#34;why\u0026#34; mode=\u0026#34;out-in\u0026#34; appear\u0026gt; \u0026lt;component :is=\u0026#34;isShow ? \u0026#39;home\u0026#39;: \u0026#39;about\u0026#39;\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import Home from \u0026#39;./pages/Home.vue\u0026#39;; import About from \u0026#39;./pages/About.vue\u0026#39;; export default { components: { Home, About }, data() { return { isShow: true } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .app { width: 200px; margin: 0 auto; } .title { display: inline-block; } .why-enter-from, .why-leave-to { opacity: 0; } .why-enter-active, .why-leave-active { transition: opacity 1s ease; } .why-enter-active { animation: bounce 1s ease; } .why-leave-active { animation: bounce 1s ease reverse; } @keyframes bounce { 0% { transform: scale(0) } 50% { transform: scale(1.2); } 100% { transform: scale(1); } } \u0026lt;/style\u0026gt; JavaScript 钩子 你可以通过监听 \u0026lt;Transition\u0026gt; 组件事件的方式在过渡过程中挂上钩子函数：\n\u0026lt;Transition @before-enter=\u0026#34;onBeforeEnter\u0026#34; @enter=\u0026#34;onEnter\u0026#34; @after-enter=\u0026#34;onAfterEnter\u0026#34; @enter-cancelled=\u0026#34;onEnterCancelled\u0026#34; @before-leave=\u0026#34;onBeforeLeave\u0026#34; @leave=\u0026#34;onLeave\u0026#34; @after-leave=\u0026#34;onAfterLeave\u0026#34; @leave-cancelled=\u0026#34;onLeaveCancelled\u0026#34; \u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/Transition\u0026gt; export default { // ... methods: { // 在元素被插入到 DOM 之前被调用 // 用这个来设置元素的 \u0026#34;enter-from\u0026#34; 状态 onBeforeEnter(el) {}, // 在元素被插入到 DOM 之后的下一帧被调用 // 用这个来开始进入动画 onEnter(el, done) { // 调用回调函数 done 表示过渡结束 // 如果与 CSS 结合使用，则这个回调是可选参数 done() }, // 当进入过渡完成时调用。 onAfterEnter(el) {}, onEnterCancelled(el) {}, // 在 leave 钩子之前调用 // 大多数时候，你应该只会用到 leave 钩子 onBeforeLeave(el) {}, // 在离开过渡开始时调用 // 用这个来开始离开动画 onLeave(el, done) { // 调用回调函数 done 表示过渡结束 // 如果与 CSS 结合使用，则这个回调是可选参数 done() }, // 在离开过渡完成、 // 且元素已从 DOM 中移除时调用 onAfterLeave(el) {}, // 仅在 v-show 过渡中可用 onLeaveCancelled(el) {} } } \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;isShow = !isShow\u0026#34;\u0026gt;显示/隐藏\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;transition @before-enter=\u0026#34;beforeEnter\u0026#34; @enter=\u0026#34;enter\u0026#34; @after-enter=\u0026#34;afterEnter\u0026#34; @before-leave=\u0026#34;beforeLeave\u0026#34; @leave=\u0026#34;leave\u0026#34; @afterLeave=\u0026#34;afterLeave\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;title\u0026#34; v-if=\u0026#34;isShow\u0026#34;\u0026gt;Hello World\u0026lt;/h2\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { isShow: true } }, methods: { beforeEnter() { console.log(\u0026#34;beforeEnter\u0026#34;); }, enter() { console.log(\u0026#34;enter\u0026#34;); }, afterEnter() { console.log(\u0026#34;afterEnter\u0026#34;); }, beforeLeave() { console.log(\u0026#34;beforeLeave\u0026#34;); }, leave() { console.log(\u0026#34;leave\u0026#34;); }, afterLeave() { console.log(\u0026#34;afterLeave\u0026#34;); } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .title { display: inline-block; } \u0026lt;/style\u0026gt; 这些钩子可以与 CSS 过渡或动画结合使用，也可以单独使用。\n在使用仅由 JavaScript 执行的动画时，最好是添加一个 :css=\u0026quot;false\u0026quot; prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。\n\u0026lt;Transition ... :css=\u0026#34;false\u0026#34; \u0026gt; ... \u0026lt;/Transition\u0026gt; 在有了 :css=\u0026quot;false\u0026quot; 后，我们就自己全权负责控制什么时候过渡结束了。这种情况下对于 @enter 和 @leave 钩子来说，回调函数 done 就是必须的。否则，钩子将被同步调用，过渡将立即完成。\n这里是使用 GreenSock 库执行动画的一个示例，你也可以使用任何你想要的库，比如 Anime.js 或者 Motion One。\n第三方库的使用 animate.css https://animate.style/\n如果我们手动一个个来编写这些动画，那么效率是比较低的，所以在开发中我们可能会引用一些第三方库的动画库， 比如animate.css。 Animate.css是一个已经准备好的、跨平台的动画库为我们的web项目，对于强调、主页、滑动、注意力引导 非常有用； 如何使用?\n安装animate.css：\nnpm install animate.css 在main.js中导入animate.css：\nimport { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./test/App.vue\u0026#39; import \u0026#39;animate.css\u0026#39; createApp(App).mount(\u0026#39;#app\u0026#39;) 接下来在使用的时候我们有两种用法：\n用法一：直接使用animate库中定义的 keyframes 动画； 用法二：直接使用animate库提供给我们的类； 使用参考: 自定义过渡 class\n\u0026lt;transition enter-active-class=\u0026#34;animate__animated animate__backInDown\u0026#34; leave-active-class=\u0026#34;animate__animated animate__bounceOutDown\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;title\u0026#34; v-if=\u0026#34;isShow\u0026#34;\u0026gt;Hello World\u0026lt;/h2\u0026gt; \u0026lt;/transition\u0026gt; gsap https://gsap.com/docs/v3/Installation/\nhttps://gsap.framer.wiki/stated \u0026ndash; 中文文档\n某些情况下我们希望通过JavaScript来实现一些动画的效果，这个时候我们可以选择使用gsap库来完成。 什么是gsap呢？ GSAP是The GreenSock Animation latform（GreenSock动画平台）的缩写； 它可以通过JavaScript为CSS属性、SVG、Canvas等设置动画，并且是浏览器兼容的； 如何使用\n安装 npm install gsap 调用 api \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;isShow = !isShow\u0026#34;\u0026gt;显示/隐藏\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;transition @enter=\u0026#34;enter\u0026#34; @leave=\u0026#34;leave\u0026#34; :css=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;h2 class=\u0026#34;title\u0026#34; v-if=\u0026#34;isShow\u0026#34;\u0026gt;Hello World\u0026lt;/h2\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import gsap from \u0026#39;gsap\u0026#39;; export default { data() { return { isShow: true, } }, methods: { enter(el, done) { console.log(\u0026#34;enter\u0026#34;); gsap.from(el, { scale: 0, x: 200, onComplete: done }) }, leave(el, done) { console.log(\u0026#34;leave\u0026#34;); gsap.to(el, { scale: 0, x: 200, onComplete: done }) } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .title { display: inline-block; } \u0026lt;/style\u0026gt; enter函数接收两个参数：el和done。el是正在进入的元素，done是一个在进入过渡完成时应该被调用的函数。 onComplete: done部分在动画完成时调用done函数。这是必要的，以便让Vue知道过渡已经完成。如果不调用done，Vue可能无法正确地确定过渡的结束，这可能会导致意外的行为。 在使用仅由 JavaScript 执行的动画时，最好是添加一个 :css=\u0026quot;false\u0026quot; prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。 gsap 数字递增效果 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; step=\u0026#34;100\u0026#34; v-model=\u0026#34;counter\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数: {{showNumber.toFixed(0)}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { gsap } from \u0026#39;gsap\u0026#39;; export default { data() { return { counter: 0, showNumber: 0 }; }, watch: { counter(newValue) { gsap.to(this, { duration: 1, showNumber: newValue }); } } }; \u0026lt;/script\u0026gt; 认识列表的过渡 目前为止，过渡动画我们只要是针对单个元素或者组件的： 要么是单个节点； 要么是同一时间渲染多个节点中的一个； 那么如果希望渲染的是一个列表，并且该列表中添加删除数据也希望有动画执行呢？ 这个时候我们要使用 组件来完成； 使用 有如下的特点： 默认情况下，它不会渲染一个元素的包裹器，但是你可以指定一个元素并以 tag attribute 进行渲染； 过渡模式不可用，因为我们不再相互切换特有的元素； 内部元素总是需要提供唯一的 key attribute 值； CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身； 基本使用 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;addNum\u0026#34;\u0026gt;添加数字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;removeNum\u0026#34;\u0026gt;删除数字\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;shuffleNum\u0026#34;\u0026gt;数字洗牌\u0026lt;/button\u0026gt; \u0026lt;transition-group tag=\u0026#34;p\u0026#34; name=\u0026#34;why\u0026#34;\u0026gt; \u0026lt;span v-for=\u0026#34;item in numbers\u0026#34; :key=\u0026#34;item\u0026#34; class=\u0026#34;item\u0026#34;\u0026gt; {{item}} \u0026lt;/span\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import _ from \u0026#39;lodash\u0026#39;; export default { data() { return { numbers: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], numCounter: 10 } }, methods: { addNum() { // this.numbers.push(this.numCounter++) this.numbers.splice(this.randomIndex(), 0, this.numCounter++) }, removeNum() { this.numbers.splice(this.randomIndex(), 1) }, shuffleNum() { this.numbers = _.shuffle(this.numbers); }, randomIndex() { return Math.floor(Math.random() * this.numbers.length) } }, } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .item { margin-right: 10px; display: inline-block; /* 设置了元素为内联块级元素。 */ } .why-enter-from, .why-leave-to { opacity: 0; transform: translateY(30px); } .why-enter-active, .why-leave-active { transition: all 1s ease; } .why-leave-active { position: absolute; } .why-move { transition: transform 1s ease; } \u0026lt;/style\u0026gt; methods对象定义了四个方法：\naddNum方法在numbers数组的随机位置插入一个新的数字，然后numCounter加1。 removeNum方法从numbers数组的随机位置删除一个数字。 shuffleNum方法使用lodash的shuffle函数打乱numbers数组的顺序。 randomIndex方法返回一个numbers数组的随机索引 列表过渡的移动动画 在上面的案例中虽然新增的或者删除的节点是有动画的，但是对于哪些其他需要移动的节点是没有动画的：\n我们可以通过使用一个新增的 v-move 的class来完成动画； 它会在元素改变位置的过程中应用； 像之前的名字一样，我们可以通过name来自定义前缀; \u0026lt;TransitionGroup\u0026gt; 支持通过 CSS transform 控制移动效果。当一个子节点在屏幕上的位置在更新之后发生变化时，它会被添加一个使其位移的 CSS class (基于 name attribute 推导，或使用 move-class prop 显式配置)。如果使其位移的 class 被添加时 CSS 的 transform 属性是“可过渡的”，那么该元素会基于 FLIP 技巧平滑地到达动画终点。\nhttps://cn.vuejs.org/api/built-in-components.html#transitiongroup\n.why-move { transition: transform 1s ease; } 演练 =\u0026gt; 列表的交替动画 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input v-model=\u0026#34;keyword\u0026#34;\u0026gt; \u0026lt;transition-group tag=\u0026#34;ul\u0026#34; name=\u0026#34;why\u0026#34; :css=\u0026#34;false\u0026#34; @before-enter=\u0026#34;beforeEnter\u0026#34; @enter=\u0026#34;enter\u0026#34; @leave=\u0026#34;leave\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in showNames\u0026#34; :key=\u0026#34;item\u0026#34; :data-index=\u0026#34;index\u0026#34;\u0026gt; {{item}} \u0026lt;/li\u0026gt; \u0026lt;/transition-group\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import gsap from \u0026#39;gsap\u0026#39;; export default { data() { return { names: [\u0026#34;abc\u0026#34;, \u0026#34;cba\u0026#34;, \u0026#34;nba\u0026#34;, \u0026#34;why\u0026#34;, \u0026#34;lilei\u0026#34;, \u0026#34;hmm\u0026#34;, \u0026#34;kobe\u0026#34;, \u0026#34;james\u0026#34;], keyword: \u0026#34;\u0026#34; } }, computed: { showNames() { return this.names.filter(item =\u0026gt; item.indexOf(this.keyword) !== -1) } }, methods: { beforeEnter(el) { el.style.opacity = 0; el.style.height = 0; }, enter(el, done) { gsap.to(el, { opacity: 1, height: \u0026#34;1.5em\u0026#34;, delay: el.dataset.index * 0.5, onComplete: done }) }, leave(el, done) { gsap.to(el, { opacity: 0, height: 0, delay: el.dataset.index * 0.5, onComplete: done }) } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; /* .why-enter-from, .why-leave-to { opacity: 0; } .why-enter-active, .why-leave-active { transition: opacity 1s ease; } */ \u0026lt;/style\u0026gt; 路由使用 关于路由 认识前端路由 路由其实是网络工程中的一个术语： 在架构一个网络时，非常重要的两个设备就是路由器和交换机。 当然，目前在我们生活中路由器也是越来越被大家所熟知，因为我们生活中都会用到路由器： 路由器的主要功能是维护一个映射表，这个映射表决定了数据的流向。在网络中，路由器通过这个映射表来确定数据包的传输路径，使得数据能够按照设定的规则正确地传输到目的地。 路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段： 后端路由阶段； 前后端分离阶段； 单页面富应用（SPA）； 后端路由阶段 早期的网站开发整个HTML页面是由服务器来渲染的. 服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示. 一个页面有自己对应的网址, 也就是URL； URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller(控制器)进行处理； Controller进行各种处理, 最终生成HTML或者数据, 返回给前端. 上面的这种操作, 就是后端路由： 当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户端. 这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化. 后端路由的缺点: 一种情况是整个页面的模块由后端人员来编写和维护的； 另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码； 而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情； 前后端分离阶段 前端渲染的理解： 每次请求涉及到的静态资源都会从静态资源服务器获取，这些资源包括HTML+CSS+JS，然后在前端对这些请求回来的资源进行渲染； 需要注意的是，客户端的每一次请求，都会从静态资源服务器请求文件； 同时可以看到，和之前的后端路由不同，这时后端只是负责提供API了； 前后端分离阶段： 随着Ajax的出现, 有了前后端分离的开发模式； 后端只提供API来返回数据，前端通过Ajax获取数据，并且可以通过JavaScript将数据渲染到页面中； 这样做最大的优点就是前后端责任的清晰，后端专注于数据上，前端专注于交互和可视化上； 并且当移动端(iOS/Android)出现后，后端不需要进行任何处理，依然使用之前的一套API即可； 目前比较少的网站采用这种模式开发（jQuery开发模式）； 单页面富应用（SPA） 随着前端框架（如AngularJS、React、Vue等）的兴起，单页面富应用成为主流。单页面富应用（SPA）是一种Web应用程序的架构模式，它通过动态加载页面内容，实现在单个HTML页面上切换视图和更新内容，而无需每次都从服务器请求新的页面。这种方式提高了用户体验和应用性能，因为页面只在初始化时加载一次，之后的页面切换和内容更新都是通过异步加载数据和更新页面内容来实现的。常见的前端框架如AngularJS、React和Vue等都支持SPA的开发模式。\nVue-router 简介 官网: https://router.vuejs.org/zh/\nVue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括：\n嵌套路由映射 动态路由选择 模块化、基于组件的路由配置 路由参数、查询、通配符 展示由 Vue.js 的过渡系统提供的过渡效果 细致的导航控制 自动激活 CSS 类的链接 HTML5 history 模式或 hash 模式 可定制的滚动行为 URL 的正确编码 具体使用示例：\n网易云音乐 https://music.163.com/\n单页面应用(SPA): 所有功能在一个 html 页面上实现\n前端路由作用: 实现业务场景切换\n优点： 简单易用 支持嵌套路由 支持路由参数、查询、动态路由等 缺点： 对于大型单页应用可能不够灵活 在处理复杂路由时可能需要额外的插件或工具 路由初体验 Vue Router 支持两种路由模式：\nHash 模式： 使用 URL 中的 ##来管理路由，适用于不需要服务端支持的单页应用。createWebHashHistory是 Vue Router 提供的一种路由模式，它基于 URL 中的 hash（#）来管理路由。这种模式在不需要服务器端支持的情况下可以工作 History 模式： 使用 HTML5 History API 来管理路由，可以去掉 URL 中的 #，需要服务器端支持来处理路由createWebHistory 是 Vue Router 提供的基于 HTML5 History API 的路由模式。这种模式需要服务器端支持来处理路由，但可以去掉 URL 中的 #，看起来更加干净。 用 Vue + Vue Router 创建单页应用非常简单：通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。下面是一个基本的例子：\n\u0026lt;script src=\u0026#34;https://unpkg.com/vue@3\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/vue-router@4\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello App!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;!--使用 router-link 组件进行导航 --\u0026gt; \u0026lt;!--通过传递 `to` 来指定链接 --\u0026gt; \u0026lt;!--`\u0026lt;router-link\u0026gt;` 将呈现一个带有正确 `href` 属性的 `\u0026lt;a\u0026gt;` 标签--\u0026gt; \u0026lt;router-link to=\u0026#34;/\u0026#34;\u0026gt;Go to Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/about\u0026#34;\u0026gt;Go to About\u0026lt;/router-link\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!-- 路由出口 --\u0026gt; \u0026lt;!-- 路由匹配到的组件将渲染在这里 --\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 定义 (路由) 组件。 // 可以从其他文件 import 进来 const Home = { template: \u0026#39;\u0026lt;div\u0026gt;Home\u0026lt;/div\u0026gt;\u0026#39; } const About = { template: \u0026#39;\u0026lt;div\u0026gt;About\u0026lt;/div\u0026gt;\u0026#39; } // 定义路由 // 每个路由应该映射一个组件。 其中\u0026#34;component\u0026#34; 可以是 // 通过 Vue.extend() 创建的组件构造器， // 或者，只是一个组件配置对象。 const routes = [ { path: \u0026#39;/\u0026#39;, component: Home }, { path: \u0026#39;/about\u0026#39;, component: About } ] // 创建 router 实例 // 你可以在这里传入配置参数 // 我们在这里使用 `routes` 配置参数 const router = VueRouter.createRouter({ history: VueRouter.createWebHashHistory(), routes // `routes: routes` 的缩写 }) // 创建和挂载根实例 // 记得要通过 router 配置参数注入路由， // 从而让整个应用都有路由功能 const app = Vue.createApp({}) app.use(router) app.mount(\u0026#39;#app\u0026#39;) \u0026lt;/script\u0026gt; router-link 请注意，我们没有使用常规的 a 标签，而是使用一个自定义组件 router-link 来创建链接。这使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。我们将在后面看到如何从这些功能中获益。\nrouter-view router-view 将显示与 URL 对应的组件。你可以把它放在任何地方，以适应你的布局。\n安装以及使用 安装\nnpm install vue-router 创建 router/index.js 并在其中编辑基本配置(默认你已经注册了 components 中的两个文件)\nimport { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; const routes = [ { path: \u0026#39;/\u0026#39;, component: () =\u0026gt; import(\u0026#39;../components/login.vue\u0026#39;) }, { path: \u0026#39;/req\u0026#39;, component: () =\u0026gt; import(\u0026#39;../components/req.vue\u0026#39;) } ] const router = createRouter({ history: createWebHistory(), routes }) export default router 在 src/App.vue 中引入 import router from \u0026#39;../router\u0026#39; createApp(App).use(router).mount(\u0026#39;#app\u0026#39;) 当然, 我们需要一个 router-view 显示与 URL 对应的组件, 一般会在 src/App.vue 中做如下配置, 当然你可以把它放在任何地方，以适应你的布局。 \u0026lt;template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/template\u0026gt; 我们也可以在其中使用 router-link \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;小满最骚\u0026lt;/h1\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!--使用 router-link 组件进行导航 --\u0026gt; \u0026lt;!--通过传递 `to` 来指定链接 --\u0026gt; \u0026lt;!--`\u0026lt;router-link\u0026gt;` 将呈现一个带有正确 `href` 属性的 `\u0026lt;a\u0026gt;` 标签--\u0026gt; \u0026lt;router-link tag=\u0026#34;div\u0026#34; to=\u0026#34;/\u0026#34;\u0026gt;跳转a\u0026lt;/router-link\u0026gt; \u0026lt;router-link tag=\u0026#34;div\u0026#34; style=\u0026#34;margin-left:200px\u0026#34; to=\u0026#34;/register\u0026#34;\u0026gt;跳转b\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;!-- 路由出口 --\u0026gt; \u0026lt;!-- 路由匹配到的组件将渲染在这里 --\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 带参数的动态路由匹配 很多时候，我们需要将给定匹配模式的路由映射到同一个组件。例如，我们可能有一个 User 组件，它应该对所有用户进行渲染，但用户 ID 不同。在 Vue Router 中，我们可以在路径中使用一个动态字段来实现，我们称之为 路径参数 ：\nconst User = { template: \u0026#39;\u0026lt;div\u0026gt;User\u0026lt;/div\u0026gt;\u0026#39;, } // 这些都会传递给 `createRouter` const routes = [ // 动态字段以冒号开始 { path: \u0026#39;/users/:id\u0026#39;, component: User }, ] 现在像 /users/johnny 和 /users/jolyne 这样的 URL 都会映射到同一个路由。\n路径参数 用冒号 : 表示。当一个路由被匹配时，它的 params 的值将在每个组件中以 this.$route.params 的形式暴露出来。因此，我们可以通过更新 User 的模板来呈现当前的用户 ID：\nconst User = { template: \u0026#39;\u0026lt;div\u0026gt;User {{ $route.params.id }}\u0026lt;/div\u0026gt;\u0026#39;, } 你可以在同一个路由中设置有多个 路径参数，它们会映射到 $route.params 上的相应字段。例如：\n匹配模式 匹配路径 $route.params /users/:username /users/eduardo { username: 'eduardo' } /users/:username/posts/:postId /users/eduardo/posts/123 { username: 'eduardo', postId: '123' } 除了 $route.params 之外，$route 对象还公开了其他有用的信息，如 $route.query（如果 URL 中存在参数）、$route.hash 等。你可以在 API 参考中查看完整的细节。\n以下是一个小 Demo\n// router.js import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; import UserPost from \u0026#39;./views/UserPost.vue\u0026#39; export const router = createRouter({ history: createWebHistory(), routes: [{ path: \u0026#39;/users/:username/posts/:postId\u0026#39;, component: UserPost }], }) \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/users/eduardo/posts/1\u0026#34; \u0026gt;/users/eduardo/posts/1\u0026lt;/router-link \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;router-link to=\u0026#34;/users/eduardo/posts/20\u0026#34; \u0026gt;/users/eduardo/posts/20\u0026lt;/router-link \u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;App\u0026#34;, }; \u0026lt;/script\u0026gt; \u0026lt;!-- ./views/UserPost.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; User {{ $route.params.username }} with post {{ $route.params.postId }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 声明式/ 编程式导航 声明式导航 基础使用/ 命名路由 除了 path 之外，你还可以为任何路由提供 name。这有以下优点：\nhttps://router.vuejs.org/zh/guide/essentials/named-routes.html\n没有硬编码的 URL\nparams 的自动编码/解码。\n防止你在 url中出现打字错误。\n绕过路径排序（如显示一个）\n这跟代码调用 router.push() 是一回事：\nrouter.push({name: \u0026#39;user\u0026#39;, params: {username: \u0026#39;erina\u0026#39;}}) // 在这两种情况下，路由将导航到路径 /user/erina。 const routes:Array\u0026lt;RouteRecordRaw\u0026gt; = [ { path:\u0026#34;/\u0026#34;, name:\u0026#34;Login\u0026#34;, component:()=\u0026gt; import(\u0026#39;../components/login.vue\u0026#39;) }, { path:\u0026#34;/reg\u0026#34;, name:\u0026#34;Reg\u0026#34;, component:()=\u0026gt; import(\u0026#39;../components/reg.vue\u0026#39;) } ] 跳转方式需要改变 变为对象并且有对应name\n两种跳转方式有区别, a 标签有新的网络请求, 会刷新整个页面\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;router-link :to=\u0026#34;{name: \u0026#39;Login\u0026#39;}\u0026#34;\u0026gt;Home\u0026lt;/router-link\u0026gt; \u0026lt;router-link :to=\u0026#34;{name: \u0026#39;Req\u0026#39;}\u0026#34;\u0026gt;Req\u0026lt;/router-link\u0026gt; \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;/req\u0026#34;\u0026gt;Req\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 跳转传参 目标: 在跳转路由时, 可以给路由对应的组件内传值\n在 router-link 上的 to 属性传值, 语法格式如下\n/path?参数名=值 /path/值 – 需要路由对象提前配置 path: \u0026quot;/path/参数名\u0026quot; 对应页面组件接收传递过来的值\nroute.query.参数名 route.params.参数名 1、新建 views/Part2.vue - 接收路由上传递的参数和值\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;我的好友\u0026lt;/p\u0026gt; \u0026lt;!-- query 查询 ？ 号后面的。 params 是获取 url : 中的参数--\u0026gt; \u0026lt;p\u0026gt;人名(path --\u0026gt; query): {{ route.query?.name }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;人名(?后参数 --\u0026gt; params): {{ route.params?.name }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // 目标: 声明式导航 - 基础使用 // 本质: vue-router 提供的全局组件 \u0026#34;router-link\u0026#34; 替代a标签 // 1. router-link 替代 a 标签 // 2. to 属性 替代 href 属性 // 好处: router-link 自带高亮的类名(激活时类名) // 3. 对激活的类名做出样式的编写 import {useRoute} from \u0026#39;vue-router\u0026#39; const route = useRoute() \u0026lt;/script\u0026gt; 2、修改路由定义\nconst routes = [ {\u0026#39;path\u0026#39;: \u0026#39;/find\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/Find.vue\u0026#39;)}, {\u0026#39;path\u0026#39;: \u0026#39;/my\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/My.vue\u0026#39;)}, {\u0026#39;path\u0026#39;: \u0026#39;/part\u0026#39;, name: \u0026#39;Part\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/Part.vue\u0026#39;)}, { path: \u0026#34;/part/:name\u0026#34;, // 有:的路径代表要接收具体的值 component: () =\u0026gt; import(\u0026#39;../views/Part2.vue\u0026#39;) }, ] 3、修改 App.vue 进行跳转\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;footer_wrap\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;a href=\u0026#34;#/find\u0026#34;\u0026gt;发现音乐\u0026lt;/a\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;a href=\u0026#34;#/my\u0026#34;\u0026gt;我的音乐\u0026lt;/a\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;a href=\u0026#34;#/part\u0026#34;\u0026gt;朋友\u0026lt;/a\u0026gt;--\u0026gt; \u0026lt;router-link to=\u0026#34;/find\u0026#34;\u0026gt;发现音乐\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/my\u0026#34;\u0026gt;我的音乐\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/part\u0026#34;\u0026gt;朋友\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/part?name=小传\u0026#34;\u0026gt;朋友-小传\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/part/小智?name=小智2\u0026#34;\u0026gt;朋友-小智\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 总结:\n?key=value 用 $route.query.key 取值 /值 提前在路由规则 /path/:key 用 $route.params.key 取值 query 是查询参数, params 是 path 路径 有:的路径代表要接收具体的值, 不然会报警告 在这个特定的场景中，我们在括号之间使用了自定义正则表达式，并将pathMatch 参数标记为可选可重复。这样做是为了让我们在需要的时候，可以通过将 path 拆分成一个数组，直接导航到路由\n捕获所有路由或 404 Not found 路由 常规参数只匹配 url 片段之间的字符，用 / 分隔。如果我们想匹配任意路径，我们可以使用自定义的 路径参数 正则表达式，在 路径参数 后面的括号中加入 正则表达式 :\nconst routes = [ // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下 { path: \u0026#39;/:pathMatch(.*)*\u0026#39;, name: \u0026#39;NotFound\u0026#39;, component: NotFound }, // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下 { path: \u0026#39;/user-:afterUser(.*)\u0026#39;, component: UserGeneric }, ] 在这个特定的场景中，我们在括号之间使用了自定义正则表达式，并将pathMatch 参数标记为可选可重复。这样做是为了让我们在需要的时候，可以通过将 path 拆分成一个数组，直接导航到路由：\nthis.$router.push({ name: \u0026#39;NotFound\u0026#39;, // 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。 params: { pathMatch: this.$route.path.substring(1).split(\u0026#39;/\u0026#39;) }, // 保留现有的查询和 hash 值，如果有的话 query: this.$route.query, hash: this.$route.hash, }) 更多内容请参见重复参数部分。\n一般使用如下\nconst routes = [ // ...省略了其他配置 // 404在最后(规则是从前往后逐个比较path) { path: \u0026#34;/:pathMatch(.*)*\u0026#34;, component: () =\u0026gt; import(\u0026#39;../views/NotFound.vue\u0026#39;) } ] 编程式导航 除了使用 \u0026lt;router-link\u0026gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n导航到不同的位置 注意：在 Vue 实例中，你可以通过 $router 访问路由实例。因此你可以调用 $router.push。\n想要导航到不同的 URL，可以使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。\n当你点击 \u0026lt;router-link\u0026gt; 时，内部会调用这个方法，所以点击 \u0026lt;router-link :to=\u0026quot;...\u0026quot;\u0026gt; 相当于调用 router.push(...) ：\n声明式 编程式 \u0026lt;router-link :to=\u0026quot;...\u0026quot;\u0026gt; router.push(...) 该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n// 字符串路径 router.push(\u0026#39;/users/eduardo\u0026#39;); // 带有路径的对象 router.push({path: \u0026#39;/users/eduardo\u0026#39;}); // 命名的路由，并加上参数，让路由建立 url router.push({name: \u0026#39;user\u0026#39;, params: {username: \u0026#39;eduardo\u0026#39;}}); // 带查询参数，结果是 /register?plan=private router.push({path: \u0026#39;/register\u0026#39;, query: {plan: \u0026#39;private\u0026#39;}}); // 带 hash，结果是 /about.md#team router.push({path: \u0026#39;/about.md\u0026#39;, hash: \u0026#39;#team\u0026#39;}); 注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ：\nconst username = \u0026#39;eduardo\u0026#39; // 我们可以手动建立 url，但我们必须自己处理编码 router.push(`/user/${username}`) // -\u0026gt; /user/eduardo // 同样 router.push({path: `/user/${username}`}) // -\u0026gt; /user/eduardo // 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益 router.push({name: \u0026#39;user\u0026#39;, params: {username}}) // -\u0026gt; /user/eduardo // `params` 不能与 `path` 一起使用 router.push({path: \u0026#39;/user\u0026#39;, params: {username}}) // -\u0026gt; /user 当指定 params 时，可提供 string 或 number 参数（或者对于可重复的参数 可提供一个数组）。任何其他类型（如 undefined、false 等）都将被自动字符串化 。对于可选参数 ，你可以提供一个空字符串（\u0026quot;\u0026quot;）来跳过它。\n由于属性 to 与 router.push 接受的对象种类相同，所以两者的规则完全相同。\n基础使用 语法:\nrouter.push({ path: \u0026#34;路由路径\u0026#34;, // 都去 router/index.js 定义 name: \u0026#34;路由名\u0026#34; }) src/router/index.js - 路由数组里, 给路由起名字 import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; const routes = [ { path: \u0026#34;/part/:name\u0026#34;, // 有:的路径代表要接收具体的值 name: \u0026#39;Part2\u0026#39;, component: () =\u0026gt; import(\u0026#39;../components/HelloWorld.vue\u0026#39;) }, ] const router = createRouter({ history: createWebHistory(), routes }) export default router App.vue - 换成 span 配合js的编程式导航跳转 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;footer_wrap\u0026#34;\u0026gt; \u0026lt;a @click=\u0026#34;change_router(\u0026#39;/part\u0026#39;, \u0026#39;Part\u0026#39;)\u0026#34;\u0026gt;朋友\u0026lt;/a\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;a @click=\u0026#34;change1\u0026#34;\u0026gt;朋友-小传\u0026lt;/a\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;a @click=\u0026#34;change2\u0026#34;\u0026gt;朋友-小智\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import {useRouter} from \u0026#39;vue-router\u0026#39;; const router = useRouter(); const change_router = (path, name) =\u0026gt; { router.push({name: name}); }; const change1 = () =\u0026gt; { router.push({ name: \u0026#39;Part2\u0026#39;, params: { name: \u0026#39;小传\u0026#39;, }, }); }; const change2 = () =\u0026gt; { router.push( { name: \u0026#39;Part2\u0026#39;, params: { name: \u0026#39;小智\u0026#39; }, query: { name: \u0026#39;小智\u0026#39;, }, }, ); }; \u0026lt;/script\u0026gt; 横跨历史 该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 window.history.go(n)。\n// 向前移动一条记录，与 router.forward() 相同 router.go(1) // 返回一条记录，与 router.back() 相同 router.go(-1) // 前进 3 条记录 router.go(3) // 如果没有那么多记录，静默失败 router.go(-100) router.go(100) 替换当前位置 它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。\n声明式 编程式 \u0026lt;router-link :to=\u0026quot;...\u0026quot; replace\u0026gt; router.replace(...) 也可以直接在传递给 router.push 的 routeLocation 中增加一个属性 replace: true ：\nrouter.push({path: \u0026#39;/home\u0026#39;, replace: true}) // 相当于 router.replace({path: \u0026#39;/home\u0026#39;}) 重定向 重定向也是通过 routes 配置来完成，下面例子是从 /home 重定向到 /：\nconst routes = [{path: \u0026#39;/home\u0026#39;, redirect: \u0026#39;/\u0026#39;}] 重定向的目标也可以是一个命名的路由：\nconst routes = [{path: \u0026#39;/home\u0026#39;, redirect: {name: \u0026#39;homepage\u0026#39;}}] 甚至是一个方法，动态返回重定向目标：\nconst routes = [ { // /search/screens -\u0026gt; /search?q=screens path: \u0026#39;/search/:searchText\u0026#39;, redirect: to =\u0026gt; { // 方法接收目标路由作为参数 // return 重定向的字符串路径/路径对象 return {path: \u0026#39;/search\u0026#39;, query: {q: to.params.searchText}} }, }, { path: \u0026#39;/search\u0026#39;, // ... }, ] 例如: 网页默认打开, 匹配路由 \u0026quot;/\u0026quot;, 强制切换到 \u0026quot;/find\u0026quot; 上\nconst routes = [ { path: \u0026#34;/\u0026#34;, // 默认hash值路径 redirect: \u0026#34;/find\u0026#34; // 重定向到 /find // 浏览器 url 中 ## 后的路径被改变成 /find -重新匹配数组规则 }, ] 总结: 强制重定向后, 还会重新来数组里匹配一次规则\n别名 有时候，同一个路径可能需要多个路由，此时可以使用 alias 创建别名。\nconst routes = [ { path: \u0026#39;/foo\u0026#39;, component: Foo, alias: \u0026#39;/bar\u0026#39; }, ] 有个通用的场景是，你可能要把 src 目录下的 @ 指向 src 目录，这时候就可以使用别名：\n在 vue.config.js 中配置别名\nmodule.exports = { configureWebpack: { resolve: { alias: { \u0026#39;@\u0026#39;: path.resolve(__dirname, \u0026#39;src\u0026#39;) } } } } 路由进阶 路由嵌套 一些应用程序的 UI 由多层嵌套的组件组成。在这种情况下，URL 的片段通常对应于特定的嵌套组件结构，例如：\n/user/johnny/profile /user/johnny/posts +------------------+ +-----------------+ | User | | User | | +--------------+ | | +-------------+ | | | Profile | | +------------\u0026gt; | | Posts | | | | | | | | | | | +--------------+ | | +-------------+ | +------------------+ +-----------------+ 通过 Vue Router，你可以使用嵌套路由配置来表达这种关系。\n接着上节创建的 app ：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; const User = { template: \u0026#39;\u0026lt;div\u0026gt;User {{ $route.params.id }}\u0026lt;/div\u0026gt;\u0026#39;, } // 这些都会传递给 `createRouter` const routes = [{ path: \u0026#39;/user/:id\u0026#39;, component: User }] 这里的 \u0026lt;router-view\u0026gt; 是一个顶层的 router-view。它渲染顶层路由匹配的组件。同样地，一个被渲染的组件也可以包含自己嵌套的 \u0026lt;router-view\u0026gt;。例如，如果我们在 User 组件的模板内添加一个 \u0026lt;router-view\u0026gt;：\nconst User = { template: ` \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;User {{ $route.params.id }}\u0026lt;/h2\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; `, } 要将组件渲染到这个嵌套的 router-view 中，我们需要在路由中配置 children：\nconst routes = [ { path: \u0026#39;/user/:id\u0026#39;, component: User, children: [ { // 当 /user/:id/profile 匹配成功 // UserProfile 将被渲染到 User 的 \u0026lt;router-view\u0026gt; 内部 path: \u0026#39;profile\u0026#39;, component: UserProfile, }, { // 当 /user/:id/posts 匹配成功 // UserPosts 将被渲染到 User 的 \u0026lt;router-view\u0026gt; 内部 path: \u0026#39;posts\u0026#39;, component: UserPosts, }, ], }, ] 注意，以 / 开头的嵌套路径将被视为根路径。这允许你利用组件嵌套，而不必使用嵌套的 URL。\n如你所见，children 配置只是另一个路由数组，就像 routes 本身一样。因此，你可以根据自己的需要，不断地嵌套视图。\n此时，按照上面的配置，当你访问 /user/eduardo 时，在 User 的 router-view 里面什么都不会呈现，因为没有匹配到嵌套路由。也许你确实想在那里渲染一些东西。在这种情况下，你可以提供一个空的嵌套路径：\nconst routes = [ { path: \u0026#39;/user/:id\u0026#39;, component: User, children: [ // 当 /user/:id 匹配成功 // UserHome 将被渲染到 User 的 \u0026lt;router-view\u0026gt; 内部 { path: \u0026#39;\u0026#39;, component: UserHome }, // ...其他子路由 ], }, ] 导航守卫 https://router.vuejs.org/zh/guide/advanced/navigation-guards.html\n正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。这里有很多方式植入路由导航中：全局的，单个路由独享的，或者组件级的。\n全局前置守卫 你可以使用 router.beforeEach 注册一个全局前置守卫：\nconst router = createRouter({ ... }) router.beforeEach((to, from) =\u0026gt; { // ... // 返回 false 以取消导航 return false }) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于等待中。\n每个守卫方法接收两个参数：\nto: 即将要进入的目标 用一种标准化的方式 from: 当前导航正要离开的路由 用一种标准化的方式 可以返回的值如下:\nfalse: 取消当前的导航。如果浏览器的 URL 改变了(可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 一个路由地址: 通过一个路由地址重定向到一个不同的地址，如同调用 router.push()，且可以传入诸如 replace: true 或 name: 'home' 之类的选项。它会中断当前的导航，同时用相同的 from 创建一个新导航。 router.beforeEach(async (to, from) =\u0026gt; { if ( // 检查用户是否已登录 !isAuthenticated \u0026amp;\u0026amp; // ❗️ 避免无限重定向 to.name !== \u0026#39;Login\u0026#39; ) { // 将用户重定向到登录页面 return { name: \u0026#39;Login\u0026#39; } } }) 如果遇到了意料之外的情况，可能会抛出一个 Error。这会取消导航并且调用 router.onError() 注册过的回调。\n如果什么都没有，undefined 或返回 true，则导航是有效的，并调用下一个导航守卫\n以上所有都同 async 函数 和 Promise 工作方式一样：\nrouter.beforeEach(async (to, from) =\u0026gt; { // canUserAccess() 返回 `true` 或 `false` const canAccess = await canUserAccess(to) if (!canAccess) return \u0026#39;/login\u0026#39; }) 在之前的 Vue Router 版本中，还可以使用 第三个参数 next 。这是一个常见的错误来源，我们经过 RFC 讨论将其移除。然而，它仍然是被支持的，这意味着你可以向任何导航守卫传递第三个参数。在这种情况下，确保 next 在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到/login的错误用例：\n// BAD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) // 如果用户未能验证身份，则 `next` 会被调用两次 next() }) 下面是正确的版本:\n// GOOD router.beforeEach((to, from, next) =\u0026gt; { if (to.name !== \u0026#39;Login\u0026#39; \u0026amp;\u0026amp; !isAuthenticated) next({ name: \u0026#39;Login\u0026#39; }) else next() }) 全局后置钩子 你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：\nrouter.afterEach((to, from) =\u0026gt; { sendToAnalytics(to.fullPath) }) 它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。\n它们也反映了 navigation failures 作为第三个参数：\nrouter.afterEach((to, from, failure) =\u0026gt; { if (!failure) sendToAnalytics(to.fullPath) }) 更多关于 navigation failures 的信息在它的指南 中。\n路由独享的守卫 你可以直接在路由配置上定义 beforeEnter 守卫：\nconst routes = [ { path: \u0026#39;/users/:id\u0026#39;, component: UserDetails, beforeEnter: (to, from) =\u0026gt; { // reject the navigation return false }, }, ] beforeEnter 守卫 只在进入路由时触发，不会在 params、query 或 hash 改变时触发。例如，从 /users/2 进入到 /users/3 或者从 /users/2#info 进入到 /users/2#projects。它们只有在 从一个不同的 路由导航时，才会被触发。\n你也可以将一个函数数组传递给 beforeEnter，这在为不同的路由重用守卫时很有用：\nfunction removeQueryParams(to) { if (Object.keys(to.query).length) return { path: to.path, query: {}, hash: to.hash } } function removeHash(to) { if (to.hash) return { path: to.path, query: to.query, hash: \u0026#39;\u0026#39; } } const routes = [ { path: \u0026#39;/users/:id\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams, removeHash], }, { path: \u0026#39;/about\u0026#39;, component: UserDetails, beforeEnter: [removeQueryParams], }, ] 请注意，你也可以通过使用路径 meta 字段和全局导航守卫来实现类似的行为。\n组件内的守卫 最后，你可以在路由组件内直接定义路由导航守卫(传递给路由配置的)\n可用的配置 API 你可以为路由组件添加以下配置：\nbeforeRouteEnter beforeRouteUpdate beforeRouteLeave const UserDetails = { template: `...`, beforeRouteEnter(to, from) { // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this` ！ // 因为当守卫执行时，组件实例还没被创建！ }, beforeRouteUpdate(to, from) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候， // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this` }, beforeRouteLeave(to, from) { // 在导航离开渲染该组件的对应路由时调用 // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this` }, } beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。\n不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数：\nbeforeRouteEnter (to, from, next) { next(vm =\u0026gt; { // 通过 `vm` 访问组件实例 }) } 注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持 传递回调，因为没有必要了：\nbeforeRouteUpdate (to, from) { // just use `this` this.name = to.params.name } 这个 离开守卫 通常用来预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消。\nbeforeRouteLeave (to, from) { const answer = window.confirm(\u0026#39;Do you really want to leave? you have unsaved changes!\u0026#39;) if (!answer) return false } 使用组合 AP 如果你正在使用组合 API 和 setup 函数来编写组件，你可以通过 onBeforeRouteUpdate 和 onBeforeRouteLeave 分别添加 update 和 leave 守卫。 请参考组合 API 部分以获得更多细节。\n完整的导航解析流程 导航被触发。 在失活的组件里调用 beforeRouteLeave 守卫。 调用全局的 beforeEach 守卫。 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。 在路由配置里调用 beforeEnter。 解析异步路由组件。 在被激活的组件里调用 beforeRouteEnter。 调用全局的 beforeResolve 守卫(2.5+)。 导航被确认。 调用全局的 afterEach 钩子。 触发 DOM 更新。 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。 路由案例 目标: 路由跳转之前, 先执行一次前置守卫函数, 判断是否可以正常跳转\n// `router.beforeEach` router.beforeEach((to, form, next) =\u0026gt; { console.log(to, form); next() }) 每个守卫方法接收三个参数：\nto: Route， 即将要进入的目标 路由对象； from: Route，当前导航正要离开的路由； next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。 next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。 next(\u0026#39;/\u0026#39;) 或者 next({ path: \u0026#39;/\u0026#39; }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 登录拦截 使用例子: 在跳转路由前, 判断用户登陆了才能去 \u0026lt;我的音乐\u0026gt; 页面, 未登录弹窗提示回到发现音乐页面\n在路由对象上使用固定方法 beforeEach\n// 目标: 路由守卫 // 场景: 当你要对路由权限判断时 // 语法: router.beforeEach((to, from, next)=\u0026gt;{//路由跳转\u0026#34;之前\u0026#34;先执行这里, 决定是否跳转}) // 参数1: 要跳转到的路由 (路由对象信息) 目标 // 参数2: 从哪里跳转的路由 (路由对象信息) 来源 // 参数3: 函数体 - next()才会让路由正常的跳转切换, next(false)在原地停留, next(\u0026#34;强制修改到另一个路由路径上\u0026#34;) // 注意: 如果不调用 next, 页面留在原地 const isLogin = ref(true)// 登录状态(未登录) router.beforeEach((to, from, next) =\u0026gt; { if (to.path === \u0026#39;/my\u0026#39; \u0026amp;\u0026amp; isLogin.value === false) { alert(\u0026#39;请登录\u0026#39;) next(false) // 阻止路由跳转 } else { next() // 正常放行 } }) 总结: next()放行, next(false)留在原地不跳转路由, next(path路径)强制换成对应path路径跳转\n权限判断 const whileList = [\u0026#39;/\u0026#39;] router.beforeEach((to, from, next) =\u0026gt; { let token = localStorage.getItem(\u0026#39;token\u0026#39;) //白名单 有值 或者登陆过存储了token信息可以跳转 否则就去登录页面 if (whileList.includes(to.path) || token) { next() } else { next({ path: \u0026#39;/\u0026#39; }) } }) 路由原信息 有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的meta属性来实现，并且它可以在路由地址和导航守卫上都被访问到。定义路由的时候你可以这样配置 meta 字段：\nconst routes = [ { path: \u0026#39;/posts\u0026#39;, component: PostsLayout, children: [ { path: \u0026#39;new\u0026#39;, component: PostsNew, // 只有经过身份验证的用户才能创建帖子 meta: { requiresAuth: true }, }, { path: \u0026#39;:id\u0026#39;, component: PostsDetail // 任何人都可以阅读文章 meta: { requiresAuth: false }, } ] } ] 那么如何访问这个 meta 字段呢？\n首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，它可能匹配多个路由记录。\n例如，根据上面的路由配置，/posts/new 这个 URL 将会匹配父路由记录 (path: '/posts') 以及子路由记录 (path: 'new')。\n一个路由匹配到的所有路由记录会暴露为 $route 对象(还有在导航守卫中的路由对象)的$route.matched 数组。我们需要遍历这个数组来检查路由记录中的 meta 字段，但是 Vue Router 还为你提供了一个 $route.meta 方法，它是一个非递归合并所有 meta 字段（从父字段到子字段）的方法。这意味着你可以简单地写\nrouter.beforeEach((to, from) =\u0026gt; { // 而不是去检查每条路由记录 // to.matched.some(record =\u0026gt; record.meta.requiresAuth) if (to.meta.requiresAuth \u0026amp;\u0026amp; !auth.isLoggedIn()) { // 此路由需要授权，请检查是否已登录 // 如果没有，则重定向到登录页面 return { path: \u0026#39;/login\u0026#39;, // 保存我们所在的位置，以便以后再来 query: { redirect: to.fullPath }, } } }) 过渡动效 想要在你的路径组件上使用转场，并对导航进行动画处理，你需要使用 v-slot API：\n\u0026lt;router-view #default=\u0026#34;{route,Component}\u0026#34;\u0026gt; \u0026lt;transition :enter-active-class=\u0026#34;`animate__animated ${route.meta.transition}`\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;Component\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/router-view\u0026gt; 上面的用法会对所有的路由使用相同的过渡。如果你想让每个路由的组件有不同的过渡，你可以将元信息和动态的 name 结合在一起，放在\u0026lt;transition\u0026gt; 上：\nconst routes = [ { path: \u0026#39;/custom-transition\u0026#39;, component: PanelLeft, meta: { transition: \u0026#39;slide-left\u0026#39; }, }, { path: \u0026#39;/other-transition\u0026#39;, component: PanelRight, meta: { transition: \u0026#39;slide-right\u0026#39; }, }, ] \u0026lt;router-view v-slot=\u0026#34;{ Component, route }\u0026#34;\u0026gt; \u0026lt;!-- 使用任何自定义过渡和回退到 `fade` --\u0026gt; \u0026lt;transition :name=\u0026#34;route.meta.transition || \u0026#39;fade\u0026#39;\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;Component\u0026#34; /\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/router-view\u0026gt; 也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。使用和刚才非常相似的片段：\n\u0026lt;!-- 使用动态过渡名称 --\u0026gt; \u0026lt;router-view v-slot=\u0026#34;{ Component, route }\u0026#34;\u0026gt; \u0026lt;transition :name=\u0026#34;route.meta.transition\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;Component\u0026#34; /\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/router-view\u0026gt; 我们可以添加一个 after navigation hook，根据路径的深度动态添加信息到 meta 字段。\nrouter.afterEach((to, from) =\u0026gt; { const toDepth = to.path.split(\u0026#39;/\u0026#39;).length const fromDepth = from.path.split(\u0026#39;/\u0026#39;).length to.meta.transition = toDepth \u0026lt; fromDepth ? \u0026#39;slide-right\u0026#39; : \u0026#39;slide-left\u0026#39; }) Vue 可能会自动复用看起来相似的组件，从而忽略了任何过渡。幸运的是，可以添加一个 key 属性来强制过渡。这也允许你在相同路由上使用不同的参数触发过渡：\n\u0026lt;router-view v-slot=\u0026#34;{ Component, route }\u0026#34;\u0026gt; \u0026lt;transition name=\u0026#34;fade\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;Component\u0026#34; :key=\u0026#34;route.path\u0026#34; /\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/router-view\u0026gt; 滚动行为 使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。\n注意: 这个功能只在支持 history.pushState 的浏览器中可用。\n当创建一个 Router 实例，你可以提供一个 scrollBehavior 方法：\nconst router = createRouter({ history: createWebHashHistory(), routes: [...], scrollBehavior (to, from, savedPosition) { // return 期望滚动到哪个的位置 } }) scrollBehavior 函数接收 to和from 路由对象，如 Navigation Guards。第三个参数 savedPosition，只有当这是一个 popstate 导航时才可用（由浏览器的后退/前进按钮触发）。\n该函数可以返回一个 ScrollToOptions 位置对象:\nconst router = createRouter({ scrollBehavior(to, from, savedPosition) { // 始终滚动到顶部 return { top: 0 } }, }) 你也可以通过 el 传递一个 CSS 选择器或一个 DOM 元素。在这种情况下，top 和 left 将被视为该元素的相对偏移量。\nconst router = createRouter({ scrollBehavior(to, from, savedPosition) { // 始终在元素 #main 上方滚动 10px return { // 也可以这么写 // el: document.getElementById(\u0026#39;main\u0026#39;), el: \u0026#39;#main\u0026#39;, // 在元素上 10 像素 top: 10, } }, }) 如果返回一个 falsy 的值，或者是一个空对象，那么不会发生滚动。\n返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样：\nconst router = createRouter({ scrollBehavior(to, from, savedPosition) { if (savedPosition) { return savedPosition } else { return { top: 0 } } }, }) 如果你要模拟 “滚动到锚点” 的行为：\nconst router = createRouter({ scrollBehavior(to, from, savedPosition) { if (to.hash) { return { el: to.hash, } } }, }) 如果你的浏览器支持滚动行为，你可以让它变得更流畅：\nconst router = createRouter({ scrollBehavior(to, from, savedPosition) { if (to.hash) { return { el: to.hash, behavior: \u0026#39;smooth\u0026#39;, } } } }) 有时候，我们需要在页面中滚动之前稍作等待。例如，当处理过渡时，我们希望等待过渡结束后再滚动。要做到这一点，你可以返回一个 Promise，它可以返回所需的位置描述符。下面是一个例子，我们在滚动前等待 500ms：\nconst router = createRouter({ scrollBehavior(to, from, savedPosition) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ left: 0, top: 0 }) }, 500) }) }, }) 我们可以将其与页面级过渡组件的事件挂钩，以使滚动行为与你的页面过渡很好地结合起来，但由于使用场景可能存在的差异和复杂性，我们只是提供了这个基础来实现特定的用户场景。\n动态路由 对路由的添加通常是通过 routes 选项来完成的，但是在某些情况下，你可能想在应用程序已经运行的时候添加或删除路由。具有可扩展接口(如 Vue CLI UI )这样的应用程序可以使用它来扩展应用程序。\n添加路由 动态路由主要通过两个函数实现。router.addRoute() 和 router.removeRoute()。它们只注册一个新的路由，也就是说，如果新增加的路由与当前位置相匹配，就需要你用 router.push() 或 router.replace() 来手动导航，才能显示该新路由。我们来看一个例子：\n想象一下，只有一个路由的以下路由：\nconst router = createRouter({ history: createWebHistory(), routes: [{ path: \u0026#39;/:articleName\u0026#39;, component: Article }], }) 进入任何页面，/about，/store，或者 /3-tricks-to-improve-your-routing-code 最终都会呈现 Article 组件。如果我们在 /about 上添加一个新的路由：\nrouter.addRoute({ path: \u0026#39;/about\u0026#39;, component: About }) 页面仍然会显示 Article 组件，我们需要手动调用 router.replace() 来改变当前的位置，并覆盖我们原来的位置（而不是添加一个新的路由，最后在我们的历史中两次出现在同一个位置）：\nrouter.addRoute({ path: \u0026#39;/about\u0026#39;, component: About }) // 我们也可以使用 this.$route 或 route = useRoute() （在 setup 中） router.replace(router.currentRoute.value.fullPath) 记住，如果你需要等待新的路由显示，可以使用 await router.replace()。\n删除路由 有几个不同的方法来删除现有的路由：\n通过添加一个名称冲突的路由。如果添加与现有途径名称相同的途径，会先删除路由，再添加路由：\nrouter.addRoute({ path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: About }) // 这将会删除之前已经添加的路由，因为他们具有相同的名字且名字必须是唯一的 router.addRoute({ path: \u0026#39;/other\u0026#39;, name: \u0026#39;about\u0026#39;, component: Other }) 通过调用 router.addRoute() 返回的回调：\nconst removeRoute = router.addRoute(routeRecord) removeRoute() // 删除路由如果存在的话 当路由没有名称时，这很有用。\n通过使用 router.removeRoute() 按名称删除路由：\nrouter.addRoute({ path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: About }) // 删除路由 router.removeRoute(\u0026#39;about\u0026#39;) 需要注意的是，如果你想使用这个功能，但又想避免名字的冲突，可以在路由中使用 Symbol 作为名字。\n当路由被删除时，所有的别名和子路由也会被同时删除\n查看现有路由 Vue Router 提供了两个功能来查看现有的路由：\nrouter.hasRoute()：检查路由是否存在。 router.getRoutes()：获取一个包含所有路由记录的数组。 动态路由案例 后端代码 -\u0026gt; Python Flask from flask import Flask, request from flask_cors import CORS app = Flask(__name__) CORS().init_app(app) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def login(): username = request.json.get(\u0026#39;username\u0026#39;) password = request.json.get(\u0026#39;password\u0026#39;) if username == \u0026#39;admin\u0026#39; and password == \u0026#39;123456\u0026#39;: return { \u0026#39;routes\u0026#39;: [ { \u0026#39;path\u0026#39;: \u0026#34;/articles\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;articles\u0026#34;, \u0026#39;parent\u0026#39;: \u0026#34;subviews\u0026#34;, \u0026#39;component\u0026#39;: \u0026#39;Articles.vue\u0026#39; }, { \u0026#39;path\u0026#39;: \u0026#34;/hot\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;hot\u0026#34;, \u0026#39;parent\u0026#39;: \u0026#34;subviews\u0026#34;, \u0026#39;component\u0026#39;: \u0026#39;Hot.vue\u0026#39; }, { \u0026#39;path\u0026#39;: \u0026#34;/author\u0026#34;, \u0026#39;name\u0026#39;: \u0026#34;author\u0026#34;, \u0026#39;parent\u0026#39;: \u0026#34;subviews\u0026#34;, \u0026#39;component\u0026#39;: \u0026#39;Author.vue\u0026#39; } ] } else: return { \u0026#39;code\u0026#39;: 400, \u0026#39;message\u0026#39;: \u0026#34;账号密码错误\u0026#34; } @app.route(\u0026#39;/menus\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def menus(): return { \u0026#39;routes\u0026#39;: [ { \u0026#39;path\u0026#39;: \u0026#39;/login\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;login\u0026#39;, \u0026#39;component\u0026#39;: \u0026#39;Login.vue\u0026#39; }, { \u0026#39;path\u0026#39;: \u0026#39;/main\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;main\u0026#39;, \u0026#39;component\u0026#39;: \u0026#39;Main.vue\u0026#39; } ] } @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def index(): return { \u0026#39;routes\u0026#39;: [ { \u0026#39;path\u0026#39;: \u0026#39;/login\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;login\u0026#39;, \u0026#39;component\u0026#39;: \u0026#39;./views/Login.vue\u0026#39; } ] } if __name__ == \u0026#39;__main__\u0026#39;: app.run(debug=True, host=\u0026#39;127.0.0.1\u0026#39;, port=5000) 前端代码 App.vue \u0026lt;script setup\u0026gt; import {onMounted} from \u0026#34;vue\u0026#34;; import axios from \u0026#34;axios\u0026#34;; import {useRouter} from \u0026#34;vue-router\u0026#34;; const router = useRouter() // 启动项目之后才加载登录路由 onMounted(async () =\u0026gt; { const response = await axios.get(\u0026#39;http://127.0.0.1:5000/menus\u0026#39;) const data = response.data data.routes.forEach((v) =\u0026gt; { router.addRoute({ path: v.path, name: v.name, component: () =\u0026gt; import(/* @vite-ignore */ `./components/${v.component}`) }) }) await router.push(\u0026#39;/login\u0026#39;) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } html, body, #app { width: 100%; height: 100%; } \u0026lt;/style\u0026gt; router.js import { createRouter, createWebHistory } from \u0026#39;vue-router\u0026#39; // @ 路径 console.log(import.meta.url) const routes = [ { path: \u0026#39;/login\u0026#39;, name: \u0026#39;login\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/components/login.vue\u0026#39;) }, { path: \u0026#39;/main\u0026#39;, name: \u0026#39;main\u0026#39;, component: () =\u0026gt; import(\u0026#39;@/components/main.vue\u0026#39;) } ] const router = createRouter({ history: createWebHistory(), routes }) export default router login.vue \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;login\u0026#34;\u0026gt; \u0026lt;el-form :model=\u0026#34;formInline\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;用户名：\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;formInline.username\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34;/\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;密\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;码：\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;formInline.password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34;\u0026gt; \u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;提交登录\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import axios from \u0026#39;axios\u0026#39;; import {reactive} from \u0026#39;vue\u0026#39; import {useRouter} from \u0026#34;vue-router\u0026#34;; const router = useRouter() const formInline = reactive({ username: \u0026#39;\u0026#39;, password: \u0026#39;\u0026#39;, }) const onSubmit = async () =\u0026gt; { const response = await axios.post(\u0026#39;http://127.0.0.1:5000/login\u0026#39;, formInline) const data = response.data console.log(data) // 登录成功之后, 解析后端返回的路由数据 if (data?.routes) { data.routes.forEach((v) =\u0026gt; { console.log(v) const path = v?.parent ? `./${v.parent}/${v.component}` : `./${v.component}` router.addRoute(\u0026#39;main\u0026#39;, { path: \u0026#39;/main\u0026#39; + v.path, name: v.name, component: () =\u0026gt; import(/* @vite-ignore */ path) }) }) console.log(router.getRoutes()) await router.push(\u0026#39;/main\u0026#39;) } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .login { width: 30%; margin: 100px auto; } \u0026lt;/style\u0026gt; main.js \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;Main\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/main/articles\u0026#34;\u0026gt;阅读文章\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/main/hot\u0026#34;\u0026gt;排行热榜\u0026lt;/router-link\u0026gt; \u0026lt;router-link to=\u0026#34;/main/author\u0026#34;\u0026gt;作者排行\u0026lt;/router-link\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;subview\u0026#34;\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; .nav a { margin: 20px; } \u0026lt;/style\u0026gt; ","permalink":"https://waite.wang/posts/vue/system-learn-vue-4-animation-router/","summary":"\u003ch2 id=\"vue-过渡与动画初体验\"\u003eVue 过渡与动画初体验\u003c/h2\u003e\n\u003ch3 id=\"认识动画\"\u003e认识动画\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验：\n\u003cul\u003e\n\u003cli\u003eReact框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group；\u003c/li\u003e\n\u003cli\u003eVue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e我们来看一个案例：\n\u003cul\u003e\n\u003cli\u003eHello World的显示和隐藏；\u003c/li\u003e\n\u003cli\u003e通过下面的代码实现，是不会有任何动画效果的；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-vue\" data-lang=\"vue\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003etemplate\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003ediv\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003ebutton\u003c/span\u003e \u003cspan class=\"nt\"\u003e@click\u003c/span\u003e\u003cspan class=\"s\"\u003e=\u0026#34;toggle\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"na\"\u003e显示\u003c/span\u003e\u003cspan class=\"err\"\u003e/\u003c/span\u003e\u003cspan class=\"na\"\u003e隐藏\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003ebutton\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003eh2\u003c/span\u003e \u003cspan class=\"nt\"\u003ev-if\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;show\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"na\"\u003eApp组件\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003eh2\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003ediv\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003etemplate\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kr\"\u003eexport\u003c/span\u003e \u003cspan class=\"k\"\u003edefault\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"nx\"\u003eshow\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003emethods\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"nx\"\u003etoggle\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eshow\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eshow\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e没有动画的情况下，整个内容的显示和隐藏会非常的生硬：\n\u003cul\u003e\n\u003cli\u003e如果我们希望给单元素或者组件实现过渡动画，可以使用 \u003ccode\u003etransition\u003c/code\u003e内置组件来完成动画；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"vue的-transition-动画\"\u003eVue的 transition 动画\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://cn.vuejs.org/guide/built-ins/transition.html#transition\"\u003ehttps://cn.vuejs.org/guide/built-ins/transition.html#transition\u003c/a\u003e\u003c/p\u003e","title":"系统学习 Vue -- 4. 动画和路由"},{"content":"微信小程序入门 微信小程序介绍 微信小程序介绍 ​ 微信小程序，简称小程序，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。\n​ 说明：\n小程序是需要下载的，小程序的占用大小很小，感觉不到下载 目前大小限制2M （最终开发的小程序打包压缩后的大小），如果超过2M,就得做分包上传.之后再合并 进入小程序后继续网络请求数据 小程序特点 微信小程序的特点：\n免安装 接近原生（IOS，Android ）的app操作基于微信开发。使用wx提供的api开发 必须在微信里面使用 小程序的优缺点 ==方便快捷，即用即走== ==速度快、不占内存== 安全稳定、保密性强 功能丰富，场景丰富 ==开发成本低、维护简便== ==开发周期比较短== 体验好 小程序开发需求 不注册可以开发小程序(不能发布) 注册小程序 企业注册(公司内部人员注册好了，给一个APPID) 个人注册 微信小程序的注册 微信公众平台：https://mp.weixin.qq.com/\n开发工具 开发工具下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\n开发者工具的使用 以下就是微信小程序开发工具的界面，主要有：微信小程序模拟器、项目目录、代码编写区域、控制台。\n项目目录结构介绍 pages目录 ​ pages目录下放的就是小程序中的各个页面。\n​ 在pages中创建页面的时候，会出现4个文件：\nxxx.js：页面相关的js代码可以写在这里 xxx.wxml：这个就是页面文件，相当于我们之前的HTML，所以页面结构内容写在这里 xxx.wxss：页面的样式内容，相当于之前的css，所以页面相关的样式可以写在这里 xxx.json：页面有关的配置，比如页面导航栏的背景色、内容等等 比如： app.js文件 ​ app.js文件是整个项目的一个==总体配置==。里面包含了项目运行==生命周期的回调函数==。\napp.json文件 ​ 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。\n小程序根目录下的 app.json 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：\nhttps://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html\napp.wxss文件 app.wxss 文件是微信小程序项目的==全局样式表==，它可以应用到所有的wxml文件中。 微信小程序中使用 rpx 作为长度单位。1rpx = 1/750 屏幕宽度。也就是屏幕宽度等于 750rpx。 px 也可以使用，表示的是设备独立像素。 建议使用长度单位 rpx。它自动做了适配。 project.config.json文件 ​ project.config.json文件是小程序项目的配置文件（如开发工具的外观配置），一般不需要修改，我们目前就改一个地方：\n\u0026quot;checkSiteMap\u0026quot;:false 作用是==控制台不要有一些没用的警告==。\nSitemap.json https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html\n搜索功能文件，指定哪些页面可以被搜索，可被配置。是在搜索小程序的时候，指定哪些页面允许被搜索到。\n小程序配置项 全局配置 https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#entryPagePath\n小程序根目录下的 app.json 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：\n属性 类型 必填 描述 最低版本 entryPagePath string 否 小程序默认启动首页 pages string[] 是 页面路径列表 window Object 否 全局的默认窗口表现 tabBar Object 否 底部 tab 栏的表现 networkTimeout Object 否 网络超时时间 debug boolean 否 是否开启 debug 模式，默认关闭 functionalPages boolean 否 是否启用插件功能页，默认关闭 2.1.0 subpackages Object[] 否 分包结构配置 1.7.3 workers string 否 Worker 代码放置的目录 1.9.90 requiredBackgroundModes string[] 否 需要在后台使用的能力，如「音乐播放」 requiredPrivateInfos string[] 否 调用的地理位置相关隐私接口 plugins Object 否 使用到的插件 1.9.6 preloadRule Object 否 分包预下载规则 2.3.0 resizable boolean 否 PC 小程序是否支持用户任意改变窗口大小（包括最大化窗口）；iPad 小程序是否支持屏幕旋转。默认关闭 2.3.0 usingComponents Object 否 全局自定义组件配置 开发者工具 1.02.1810190 permission Object 否 小程序接口权限相关设置 微信客户端 7.0.0 sitemapLocation string 是 指明 sitemap.json 的位置 style string 否 指定使用升级后的weui样式 2.8.0 useExtendedLib Object 否 指定需要引用的扩展库 2.2.1 entranceDeclare Object 否 微信消息用小程序打开 微信客户端 7.0.9 darkmode boolean 否 小程序支持 DarkMode 2.11.0 themeLocation string 否 指明 theme.json 的位置，darkmode为true为必填 开发者工具 1.03.2004271 lazyCodeLoading string 否 配置自定义组件代码按需注入 2.11.1 singlePage Object 否 单页模式相关配置 2.12.0 supportedMaterials Object 否 聊天素材小程序打开相关配置 2.14.3 serviceProviderTicket string 否 定制化型服务商票据 embeddedAppIdList string[] 否 半屏小程序 appId 2.20.1 halfPage Object 否 视频号直播半屏场景设置 2.18.0 debugOptions Object 否 调试相关配置 2.22.1 enablePassiveEvent Object或boolean 否 touch 事件监听是否为 passive 2.24.1 resolveAlias Object 否 自定义模块映射规则 renderer string 否 全局默认的渲染后端 2.30.4 rendererOptions Object 否 渲染后端选项 2.31.1 componentFramework string 否 组件框架，详见相关文档 2.30.4 miniApp Object 否 多端模式场景接入身份管理服务时开启小程序授权页相关配置，详见相关文档 static Object 否 正常情况下默认所有资源文件都被打包发布到所有平台，可以通过 static 字段配置特定每个目录/文件只能发布到特定的平台(多端场景) 相关文档 convertRpxToVw boolean 否 配置是否将 rpx 单位转换为 vw 单位，开启后能修复某些 rpx 下的精度问题 3.3.0 以下简单列举了一部分, 其他未列举可以在官方文档中查看\nentryPagePath 指定小程序的默认启动路径（首页），常见情景是从微信聊天列表页下拉启动、小程序列表启动等。如果不填，将默认为 pages 列表的第一项。不支持带页面路径参数。\npages 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理。\n未指定 entryPagePath 时，数组的第一项代表小程序的初始页面（首页）。\n小程序中新增/减少页面，都需要对 pages 数组进行修改。\n则需要在 app.json 中写\n{ \u0026#34;pages\u0026#34;: [\u0026#34;pages/index/index\u0026#34;, \u0026#34;pages/logs/logs\u0026#34;] } window 用于设置小程序的状态栏、导航条、标题、窗口背景色。\n属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle string white 导航栏标题、状态栏颜色，仅支持 black / white navigationBarTitleText string 导航栏标题文字内容 navigationStyle string default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮。参见注 2。 iOS/Android 微信客户端 6.6.0，Windows 微信客户端不支持 homeButton boolean default 在非首页、非页面栈最底层页面或非tabbar内页面中的导航栏展示home键 微信客户端 8.0.24 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle string dark 下拉 loading 的样式，仅支持 dark / light backgroundColorTop string #ffffff 顶部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 backgroundColorBottom string #ffffff 底部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 enablePullDownRefresh boolean false 是否开启全局的下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance number 50 页面上拉触底事件触发时距页面底部距离，单位为 px。 详见 Page.onReachBottom pageOrientation string portrait 屏幕旋转设置，支持 auto / portrait / landscape 详见 响应显示区域变化 2.4.0 (auto) / 2.5.0 (landscape) restartStrategy string homePage 重新启动策略配置 2.8.0 initialRenderingCache string 页面初始渲染缓存配置，支持 static / dynamic 2.11.1 visualEffectInBackground string none 切入系统后台时，隐藏页面内容，保护用户隐私。支持 hidden / none 2.15.0 handleWebviewPreload string static 控制预加载下个页面的时机。支持 static / manual / auto 2.15.0 如：\n{ \u0026#34;window\u0026#34;: { \u0026#34;navigationBarBackgroundColor\u0026#34;: \u0026#34;#ffffff\u0026#34;, \u0026#34;navigationBarTextStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;navigationBarTitleText\u0026#34;: \u0026#34;微信接口功能演示\u0026#34;, \u0026#34;backgroundColor\u0026#34;: \u0026#34;#eeeeee\u0026#34;, \u0026#34;backgroundTextStyle\u0026#34;: \u0026#34;light\u0026#34; } } tabBar 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。\n属性 类型 必填 默认值 描述 最低版本 color HexColor 是 tab 上的文字默认颜色，仅支持十六进制颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色，仅支持十六进制颜色 backgroundColor HexColor 是 tab 的背景色，仅支持十六进制颜色 borderStyle string 否 black tabbar 上边框的颜色， 仅支持 black / white list Array 是 tab 的列表，详见 list 属性说明，最少 2 个、最多 5 个 tab position string 否 bottom tabBar 的位置，仅支持 bottom / top custom boolean 否 false 自定义 tabBar，见详情 2.5.0 其中 list 接受一个数组，只能配置最少 2 个、最多 5 个 tab。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：\n属性 类型 必填 说明 pagePath string 是 页面路径，必须在 pages 中先定义 text string 是 tab 上按钮文字 iconPath string 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 position 为 top 时，不显示 icon。 selectedIconPath string 否 选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。 当 position 为 top 时，不显示 icon。 以下是一个简单示例\n\u0026#34;tabBar\u0026#34;: { \u0026#34;color\u0026#34;: \u0026#34;#00A95E\u0026#34;, \u0026#34;selectedColor\u0026#34;: \u0026#34;#FA8072\u0026#34;, \u0026#34;backgroundColor\u0026#34;: \u0026#34;#f5f5f5\u0026#34;, \u0026#34;borderStyle\u0026#34;: \u0026#34;black\u0026#34;, \u0026#34;list\u0026#34;: [ { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/index/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Index\u0026#34;, \u0026#34;iconPath\u0026#34;: \u0026#34;icon/_home.png\u0026#34;, \u0026#34;selectedIconPath\u0026#34;: \u0026#34;icon/home.png\u0026#34; }, { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/logs/logs\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Logs\u0026#34;, \u0026#34;iconPath\u0026#34;: \u0026#34;icon/_search.png\u0026#34;, \u0026#34;selectedIconPath\u0026#34;: \u0026#34;icon/search.png\u0026#34; }, { \u0026#34;pagePath\u0026#34;: \u0026#34;pages/demo/demo\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;Demo\u0026#34;, \u0026#34;iconPath\u0026#34;: \u0026#34;icon/_videocamera.png\u0026#34;, \u0026#34;selectedIconPath\u0026#34;: \u0026#34;icon/videocamera.png\u0026#34; } ] } networkTimeout 各类网络请求的超时时间，单位均为毫秒。\n属性 类型 必填 默认值 说明 request number 否 60000 wx.request 的超时时间，单位：毫秒。 connectSocket number 否 60000 wx.connectSocket 的超时时间，单位：毫秒。 uploadFile number 否 60000 wx.uploadFile 的超时时间，单位：毫秒。 downloadFile number 否 60000 wx.downloadFile 的超时时间，单位：毫秒 debug 可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有 Page 的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。\n页面配置 app.json 中的部分配置，也支持对单个页面进行配置，可以在页面对应的 .json 文件来对本页面的表现进行配置。\n页面中配置项在当前页面会覆盖 app.json 中相同的配置项（样式相关的配置项属于 app.json 中的 window 属性，但这里不需要额外指定 window 字段），具体的取值和含义可参考全局配置文档中说明。\n文件内容为一个 JSON 对象，有以下属性：\n属性 类型 默认值 描述 最低版本 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle string white 导航栏标题、状态栏颜色，仅支持 black / white navigationBarTitleText string 导航栏标题文字内容 navigationStyle string default 导航栏样式，仅支持以下值： default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮。 iOS/Android 微信客户端 7.0.0，Windows 微信客户端不支持 homeButton boolean false 在非首页、非页面栈最底层页面或非tabbar内页面中的导航栏展示home键 微信客户端 8.0.24 backgroundColor HexColor #ffffff 窗口的背景色 backgroundColorContent HexColor #RRGGBBAA 页面容器背景色，点击查看设置背景色详情 backgroundTextStyle string dark 下拉 loading 的样式，仅支持 dark / light backgroundColorTop string #ffffff 顶部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 backgroundColorBottom string #ffffff 底部窗口的背景色，仅 iOS 支持 微信客户端 6.5.16 enablePullDownRefresh boolean false 是否开启当前页面下拉刷新。 详见 Page.onPullDownRefresh onReachBottomDistance number 50 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 Page.onReachBottom pageOrientation string portrait 屏幕旋转设置，支持 auto / portrait / landscape 详见 响应显示区域变化 2.4.0 (auto) / 2.5.0 (landscape) disableScroll boolean false 设置为 true 则页面整体不能上下滚动。 只在页面配置中有效，无法在 app.json 中设置 usingComponents Object 否 页面自定义组件配置 1.6.3 initialRenderingCache string 页面初始渲染缓存配置，支持 static / dynamic 2.11.1 style string default 启用新版的组件样式 2.10.2 singlePage Object 否 单页模式相关配置 2.12.0 restartStrategy string homePage 重新启动策略配置 2.8.0 handleWebviewPreload string static 控制预加载下个页面的时机。支持 static / manual / auto 2.15.0 visualEffectInBackground string 否 切入系统后台时，隐藏页面内容，保护用户隐私。支持 hidden / none，若对页面单独设置则会覆盖全局的配置，详见 全局配置 2.15.0 enablePassiveEvent Object或boolean 否 事件监听是否为 passive，若对页面单独设置则会覆盖全局的配置，详见 全局配置 2.24.1 renderer string 否 渲染后端 2.30.4 rendererOptions Object 否 渲染后端选项，详情相关文档 3.1.0 componentFramework string 否 组件框架，详情相关文档 2.30.4 注：并不是所有 app.json 中的配置都可以在页面覆盖或单独指定，仅限于本文档包含的选项。 注：iOS/Android 客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。 WXSS WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。\nWXSS 用来决定 WXML 的组件应该怎么显示。\n为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。\n与 CSS 相比，WXSS 扩展的特性有：\n尺寸单位 样式导入 尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。\n注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。\n样式导入 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。\n示例代码：\n/** common.wxss **/ .small-p { padding:5px; } /** app.wxss **/ @import \u0026#34;common.wxss\u0026#34;; .middle-p { padding:15px; } 内联样式 框架组件上支持使用 style、class 属性来控制组件的样式。\nstyle：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。 \u0026lt;view style=\u0026#34;color:{{color}};\u0026#34; /\u0026gt; class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。 \u0026lt;view class=\u0026#34;normal_view\u0026#34; /\u0026gt; 选择器 目前支持的选择器有：\n选择器 样例 样例描述 .class .intro 选择所有拥有 class=\u0026ldquo;intro\u0026rdquo; 的组件 #id #firstname 选择拥有 id=\u0026ldquo;firstname\u0026rdquo; 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 全局样式与局部样式 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。\n组件 https://developers.weixin.qq.com/miniprogram/dev/component/\nhtml 中有 div、span、ul、li 、img, 而小程序上面所有的标签都没有，只有组件, 微信小程序中的组件就相当于之前HTML中的标签。但是小程序中的组件除了包裹功能，还具有样式和 js 功能。\n以下会介绍一些常用的标签, 剩下的可以在官方文档中查看\n视图/基础组件 View ​ 视图容器，view组件就相当于之前HTML中的div标签。\n属性 类型 默认值 必填 说明 最低版本 hover-class string none 否 指定按下去的样式类。当 hover-class=\u0026quot;none\u0026quot; 时，没有点击态效果 1.0.0 hover-stop-propagation boolean false 否 指定是否阻止本节点的祖先节点出现点击态 1.5.0 hover-start-time number 50 否 按住后多久出现点击态，单位毫秒 1.0.0 hover-stay-time number 400 否 手指松开后点击态保留时间，单位毫秒 1.0.0 \u0026lt;view class=\u0026#34;wrapper\u0026#34; hover-class=\u0026#34;wrapper-hover\u0026#34; hover-stay-time=\u0026#34;1000\u0026#34;\u0026gt;我的第一个微信程序\u0026lt;/view\u0026gt; .wrapper{ width: 100%; height: 100rpx; text-align: center; line-height: 100rpx; background-color: skyblue; } .wrapper-hover { background-color: pink; } 以下是一个 Flex 布局的例子\n\u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-body\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-section\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-section-title\u0026#34;\u0026gt; \u0026lt;text\u0026gt;flex-direction: row\u0026lt;/text\u0026gt; \u0026lt;text\u0026gt;横向布局\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;page-section-spacing\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-wrp\u0026#34; style=\u0026#34;flex-direction:row;\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-item demo-text-1\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item demo-text-2\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item demo-text-3\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;page-section\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-section-title\u0026#34;\u0026gt; \u0026lt;text\u0026gt;flex-direction: column\u0026lt;/text\u0026gt; \u0026lt;text\u0026gt;纵向布局\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-wrp\u0026#34; style=\u0026#34;flex-direction:column;\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;flex-item flex-item-V demo-text-1\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item flex-item-V demo-text-2\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;flex-item flex-item-V demo-text-3\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; .container { margin-top: 80px; } .flex-wrp { display: flex; } .flex-item { width: 200rpx; height: 300rpx; font-size: 26rpx; } .flex-item-V { margin: 0 auto; width: 300rpx; height: 200rpx; } .page-section-title text { line-height: 36px; } .demo-text-1 { position: relative; align-items: center; justify-content: center; background-color: #1AAD19; color: #FFFFFF; font-size: 36rpx; } .demo-text-1:before { content: \u0026#39;A\u0026#39;; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .demo-text-2 { position: relative; align-items: center; justify-content: center; background-color: #2782D7; color: #FFFFFF; font-size: 36rpx; } .demo-text-2:before { content: \u0026#39;B\u0026#39;; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .demo-text-3 { position: relative; align-items: center; justify-content: center; background-color: #F1F1F1; color: #353535; font-size: 36rpx; } .demo-text-3:before { content: \u0026#39;C\u0026#39;; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } text ​ 文本组件，相当于HTML中的span标签。\n\u0026lt;text\u0026gt;啦啦啦啦\u0026lt;/text\u0026gt; swiper https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html#%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA\n滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为。也就是说swiper内部只能放swiper-item组件，而swiper-item组件中就可以随便放其它组件及内容了。\n\u0026lt;swiper class=\u0026#34;banner\u0026#34;\u0026gt; \u0026lt;swiper-item\u0026gt;item1\u0026lt;/swiper-item\u0026gt; \u0026lt;swiper-item\u0026gt;item2\u0026lt;/swiper-item\u0026gt; \u0026lt;swiper-item\u0026gt;item3\u0026lt;/swiper-item\u0026gt; \u0026lt;/swiper\u0026gt; .banner{ height: 80rpx; text-align: center; line-height: 80rpx; } 可以看到swiper组件有轮播图的效果。而且它有默认的高度(150px)。\n属性 类型 默认值 必填 说明 最低版本 indicator-dots boolean false 否 是否显示面板指示点 1.0.0 indicator-color color rgba(0, 0, 0, .3) 否 指示点颜色 1.1.0 indicator-active-color color #000000 否 当前选中的指示点颜色 1.1.0 autoplay boolean false 否 是否自动切换 1.0.0 current number 0 否 当前所在滑块的 index 1.0.0 interval number 5000 否 自动切换时间间隔 1.0.0 duration number 500 否 滑动动画时长 1.0.0 circular boolean false 否 是否采用衔接滑动 1.0.0 vertical boolean false 否 滑动方向是否为纵向 1.0.0 display-multiple-items number 1 否 同时显示的滑块数量 1.9.0 previous-margin string \u0026ldquo;0px\u0026rdquo; 否 前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值 1.9.0 以下是一个简单的轮播图效果\nconst food = [ \u0026#39;https://img1.baidu.com/it/u=3033226715,2238019049\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=800\u0026amp;h=500\u0026#39;, \u0026#39;https://img1.baidu.com/it/u=1948650034,2409824853\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=120\u0026amp;f=JPEG?w=1200\u0026amp;h=675\u0026#39;, \u0026#39;https://img2.baidu.com/it/u=3016274568,4110305242\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=500\u0026amp;h=313\u0026#39;, \u0026#39;https://img2.baidu.com/it/u=2364493189,83457107\u0026amp;fm=253\u0026amp;fmt=auto\u0026amp;app=138\u0026amp;f=JPEG?w=800\u0026amp;h=500\u0026#39; ] Page({ data: { food }, }) \u0026lt;view style=\u0026#34;height: 400rpx;\u0026#34;\u0026gt; \u0026lt;swiper class=\u0026#34;banner\u0026#34; indicator-dots\u0026gt; \u0026lt;swiper-item wx:for=\u0026#34;{{food}}\u0026#34; wx:key=\u0026#34;*this\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;img\u0026#34; src=\u0026#34;{{item}}\u0026#34; mode=\u0026#34;aspectFill\u0026#34; /\u0026gt; \u0026lt;/swiper-item\u0026gt; \u0026lt;/swiper\u0026gt; \u0026lt;/view\u0026gt; .banner { height: 100%; width: 100%; text-align: center; line-height: 80rpx; } 当然, 在 Skyline 渲染模式下, 他也会有不同的表现, 具体可以看\nhttps://developers.weixin.qq.com/miniprogram/dev/component/swiper.html#%E6%8C%87%E7%A4%BA%E5%99%A8%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA\nscroll-view https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html\n可滚动视图区域。使用竖向滚动时，需要给scroll-view一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。\n横向滚动需打开 enable-flex 以兼容 WebView，如 滚动条的长度是预估的，若直接子节点的高度差别较大，则滚动条长度可能会不准确 使用 worklet 函数需要开启开发者工具 \u0026ldquo;将 JS 编译成 ES5\u0026rdquo; 或 \u0026ldquo;编译 worklet 函数\u0026rdquo; 选项。 以下我会给出 纵向滚动 以及 横向滚动 两个效果, 具体属性可以在官方文档中查看\n\u0026lt;view class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-body\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-section\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-section-title\u0026#34;\u0026gt; \u0026lt;text\u0026gt;Vertical Scroll\u0026lt;/text\u0026gt; \u0026lt;text\u0026gt;纵向滚动\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;page-section-spacing\u0026#34;\u0026gt; \u0026lt;scroll-view type=\u0026#34;list\u0026#34; scroll-y=\u0026#34;true\u0026#34; style=\u0026#34;height: 300rpx;\u0026#34;\u0026gt; \u0026lt;view id=\u0026#34;demo1\u0026#34; class=\u0026#34;scroll-view-item demo-text-1\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view id=\u0026#34;demo2\u0026#34; class=\u0026#34;scroll-view-item demo-text-2\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view id=\u0026#34;demo3\u0026#34; class=\u0026#34;scroll-view-item demo-text-3\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/scroll-view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;page-section\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;page-section-title\u0026#34;\u0026gt; \u0026lt;text\u0026gt;Horizontal Scroll\u0026lt;/text\u0026gt; \u0026lt;text\u0026gt;横向滚动\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;page-section-spacing\u0026#34;\u0026gt; \u0026lt;scroll-view type=\u0026#34;list\u0026#34; class=\u0026#34;scroll-view_H\u0026#34; scroll-x=\u0026#34;true\u0026#34; bindscroll=\u0026#34;scroll\u0026#34; style=\u0026#34;width: 100%;height: 300rpx;\u0026#34;\u0026gt; \u0026lt;view id=\u0026#34;demo1\u0026#34; class=\u0026#34;scroll-view-item_H demo-text-1\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view id=\u0026#34;demo2\u0026#34; class=\u0026#34;scroll-view-item_H demo-text-2\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;view id=\u0026#34;demo3\u0026#34; class=\u0026#34;scroll-view-item_H demo-text-3\u0026#34;\u0026gt;\u0026lt;/view\u0026gt; \u0026lt;/scroll-view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; Page({ tapMove() { this.setData({ scrollTop: this.data.scrollTop + 10 }) } }) .container { margin-top: 80px; } .page-section-spacing { margin-top: 60rpx; } .scroll-view_H { white-space: nowrap; } .scroll-view-item { height: 300rpx; } .scroll-view-item_H { display: inline-block; width: 100%; height: 300rpx; } .demo-text-1 { position: relative; align-items: center; justify-content: center; background-color: #1AAD19; color: #FFFFFF; font-size: 36rpx; } .demo-text-1::before { content: \u0026#39;A\u0026#39;; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .demo-text-2 { position: relative; align-items: center; justify-content: center; background-color: #2782D7; color: #FFFFFF; font-size: 36rpx; } .demo-text-2::before { content: \u0026#39;B\u0026#39;; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .demo-text-3 { position: relative; align-items: center; justify-content: center; background-color: #F1F1F1; color: #353535; font-size: 36rpx; } .demo-text-3::before { content: \u0026#39;C\u0026#39;; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html#scroll-view-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E7%A4%BA%E4%BE%8B\n以下是横向滚动案例\n\u0026lt;!-- scroll-view --\u0026gt; \u0026lt;scroll-view class=\u0026#34;myScroll\u0026#34; scroll-x\u0026gt; \u0026lt;view class=\u0026#34;myScroll.row\u0026#34;\u0026gt;1\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;2\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;3\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;4\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;5\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;6\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;7\u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;row\u0026#34;\u0026gt;8\u0026lt;/view\u0026gt; \u0026lt;/scroll-view\u0026gt; .myScroll { width: 100%; height: 220rpx; background: #eee; /* 使文本在不换行的情况下继续显示 */ white-space: nowrap; } .myScroll .row { width: 220rpx; height: 220rpx; background: burlywood; margin-right: 20rpx; display: inline-block; } .myScroll .row:last-child { margin-right: 0; } icon ​ icon组件就是在页面可以显示一个图标。\n\u0026lt;icon type=\u0026#34;success\u0026#34;\u0026gt;\u0026lt;/icon\u0026gt; \u0026lt;icon type=\u0026#34;success\u0026#34; size=\u0026#34;50\u0026#34;\u0026gt;\u0026lt;/icon\u0026gt; \u0026lt;icon type=\u0026#34;warn\u0026#34;\u0026gt;\u0026lt;/icon\u0026gt; 属性 类型 默认值 必填 说明 最低版本 type string 是 icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear 1.0.0 size number/string 23 否 icon的大小，单位默认为px，2.4.0起支持传入单位(rpx/px)，2.21.3起支持传入其余单位(rem 等)。 1.0.0 color string 否 icon的颜色，同css的color 1.0.0 progress 进度条 进度条。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。\n属性 类型 默认值 必填 说明 最低版本 percent number 否 百分比0~100 1.0.0 show-info boolean false 否 在进度条右侧显示百分比 1.0.0 border-radius number/string 0 否 圆角大小 2.3.1 font-size number/string 16 否 右侧百分比字体大小 2.3.1 stroke-width number/string 6 否 进度条线的宽度 1.0.0 color string #09BB07 否 进度条颜色（请使用activeColor） 1.0.0 activeColor string #09BB07 否 已选择的进度条的颜色 1.0.0 backgroundColor string #EBEBEB 否 未选择的进度条的颜色 1.0.0 active boolean false 否 进度条从左往右的动画 1.0.0 active-mode string backwards 否 backwards: 动画从头播；forwards：动画从上次结束点接着播 1.7.0 duration number 30 否 进度增加1%所需毫秒数 2.8.2 bindactiveend eventhandle 否 动画完成事件 2.4.1 \u0026lt;progress percent=\u0026#34;20\u0026#34; show-info /\u0026gt; \u0026lt;progress percent=\u0026#34;40\u0026#34; stroke-width=\u0026#34;12\u0026#34; /\u0026gt; \u0026lt;progress percent=\u0026#34;60\u0026#34; color=\u0026#34;pink\u0026#34; /\u0026gt; \u0026lt;progress percent=\u0026#34;80\u0026#34; active /\u0026gt; 表单组件 具体可以在官方文档查看\nButton https://developers.weixin.qq.com/miniprogram/dev/component/button.html\n具体属性看官方文档, 可以通过 open-type 配置分享, 打开交流窗口等等功能\n\u0026lt;button size=\u0026#34;default\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;button size=\u0026#34;mini\u0026#34;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;button size=\u0026#34;mini\u0026#34; type=\u0026#34;primary\u0026#34;\u0026gt;按钮3\u0026lt;/button\u0026gt; \u0026lt;button size=\u0026#34;mini\u0026#34; type=\u0026#34;warn\u0026#34;\u0026gt;按钮3\u0026lt;/button\u0026gt; \u0026lt;button size=\u0026#34;mini\u0026#34; type=\u0026#34;primary\u0026#34; open-type=\u0026#34;share\u0026#34;\u0026gt;按钮4\u0026lt;/button\u0026gt; 导航组件 navigator https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html\nnavigator组件相当于HTML的超链接标签。\n\u0026lt;!-- navigator组件相当于HTML的超链接标签。 target属性：在哪个目标上发生跳转，默认self-当前小程序； url属性：当前小程序内的跳转链接 open-type属性：指定跳转方式，默认是navigate navigate：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 redirect：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 switchTab：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 reLaunch：关闭所有页面，打开到应用内的某个页面 navigateBack：关闭当前页面，返回上一页面或多级页面。 --\u0026gt; \u0026lt;navigator target=\u0026#34;self\u0026#34; url=\u0026#34;../about/about\u0026#34; open-type=\u0026#34;switchTab\u0026#34;\u0026gt;点我跳转\u0026lt;/navigator\u0026gt; \u0026lt;!-- 导航 跳转到页面，都不写后缀名 1、open-type=\u0026#39;navigate\u0026#39; 跳转方式: 保留当前页面，跳转应用内的某个页面，但不跳转tabber页面 2、open-type=\u0026#34;redirect 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 没返回，有返回首页 3、open-type=\u0026#34;switchTab\u0026#34; 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 4、reLaunch 关闭所有页面，打开到应用内的某个页面 5、navigateBack 关闭当前页面，返回上一页面或多级页面。标签的话，就是返回上一页。用方法的话，可以指定返回多少级 6、exit\t退出小程序，`target=\u0026#34;miniProgram\u0026#34;`时生效 需要用真机去测 --\u0026gt; \u0026lt;navigator url=\u0026#34;../detail/detail\u0026#34;\u0026gt;进入详情页\u0026lt;/navigator\u0026gt; \u0026lt;navigator url=\u0026#34;../detail/detail\u0026#34; open-type=\u0026#34;redirect\u0026#34;\u0026gt;redirect 进入详情页\u0026lt;/navigator\u0026gt; \u0026lt;navigator url=\u0026#34;../index/index\u0026#34; open-type=\u0026#34;switchTab\u0026#34;\u0026gt;跳转到首页\u0026lt;/navigator\u0026gt; \u0026lt;!-- 还可以调tabBar --\u0026gt; \u0026lt;navigator url=\u0026#34;../detail/detail\u0026#34; open-type=\u0026#34;reLaunch\u0026#34;\u0026gt;reLaunch 到详情页\u0026lt;/navigator\u0026gt; \u0026lt;navigator open-type=\u0026#34;exit\u0026#34; target=\u0026#34;miniProgram\u0026#34;\u0026gt;退出小程序\u0026lt;/navigator\u0026gt; 媒体组件 image https://developers.weixin.qq.com/miniprogram/dev/component/image.html\n为了保证大小, 可以使用裁剪或者缩放调整大小\n属性 类型 默认值 必填 说明 最低版本 show-menu-by-longpress boolean false 否 长按图片显示发送给朋友、收藏、保存图片、搜一搜、打开名片/前往群聊/打开小程序（若图片中包含对应二维码或小程序码）的菜单。 2.7.0 mode string scaleToFill 否 图片裁剪、缩放的模式 1.0.0 合法值 说明 最低版本 scaleToFill 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 aspectFit 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 aspectFill 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 widthFix 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变 heightFix 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变 2.10.3 top 裁剪模式，不缩放图片，只显示图片的顶部区域。仅 Webview 支持。 bottom 裁剪模式，不缩放图片，只显示图片的底部区域。仅 Webview 支持。 center 裁剪模式，不缩放图片，只显示图片的中间区域。仅 Webview 支持。 left 裁剪模式，不缩放图片，只显示图片的左边区域。仅 Webview 支持。 right 裁剪模式，不缩放图片，只显示图片的右边区域。仅 Webview 支持。 top left 裁剪模式，不缩放图片，只显示图片的左上边区域。仅 Webview 支持。 top right 裁剪模式，不缩放图片，只显示图片的右上边区域。仅 Webview 支持。 bottom left 裁剪模式，不缩放图片，只显示图片的左下边区域。仅 Webview 支持。 bottom right 裁剪模式，不缩放图片，只显示图片的右下边区域。仅 Webview 支持。 可以在 https://developers.weixin.qq.com/miniprogram/dev/component/image.html#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81 查看示例代码\n地图组件 https://developers.weixin.qq.com/miniprogram/dev/component/map.html\n\u0026lt;!-- latitude：维度 longitude：经度 --\u0026gt; \u0026lt;map longitude=\u0026#34;115\u0026#34; latitude=\u0026#34;39\u0026#34;\u0026gt;\u0026lt;/map\u0026gt; 框架 ​ 小程序依赖于微信客户端提供的环境\u0026ndash;宿主环境，小程序借助这个宿注环境提供的功能，可以实现网页无法实现的功能。让小程序更接近原生的app体验。\n小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。\n​ 首先，我们来简单了解下小程序的运行环境。整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）。小程序提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。\n​ 小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。\n响应的数据绑定 框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。\n\u0026lt;!-- This is our View --\u0026gt; \u0026lt;view\u0026gt; Hello {{name}}! \u0026lt;/view\u0026gt; \u0026lt;button bindtap=\u0026#34;changeName\u0026#34;\u0026gt; Click me! \u0026lt;/button\u0026gt; // This is our App Service. // This is our data. var helloData = { name: \u0026#39;Weixin\u0026#39; } // Register a Page. Page({ data: helloData, changeName: function(e) { // sent data change to view this.setData({ name: \u0026#39;MINA\u0026#39; }) } }) 开发者通过框架将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以在页面一打开的时候会显示 Hello Weixin!； 当点击按钮的时候，视图层会发送 changeName 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数； 回调函数触发后，逻辑层执行 setData 的操作，将 data 中的 name 从 Weixin 变为 MINA，因为该数据和视图层已经绑定了，从而视图层会自动改变为 Hello MINA!。 逻辑层 小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发 JavaScript 代码的运行环境以及微信小程序的特有功能。\n逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。\n开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。\n在 JavaScript 的基础上，我们增加了一些功能，以方便小程序的开发：\n增加 App 和 Page 方法，进行程序注册和页面注册。 增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。 提供模块化能力，每个页面有独立的作用域。 注意：小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 window，document 等。\n注册小程序 每个小程序都需要在 app.js 中调用 App 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。\n// app.js App({ onLaunch (options) { // Do something initial when launch. }, onShow (options) { // Do something when show. }, onHide () { // Do something when hide. }, onError (msg) { console.log(msg) }, globalData: \u0026#39;I am global data\u0026#39; } 属性 类型 默认值 必填 说明 最低版本 onLaunch function 否 生命周期回调——监听小程序初始化。 onShow function 否 生命周期回调——监听小程序启动或切前台。 onHide function 否 生命周期回调——监听小程序切后台。 onError function 否 错误监听函数。 onPageNotFound function 否 页面不存在监听函数。 1.9.90 onUnhandledRejection function 否 未处理的 Promise 拒绝事件监听函数。 2.10.0 onThemeChange function 否 监听系统主题变化 2.11.0 其他 any 否 开发者可以添加任意的函数或数据变量到 Object 参数中，用 this 可以访问 整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 App 上的函数。\n// xxx.js const appInstance = getApp() console.log(appInstance.globalData) // I am global data 注册页面 对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。\n使用 Page 构造器注册页 简单的页面可以使用 Page() 进行构造。\n代码示例：\n//index.js Page({ data: { text: \u0026#34;This is page data.\u0026#34; }, onLoad: function(options) { // 页面创建时执行 }, onShow: function() { // 页面出现在前台时执行 }, onReady: function() { // 页面首次渲染完毕时执行 }, onHide: function() { // 页面从前台变为后台时执行 }, onUnload: function() { // 页面销毁时执行 }, onPullDownRefresh: function() { // 触发下拉刷新时执行 }, onReachBottom: function() { // 页面触底时执行 }, onShareAppMessage: function () { // 页面被用户分享时执行 }, onPageScroll: function() { // 页面滚动时执行 }, onResize: function() { // 页面尺寸变化时执行 }, onTabItemTap(item) { // tab 点击时执行 console.log(item.index) console.log(item.pagePath) console.log(item.text) }, // 事件响应函数 viewTap: function() { this.setData({ text: \u0026#39;Set some data for updating view.\u0026#39; }, function() { // this is setData callback }) }, // 自由数据 customData: { hi: \u0026#39;MINA\u0026#39; } }) 详细的参数含义和使用请参考 Page 参考文档\n页面生命周期 模块化 可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。\n注意：\nexports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。 小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中，或者使用小程序支持的 npm 功能。 // common.js function sayHello(name) { console.log(`Hello ${name} !`) } function sayGoodbye(name) { console.log(`Goodbye ${name} !`) } module.exports.sayHello = sayHello exports.sayGoodbye = sayGoodbye 在需要使用这些模块的文件中，使用 require 将公共代码引入\nvar common = require(\u0026#39;common.js\u0026#39;) Page({ helloMINA: function() { common.sayHello(\u0026#39;MINA\u0026#39;) }, goodbyeMINA: function() { common.sayGoodbye(\u0026#39;MINA\u0026#39;) } }) 文件作用域 在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。\n通过全局函数 getApp 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置，如：\n// app.js App({ globalData: 1 }) // a.js // The localValue can only be used in file a.js. var localValue = \u0026#39;a\u0026#39; // Get the app instance. var app = getApp() // Get the global data and change it. app.globalData++ // b.js // You can redefine localValue in file b.js, without interference with the localValue in a.js. var localValue = \u0026#39;b\u0026#39; // If a.js it run before b.js, now the globalData shoule be 2. console.log(getApp().globalData) API 详细见 https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#API\n视图层 WXML 数据绑定 \u0026lt;!--wxml--\u0026gt; \u0026lt;view\u0026gt; {{message}} \u0026lt;/view\u0026gt; // page.js Page({ data: { message: \u0026#39;Hello MINA!\u0026#39; } }) 列表渲染 \u0026lt;!--wxml--\u0026gt; \u0026lt;view wx:for=\u0026#34;{{array}}\u0026#34;\u0026gt; {{item}} \u0026lt;/view\u0026gt; // page.js Page({ data: { array: [1, 2, 3, 4, 5] } }) 条件渲染 \u0026lt;!--wxml--\u0026gt; \u0026lt;view wx:if=\u0026#34;{{view == \u0026#39;WEBVIEW\u0026#39;}}\u0026#34;\u0026gt; WEBVIEW \u0026lt;/view\u0026gt; \u0026lt;view wx:elif=\u0026#34;{{view == \u0026#39;APP\u0026#39;}}\u0026#34;\u0026gt; APP \u0026lt;/view\u0026gt; \u0026lt;view wx:else=\u0026#34;{{view == \u0026#39;MINA\u0026#39;}}\u0026#34;\u0026gt; MINA \u0026lt;/view\u0026gt; // page.js Page({ data: { view: \u0026#39;MINA\u0026#39; } }) 模板 \u0026lt;!--wxml--\u0026gt; \u0026lt;template name=\u0026#34;staffName\u0026#34;\u0026gt; \u0026lt;view\u0026gt; FirstName: {{firstName}}, LastName: {{lastName}} \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template is=\u0026#34;staffName\u0026#34; data=\u0026#34;{{...staffA}}\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template is=\u0026#34;staffName\u0026#34; data=\u0026#34;{{...staffB}}\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; \u0026lt;template is=\u0026#34;staffName\u0026#34; data=\u0026#34;{{...staffC}}\u0026#34;\u0026gt;\u0026lt;/template\u0026gt; // page.js Page({ data: { staffA: {firstName: \u0026#39;Hulk\u0026#39;, lastName: \u0026#39;Hu\u0026#39;}, staffB: {firstName: \u0026#39;Shang\u0026#39;, lastName: \u0026#39;You\u0026#39;}, staffC: {firstName: \u0026#39;Gideon\u0026#39;, lastName: \u0026#39;Lin\u0026#39;} } }) 三目运算符 //\u0026lt;view class=\u0026#34;{{flag?\u0026#39;red\u0026#39;:\u0026#39;green\u0026#39;}}\u0026#34;\u0026gt;是否加样式\u0026lt;/view\u0026gt; data: { flag: false, }, // Register a Page. Page({ data: helloData, changeName: function (e) { // sent data change to view console.log(this.data) this.data.name = this.data.name === \u0026#39;Weixin\u0026#39; ? \u0026#39;xxx\u0026#39; : \u0026#39;Weixin\u0026#39; this.setData({ name: this.data.name }) } }) 具体的能力以及使用方式在以下章节查看：\n数据绑定、列表渲染、条件渲染、模板、引用\nWXS WXS（WeiXin Script）是内联在 WXML 中的脚本段。通过 WXS 可以在模版中内联少量处理脚本，丰富模板的数据预处理能力。另外， WXS 还可以用来编写简单的 WXS 事件响应函数。\n从语法上看， WXS 类似于有少量限制的 JavaScript 。要完整了解 WXS 语法，请参考WXS 语法参考。\n以下是一些使用 WXS 的简单示例。\n页面渲染 \u0026lt;!--wxml--\u0026gt; \u0026lt;wxs module=\u0026#34;m1\u0026#34;\u0026gt; var msg = \u0026#34;hello world\u0026#34;; module.exports.message = msg; \u0026lt;/wxs\u0026gt; \u0026lt;view\u0026gt; {{m1.message}} \u0026lt;/view\u0026gt; 数据处理 // page.js Page({ data: { array: [1, 2, 3, 4, 5, 1, 2, 3, 4] } }) \u0026lt;!--wxml--\u0026gt; \u0026lt;!-- 下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值 --\u0026gt; \u0026lt;wxs module=\u0026#34;m1\u0026#34;\u0026gt; var getMax = function(array) { var max = undefined; for (var i = 0; i \u0026lt; array.length; ++i) { max = max === undefined ? array[i] : (max \u0026gt;= array[i] ? max : array[i]); } return max; } module.exports.getMax = getMax; \u0026lt;/wxs\u0026gt; \u0026lt;!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array --\u0026gt; \u0026lt;view\u0026gt; {{m1.getMax(array)}} \u0026lt;/view\u0026gt; 简易双向绑定 在 WXML 中，普通的属性的绑定是单向的。例如：\n\u0026lt;input value=\u0026#34;{{value}}\u0026#34; /\u0026gt; 如果使用 this.setData({ value: 'leaf' }) 来更新 value ，this.data.value 和输入框的中显示的值都会被更新为 leaf ；但如果用户修改了输入框里的值，却不会同时改变 this.data.value 。\n如果需要在用户输入的同时改变 this.data.value ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 model: 前缀：\n如果使用 this.setData({ value: 'leaf' }) 来更新 value ，this.data.value 和输入框的中显示的值都会被更新为 leaf ；但如果用户修改了输入框里的值，却不会同时改变 this.data.value 。\n如果需要在用户输入的同时改变 this.data.value ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 model: 前缀：\n\u0026lt;input model:value=\u0026#34;{{value}}\u0026#34; /\u0026gt; 这样，如果输入框的值被改变了， this.data.value 也会同时改变。同时， WXML 中所有绑定了 value 的位置也会被一同更新， 数据监听器 也会被正常触发。\n在开发者工具中预览效果\n用于双向绑定的表达式有如下限制：\n只能是一个单一字段的绑定，如 \u0026lt;input model:value=\u0026#34;值为 {{value}}\u0026#34; /\u0026gt; \u0026lt;input model:value=\u0026#34;{{ a + b }}\u0026#34; /\u0026gt; 都是非法的；\n目前，尚不能 data 路径，如 \u0026lt;input model:value=\u0026#34;{{ a.b }}\u0026#34; /\u0026gt; 这样的表达式目前暂不支持。\n关于微信小程序警告“Do not have handler in component: pages/xxx/xxx. “的解决方法\n通过资料查询和微信开发者社区询问，原因是没有绑定bindinput方法，因此我们可以为表单绑定一个空的方法，来解决这个警告\n\u0026lt;input model:value=\u0026#34;{{name}}\u0026#34; bindinput=\u0026#34;textCallback\u0026#34;/\u0026gt; \u0026lt;!-- js --\u0026gt; Page({ data: helloData, changeName: function (e) { // sent data change to view console.log(this.data) this.data.name = this.data.name === \u0026#39;Weixin\u0026#39; ? \u0026#39;xxx\u0026#39; : \u0026#39;Weixin\u0026#39; this.setData({ name: this.data.name }) }, textCallback: function () {} }) 在自定义组件中传递双向绑定 双向绑定同样可以使用在自定义组件上。如下的自定义组件：\n// custom-component.js Component({ properties: { myValue: String } }) \u0026lt;!-- custom-component.wxml --\u0026gt; \u0026lt;input model:value=\u0026#34;{{myValue}}\u0026#34; /\u0026gt; 这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value 属性上。这样，如果页面这样使用这个组件：\n\u0026lt;custom-component model:my-value=\u0026#34;{{pageValue}}\u0026#34; /\u0026gt; 当输入框的值变更时，自定义组件的 myValue 属性会同时变更，这样，页面的 this.data.pageValue 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。\n在自定义组件中触发双向绑定更新 自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData 设置自身的属性。例如：\n// custom-component.js Component({ properties: { myValue: String }, methods: { update: function() { // 更新 myValue this.setData({ myValue: \u0026#39;leaf\u0026#39; }) } } }) 如果页面这样使用这个组件：\n\u0026lt;custom-component model:my-value=\u0026#34;{{pageValue}}\u0026#34; /\u0026gt; 当组件使用 setData 更新 myValue 时，页面的 this.data.pageValue 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。\n响应显示区域变化 具体看 https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html\n从小程序基础库版本 2.4.0 开始，小程序在手机上支持屏幕旋转。使小程序中的页面支持屏幕旋转的方法是：在 app.json 的 window 段中设置 \u0026quot;pageOrientation\u0026quot;: \u0026quot;auto\u0026quot; ，或在页面 json 文件中配置 \u0026quot;pageOrientation\u0026quot;: \u0026quot;auto\u0026quot; 。\n以下是在单个页面 json 文件中启用屏幕旋转的示例。\n代码示例：\n{ \u0026#34;pageOrientation\u0026#34;: \u0026#34;auto\u0026#34; } 如果页面添加了上述声明，则在屏幕旋转时，这个页面将随之旋转，显示区域尺寸也会随着屏幕旋转而变化。\n从小程序基础库版本 2.5.0 开始， pageOrientation 还可以被设置为 landscape ，表示固定为横屏显示。\n动画 https://developers.weixin.qq.com/miniprogram/dev/framework/view/animation.html\n初始渲染缓存 小程序页面的初始化分为两个部分。\n逻辑层初始化：载入必需的小程序代码、初始化页面 this 对象（也包括它涉及到的所有自定义组件的 this 对象）、将相关数据发送给视图层。 视图层初始化：载入必需的小程序代码，然后等待逻辑层初始化完毕并接收逻辑层发送的数据，最后渲染页面。 在启动页面时，尤其是小程序冷启动、进入第一个页面时，逻辑层初始化的时间较长。在页面初始化过程中，用户将看到小程序的标准载入画面（冷启动时）或可能看到轻微的白屏现象（页面跳转过程中）。\n启用初始渲染缓存，可以使视图层不需要等待逻辑层初始化完毕，而直接提前将页面初始 data 的渲染结果展示给用户，这可以使得页面对用户可见的时间大大提前。它的工作原理如下：\n在小程序页面第一次被打开后，将页面初始数据渲染结果记录下来，写入一个持久化的缓存区域（缓存可长时间保留，但可能因为小程序更新、基础库更新、储存空间回收等原因被清除）； 在这个页面被第二次打开时，检查缓存中是否还存有这个页面上一次初始数据的渲染结果，如果有，就直接将渲染结果展示出来； 如果展示了缓存中的渲染结果，这个页面暂时还不能响应用户事件，等到逻辑层初始化完毕后才能响应用户事件。 利用初始渲染缓存，可以：\n快速展示出页面中永远不会变的部分，如导航栏； 预先展示一个骨架页，提升用户体验； 展示自定义的加载提示； 提前展示广告，等等。 支持的组件 在初始渲染缓存阶段中，复杂组件不能被展示或不能响应交互。\n目前支持的内置组件：\n\u0026lt;view /\u0026gt; \u0026lt;text /\u0026gt; \u0026lt;button /\u0026gt; \u0026lt;image /\u0026gt; \u0026lt;scroll-view /\u0026gt; \u0026lt;rich-text /\u0026gt; 自定义组件本身可以被展示（但它们里面用到的内置组件也遵循上述限制）。\n静态初始渲染缓存 若想启用初始渲染缓存，最简单的方法是在页面的 json 文件中添加配置项 \u0026quot;initialRenderingCache\u0026quot;: \u0026quot;static\u0026quot; ：\n{ \u0026#34;initialRenderingCache\u0026#34;: \u0026#34;static\u0026#34; } 如果想要对所有页面启用，可以在 app.json 的 window 配置段中添加这个配置：\n{ \u0026#34;window\u0026#34;: { \u0026#34;initialRenderingCache\u0026#34;: \u0026#34;static\u0026#34; } } 添加这个配置项之后，在手机中预览小程序首页，然后杀死小程序再次进入，就会通过初始渲染缓存来渲染首页。\n注意：这种情况下，初始渲染缓存记录的是页面 data 应用在页面 WXML 上的结果，不包含任何 setData 的结果。\n例如，如果想要在页面中展示出“正在加载”几个字，这几个字受到 loading 数据字段控制：\n\u0026lt;view wx:if=\u0026#34;{{loading}}\u0026#34;\u0026gt;正在加载\u0026lt;/view\u0026gt; 这种情况下， loading 应当在 data 中指定为 true ，如：\n// 正确的做法 Page({ data: { loading: true } }) 而不能通过 setData 将 loading 置为 true ：\n// 错误的做法！不要这么做！ Page({ data: {}, onLoad: function() { this.setData({ loading: true }) } }) 换而言之，这种做法只包含页面 data 的渲染结果，即页面的纯静态成分。\n在初始渲染缓存中添加动态内容 有些场景中，只是页面 data 的渲染结果会比较局限。有时会想要额外展示一些可变的内容，如展示的广告图片 URL 等。\n这种情况下可以使用“动态”初始渲染缓存的方式。首先，配置 \u0026quot;initialRenderingCache\u0026quot;: \u0026quot;dynamic\u0026quot; ：\n{ \u0026#34;initialRenderingCache\u0026#34;: \u0026#34;dynamic\u0026#34; } 此时，初始渲染缓存不会被自动启用，还需要在页面中调用 this.setInitialRenderingCache(dynamicData) 才能启用。其中， dynamicData 是一组数据，与 data 一起参与页面 WXML 渲染。\nPage({ data: { loading: true }, onReady: function() { this.setInitialRenderingCache({ loadingHint: \u0026#39;正在加载\u0026#39; // 这一部分数据将被应用于界面上，相当于在初始 data 基础上额外进行一次 setData }) } }) \u0026lt;view wx:if=\u0026#34;{{loading}}\u0026#34;\u0026gt;{{loadingHint}}\u0026lt;/view\u0026gt; 从原理上说，在动态生成初始渲染缓存的方式下，页面会在后台使用动态数据重新渲染一次，因而开销相对较大。因而要尽量避免频繁调用 this.setInitialRenderingCache ，如果在一个页面内多次调用，仅最后一次调用生效。\n注意：\nthis.setInitialRenderingCache 调用时机不能早于 Page 的 onReady 或 Component 的 ready 生命周期，否则可能对性能有负面影响。 如果想禁用初始渲染缓存，调用 this.setInitialRenderingCache(null) 。 自定义 tabBar 参考 https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html\n自定义tabBar 自定义 tabBar 可以让开发者更加灵活地设置 tabBar 样式，以满足更多个性化的场景。\n在自定义 tabBar 模式下\n为了保证低版本兼容以及区分哪些页面是 tab 页，tabBar 的相关配置项需完整声明，但这些字段不会作用于自定义 tabBar 的渲染。 此时需要开发者提供一个自定义组件来渲染 tabBar，所有 tabBar 的样式都由该自定义组件渲染。推荐用 fixed 在底部的 cover-view + cover-image 组件渲染样式，以保证 tabBar 层级相对较高。 与 tabBar 样式相关的接口，如 wx.setTabBarItem 等将失效。 每个 tab 页下的自定义 tabBar 组件实例是不同的，可通过自定义组件下的 getTabBar 接口，获取当前页面的自定义 tabBar 组件实例。 注意：如需实现 tab 选中态，要在当前页面下，通过 getTabBar 接口获取组件实例，并调用 setData 更新选中态。可参考底部的代码示例。\n使用 配置信息 在 app.json 中的 tabBar 项指定 custom 字段，同时其余 tabBar 相关配置也补充完整。 所有 tab 页的 json 里需声明 usingComponents 项，也可以在 app.json 全局开启。 { \u0026#34;tabBar\u0026#34;: { \u0026#34;custom\u0026#34;: true, \u0026#34;color\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;selectedColor\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;backgroundColor\u0026#34;: \u0026#34;#000000\u0026#34;, \u0026#34;list\u0026#34;: [{ \u0026#34;pagePath\u0026#34;: \u0026#34;page/component/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;组件\u0026#34; }, { \u0026#34;pagePath\u0026#34;: \u0026#34;page/API/index\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;接口\u0026#34; }] }, \u0026#34;usingComponents\u0026#34;: {} } 添加 tabBar 代码文件 在代码根目录下添加入口文件:\ncustom-tab-bar/index.js custom-tab-bar/index.json custom-tab-bar/index.wxml custom-tab-bar/index.wxss 3. 编写 tabBar 代码\n用自定义组件的方式编写即可，该自定义组件完全接管 tabBar 的渲染。另外，自定义组件新增 getTabBar 接口，可获取当前页面下的自定义 tabBar 组件实例\n以下是一个简单的自定义 tabBar 组件示例：\n\u0026lt;view class=\u0026#34;tabbar\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;tabbar-item {{ select === index ? \u0026#39;tabbar-select\u0026#39; : \u0026#39;\u0026#39; }}\u0026#34; wx:for=\u0026#34;{{ list }}\u0026#34; wx:key=\u0026#34;index\u0026#34; data-page=\u0026#34;{{ item.pagePath }}\u0026#34; data-index=\u0026#34;{{ index }}\u0026#34; data-type=\u0026#34;{{ item.type }}\u0026#34; bindtap=\u0026#34;selectPage\u0026#34;\u0026gt; \u0026lt;block wx:if=\u0026#34;{{ item.type === 0 }}\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;tabbar-image\u0026#34; src=\u0026#34;{{ select === index ? item.selectedIconPath : item.iconPath }}\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;text class=\u0026#34;tabbar-text\u0026#34;\u0026gt;{{ item.text }}\u0026lt;/text\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;block wx:else\u0026gt; \u0026lt;view class=\u0026#34;publish\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;tabbar-image\u0026#34; src=\u0026#34;../images/add.png\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/block\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; Component({ data: { select: 0, list: [ { iconPath: \u0026#34;/images/index.png\u0026#34;, pagePath: \u0026#34;/pages/index/index\u0026#34;, selectedIconPath: \u0026#34;/images/index_fill.png\u0026#34;, text: \u0026#34;首页\u0026#34;, type: 0 }, { iconPath: \u0026#34;/images/classify.png\u0026#34;, pagePath: \u0026#34;/pages/classify/classify\u0026#34;, selectedIconPath: \u0026#34;/images/classify_fill.png\u0026#34;, text: \u0026#34;分类\u0026#34;, type: 0 }, { type: 1, pagePath: \u0026#34;/pages/publish/publish\u0026#34;, }, { iconPath: \u0026#34;/images/collection.png\u0026#34;, pagePath: \u0026#34;/pages/collection/collection\u0026#34;, selectedIconPath: \u0026#34;/images/collection_fill.png\u0026#34;, text: \u0026#34;收藏夹\u0026#34;, type: 0, }, { iconPath: \u0026#34;/images/me.png\u0026#34;, pagePath: \u0026#34;/pages/me/me\u0026#34;, selectedIconPath: \u0026#34;/images/me_fill.png\u0026#34;, text: \u0026#34;我的\u0026#34;, type: 0 } ] }, methods: { selectPage(e) { const { index, page, type } = e.currentTarget.dataset if (index !== this.data.select \u0026amp;\u0026amp; type === 0) { wx.switchTab({ url: page, }) } if (type === 1) { wx.navigateTo({ url: \u0026#39;../../pages/publish/publish\u0026#39;, }) } this.setData({ select: index }) } } }) .tabbar { width: 100%; height: 80rpx; display: flex; background-color: #fff; position: fixed; bottom: 0; padding-bottom: env(safe-area-inset-bottom); padding-top: 10rpx; z-index: 9999; } .tabbar-item { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; } .tabbar-item .tabbar-image { width: 40rpx; height: 40rpx; } .tabbar-item .tabbar-text { font-size: 26rpx; margin-top: 10rpx; } .tabbar-item .publish { padding: 8px; background-color: #B2A4EC; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-bottom: auto; } .tabbar-select { color: #B2A4EC; } skyline 模式 ","permalink":"https://waite.wang/posts/mini-program/learn-wechat-minipro-1/","summary":"\u003ch2 id=\"微信小程序入门\"\u003e微信小程序入门\u003c/h2\u003e\n\u003ch3 id=\"微信小程序介绍\"\u003e微信小程序介绍\u003c/h3\u003e\n\u003ch4 id=\"微信小程序介绍-1\"\u003e微信小程序介绍\u003c/h4\u003e\n\u003cp\u003e​ 微信小程序，简称小程序，是一种不需要下载安装即可使用的应用，它实现了应用”触手可及”的梦想，用户扫一扫或搜一下即可打开应用。\u003c/p\u003e\n\u003cp\u003e​ 说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e小程序是需要下载的，小程序的占用大小很小，感觉不到下载\u003c/li\u003e\n\u003cli\u003e目前大小限制2M （最终开发的小程序打包压缩后的大小），如果超过2M,就得做分包上传.之后再合并\u003c/li\u003e\n\u003cli\u003e进入小程序后继续网络请求数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"小程序特点\"\u003e小程序特点\u003c/h4\u003e\n\u003cp\u003e微信小程序的特点：\u003c/p\u003e","title":"微信小程序入门"},{"content":"认识组件化开发 认识组件化开发 人面对复杂问题的处理方式： 任何一个人处理信息的逻辑能力都是有限的 所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。 但是，我们人有一种天生的能力，就是将问题进行拆解。 如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。 组件化也是类似的思想： 如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展； 但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了； 如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目； 现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想 所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。 我们需要通过组件化的思想来思考整个应用程序： 我们将一个完整的页面分成很多个组件； 每个组件都用于实现页面的一个功能块； 而每一个组件又可以进行细分； 而组件本身又可以在多个地方进行复用； Vue的组件化 vue 项目起始文件 createApp 函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的根 组件； 组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用； 任何的应用都会被抽象成一颗组件树； 组件名称 在通过 app.componen t注册一个组件的时候，第一个参数是组件的名称，定义组件名的方式有两种： 方式一：使用 kebab-case（短横线分割符） 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case， 例如 \u0026lt;my-component-name\u0026gt;; 方式二：使用 PascalCase（驼峰标识符） 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也 就是说 \u0026lt;my-component-name\u0026gt;和 MyComponentName 都是可接受的； 在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 DOM 内模板解析注意事项。 为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 MyComponent 为名注册的组件，在模板中可以通过 \u0026lt;MyComponent\u0026gt; 或 \u0026lt;my-component\u0026gt; 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。 注册组件的方式 https://cn.vuejs.org/guide/components/registration.html#component-registration\n如果我们现在有一部分内容（模板、逻辑等），我们希望将这部分内容抽取到一个独立的组件中去维护，这个时候 如何注册一个组件呢？ 我们先从简单的开始谈起，比如下面的模板希望抽离到一个单独的组件： \u0026lt;h2\u0026gt;{{title}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; 注册组件分成两种： 全局组件：在任何其他的组件中都可以使用的组件； 局部组件：只有在注册的组件中才能使用的组件； 注册全局组件 全局组件需要使用我们全局创建的app来注册组件； 通过component方法传入组件名称、组件对象即可注册一个全局组件了； 之后，我们可以在App组件的template中直接使用这个全局组件： \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;component-a\u0026gt;\u0026lt;/component-a\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, } // 使用 app.component() 注册一个全局组件, app.component() 是 Vue.createApp() 的一个方法 const app = Vue.createApp(App); // app.component() 的第一个参数是组件的名称, 第二个参数是组件的配置对象 app.component(\u0026#39;component-a\u0026#39;, { template: \u0026#39;\u0026lt;h2\u0026gt;{{ title }}\u0026lt;/h2\u0026gt;\u0026#39;, data() { return { title: \u0026#39;我是标题\u0026#39;, desc: \u0026#39;我是内容, 哈哈哈哈哈\u0026#39; } }, methods: { btnClick() { console.log(\u0026#39;按钮的点击\u0026#39;); } } }); app.mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 也可以\n\u0026lt;template id=\u0026#34;component-a\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ title }}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{ desc }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; app.component(\u0026#39;component-a\u0026#39;, { template: \u0026#39;#component-a\u0026#39;, ... } 注册局部组件 全局注册虽然很方便，但有以下几个问题：\n全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。 相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。\n局部注册需要使用 components 选项：\n\u0026lt;script\u0026gt; import ComponentA from \u0026#39;./ComponentA.vue\u0026#39; export default { components: { ComponentA } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;ComponentA /\u0026gt; \u0026lt;/template\u0026gt; 对于每个 components 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\nexport default { components: { ComponentA: ComponentA } // ... } 请注意：局部注册的组件在后代组件中并不可用。在这个例子中，ComponentA 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。\n全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注 册： 比如我们注册了三个全局组件：ComponentA、ComponentB、ComponentC； 在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行 了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包； 这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包 的大小； 所以在开发中我们通常使用组件的时候采用的都是局部注册： 局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册； 比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项； 该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象； Vue的开发模式 目前我们使用vue的过程都是在html文件中，通过template编写自己的模板、脚本逻辑、样式等。 但是随着项目越来越复杂，我们会采用组件化的方式来进行开发： 这就意味着每个组件都会有自己的模板、脚本逻辑、样式等； 当然我们依然可以把它们抽离到单独的js、css文件中，但是它们还是会分离开来； 也包括我们的script是在一个全局的作用域下，很容易出现命名冲突的问题； 并且我们的代码为了适配一些浏览器，必须使用ES5的语法； 在我们编写代码完成之后，依然需要通过工具对代码进行构建、代码； 所以在真实开发中，我们可以通过一个后缀名为 .vue 的single-file components (单文件组件) 来解决，并且可以使用 webpack 或者 vite 或者 rollup 等构建工具来对其进行处理。 比如: 我们可以单独抽离组件 componentA\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{ title }}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{ desc }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;按钮点击\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { title: \u0026#34;我是标题\u0026#34;, desc: \u0026#34;我是内容, 哈哈哈哈哈\u0026#34;, }; }, methods: { btnClick() { console.log(\u0026#34;按钮的点击\u0026#34;); }, }, }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 在这个组件中我们可以获得非常多的特性：\n代码的高亮； ES6、CommonJS的模块化能力； 组件作用域的CSS； 可以使用预处理器来构建更加丰富的组件，比如TypeScript、Babel、Less、Sass等； 如何支持SFC 如果我们想要使用这一 componentA.vue 文件，比较常见的是两种方式： 方式一：使用Vue CLI来创建项目，项目会默认帮助我们配置好所有的配置选项，可以在其中直接使用.vue文件； 方式二：自己使用webpack或rollup或 vite 这类打包工具，对其进行打包处理； 组件实例 $refs https://cn.vuejs.org/api/component-instance.html#refs\n某些情况下，我们在组件中想要直接获取到元素对象或者子组件实例： 在Vue开发中我们是不推荐进行DOM操作的； 这个时候，我们可以给元素或者组件绑定一个ref的attribute属性； 在Vue 3中，$refs属性用于访问父组件中的子组件或DOM元素。它允许您以编程方式直接引用和操作这些组件或元素。 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component ref=\u0026#34;childRef\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;button @click=\u0026#34;logChildRef\u0026#34;\u0026gt;Log Child Ref\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, methods: { logChildRef() { console.log(this.$refs.childRef); } } } \u0026lt;/script\u0026gt; 在上面的示例中，我们通过使用ref属性给子组件命名为childRef，然后可以通过this.$refs.childRef来访问和操作子组件。在点击\u0026quot;Log Child Ref\u0026quot;按钮时，会将子组件实例打印到控制台。\n$parent, $root https://cn.vuejs.org/api/component-instance.html#parent\n在Vue中，$parent和$root都是用于访问组件层级关系的特殊属性。\n$parent属性用于访问当前组件的父组件实例。通过this.$parent可以访问父组件的属性和方法。 $root属性用于访问根组件实例。根组件是Vue应用的最顶层组件，通过this.$root可以访问根组件的属性和方法。 这些属性在处理组件之间的通信或访问全局状态时非常有用。\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, mounted() { console.log(this.$parent); // 访问父组件实例 console.log(this.$root); // 访问根组件实例 } } \u0026lt;/script\u0026gt; 在上面的示例中，父组件中通过使用$parent属性访问了父组件实例，使用​$root属性访问了根组件实例，并将它们打印到控制台。\n组件的 v-model https://cn.vuejs.org/guide/components/v-model.html#component-v-model\nv-model 可以在组件上使用以实现双向绑定。\n首先让我们回忆一下 v-model 在原生元素上的用法：\n\u0026lt;input v-model=\u0026#34;searchText\u0026#34; /\u0026gt; 在代码背后，模板编译器会对 v-model 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：\n\u0026lt;input :value=\u0026#34;searchText\u0026#34; @input=\u0026#34;searchText = $event.target.value\u0026#34; /\u0026gt; 而当使用在一个组件上时，v-model 会被展开为如下的形式：\n\u0026lt;CustomInput :model-value=\u0026#34;searchText\u0026#34; @update:model-value=\u0026#34;newValue =\u0026gt; searchText = newValue\u0026#34; /\u0026gt; 要让这个例子实际工作起来，\u0026lt;CustomInput\u0026gt; 组件内部需要做两件事：\n将内部原生 \u0026lt;input\u0026gt; 元素的 value attribute 绑定到 modelValue prop 当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件 \u0026lt;!-- CustomInput.vue --\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;modelValue\u0026#39;], emits: [\u0026#39;update:modelValue\u0026#39;] } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:modelValue\u0026#39;, $event.target.value)\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 现在 v-model 可以在这个组件上正常工作了：\n\u0026lt;CustomInput v-model=\u0026#34;searchText\u0026#34; /\u0026gt; 另一种在组件内实现 v-model 的方式是使用一个可写的，同时具有 getter 和 setter 的 computed 属性。get 方法需返回 modelValue prop，而 set 方法需触发相应的事件：\n\u0026lt;!-- CustomInput.vue --\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;modelValue\u0026#39;], emits: [\u0026#39;update:modelValue\u0026#39;], computed: { value: { get() { return this.modelValue }, set(value) { this.$emit(\u0026#39;update:modelValue\u0026#39;, value) } } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input v-model=\u0026#34;value\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 多个 v-model 绑定 利用刚才在 v-model 参数小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 v-model 双向绑定。\n组件上的每一个 v-model 都会同步不同的 prop，而无需额外的选项：\n\u0026lt;UserName v-model:first-name=\u0026#34;first\u0026#34; v-model:last-name=\u0026#34;last\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; export default { props: { firstName: String, lastName: String }, emits: [\u0026#39;update:firstName\u0026#39;, \u0026#39;update:lastName\u0026#39;] } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;firstName\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:firstName\u0026#39;, $event.target.value)\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;lastName\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:lastName\u0026#39;, $event.target.value)\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { modelValue: String, title: String }, emits: [\u0026#34;update:modelValue\u0026#34;, \u0026#34;update:title\u0026#34;], computed: { value: { set(value) { this.$emit(\u0026#34;update:modelValue\u0026#34;, value); }, get() { return this.modelValue; } }, why: { set(why) { this.$emit(\u0026#34;update:title\u0026#34;, why); }, get() { return this.title; } } } } \u0026lt;/script\u0026gt; 组件之间的通信 认识组件的嵌套 在之前的案例中，我们只是创建了一个组件App； 如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护； 所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件； 再将这些组件组合嵌套在一起，最终形成我们的应用程序； 我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;NavBar\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Banner\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;商品列表1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Footer\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;免责声明\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。\n所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。\n组件的拆分 如上代码, 我们可以按照如下的方式进行拆分：\nApp.vue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;VueHeader\u0026gt;\u0026lt;/VueHeader\u0026gt; \u0026lt;VueMain\u0026gt;\u0026lt;/VueMain\u0026gt; \u0026lt;VueFooter\u0026gt;\u0026lt;/VueFooter\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import VueHeader from \u0026#39;./VueHeader.vue\u0026#39;; import VueMain from \u0026#39;./VueMain.vue\u0026#39;; import VueFooter from \u0026#39;./VueFooter.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { VueHeader, VueMain, VueFooter } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; Header.vue组件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;NavBar\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Main.vue组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;vue-banner\u0026gt;\u0026lt;/vue-banner\u0026gt; \u0026lt;vue-product-list\u0026gt;\u0026lt;/vue-product-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import VueBanner from \u0026#39;./VueBanner.vue\u0026#39;; import VueProductList from \u0026#39;./VueProductList.vue\u0026#39;; export default { name: \u0026#39;VueMain\u0026#39;, components: { VueBanner, VueProductList } }; \u0026lt;/script\u0026gt; Banner.vue组件：\n\u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;Banner\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; ProductList组件：\n\u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;商品列表1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; Footer.vue组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Footer\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;免责声明\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。\n组件的通信 上面的嵌套逻辑如下，它们存在如下关系：\nApp组件是Header、Main、Footer组件的父组件； Main组件是Banner、ProductList组件的父组件； 在开发过程中，我们会经常遇到需要组件之间相互进行通信：\n比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示； 又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示； 也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件； 父子组件之间如何进行通信呢？\n父组件传递给子组件：通过props属性； 子组件传递给父组件：通过$emit触发事件； 父传子 在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：\n这个时候我们可以通过props来完成组件之间的通信； 什么是 props?\n在Vue3中，props是一种用于向组件传递数据的机制。它允许父组件向子组件传递数据，并在子组件中使用这些数据。\n在Vue3中，每个组件都可以定义自己的props，并指定每个prop的类型、默认值和其他验证规则。当父组件向子组件传递数据时，子组件可以使用这些props来访问传递过来的数据。\nprops 的定义 在Vue3中，props可以使用两种方式来定义：\n字符串数组，数组中的字符串就是attribute的名称； 对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等； 字符串数组 使用字符串数组的方式，可以简单地指定需要接收的属性名称。在这种情况下，属性类型默认为any。\n在下面的示例中，父组件使用message=\u0026quot;Hello from parent\u0026quot;将message属性作为字符串传递给子组件。在子组件中，使用props选项并传递一个字符串数组来定义message属性。这样子组件就可以使用message属性来访问父组件传递过来的数据了。\n\u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component message=\u0026#34;Hello from parent\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39; export default { components: { ChildComponent } } \u0026lt;/script\u0026gt; \u0026lt;!--ChildComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;message\u0026#39;] } \u0026lt;/script\u0026gt; 对象类型 使用对象类型的方式，可以更详细地指定需要接收的属性名称、类型、是否必须、默认值等等。\n在下面的示例中，父组件使用:message=\u0026quot;parentMessage\u0026quot;将parentMessage属性作为字符串传递给子组件。在子组件中，使用props选项并传递一个对象来定义message属性。在这个对象中，我们指定了type为字符串、required为true、default为\u0026rsquo;Hello from child\u0026rsquo;、以及一个自定义的验证函数。\n这样子组件就可以使用message属性来访问父组件传递过来的数据了。\n\u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component :message=\u0026#34;parentMessage\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39; export default { components: { ChildComponent }, data() { return { parentMessage: \u0026#39;Hello from parent\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;!--ChildComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { message: { type: String, // 必须传输? required: true, // 默认值 default: \u0026#39;Hello from child\u0026#39;, // 传递的数据是否符合要求? validator: (value) =\u0026gt; { return value.length \u0026gt; 0 }, info: String } } } \u0026lt;/script\u0026gt; 其他 Type的类型都可以是哪些？ String：用于指定字符串类型的属性。 Number：用于指定数字类型的属性。 Boolean：用于指定布尔类型的属性。 Array：用于指定数组类型的属性。 Object：用于指定对象类型的属性。 Date：用于指定日期类型的属性。 Function：用于指定函数类型的属性。 Symbol：用于指定符号类型的属性。 对象类型的其他写法 props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取, 因为每个实例需要维护一份被返回对象的独立的副本 default: function () { return { message: \u0026#39;hello\u0026#39; } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].indexOf(value) !== -1 } }, // 具有默认值的函数 propG: { type: Function, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: \u0026#39;hello\u0026#39; } } } } Prop 的大小写命名(camelCase vs kebab-case) 在Vue.js中，你可以使用驼峰式(camelCase)或短横线分隔(kebab-case)来命名你的props。然而，由于HTML属性不区分大小写，所以在模板中使用驼峰式命名的props时，需要转换为短横线分隔的形式。\n例如，如果你在JavaScript中定义了一个名为myProp的prop，你需要在模板中使用my-prop来引用它。\n这是一个例子：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 在模板中使用短横线分隔的形式 --\u0026gt; \u0026lt;child-component :my-prop=\u0026#34;parentValue\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, data() { return { parentValue: \u0026#39;Hello from Parent Component\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;!--ChildComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 使用prop的值 --\u0026gt; \u0026lt;h2\u0026gt;{{ myProp }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { // 在JavaScript中使用驼峰式命名 myProp: String } } \u0026lt;/script\u0026gt; 在这个例子中，父组件将其数据parentValue传递给子组件的myProp prop。注意在父组件模板中，我们使用短横线分隔的形式:my-prop，而在子组件的JavaScript代码中，我们使用驼峰式命名myProp, 这也是官方推荐的写法。\n非 Prop 的Attribute 在Vue.js中，非prop的attribute是指那些被绑定到组件，但没有对应的prop定义的attribute。这些attribute会被添加到组件的根元素上。\n例如，如果你有一个组件，它的模板是一个\u0026lt;div\u0026gt;元素，然后你在使用这个组件时添加了一个class或style属性，那么这个class或style属性就会被添加到\u0026lt;div\u0026gt;元素上，即使你没有在组件的props中定义它们。\n这是一个例子：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component id=\u0026#34;abc\u0026#34; class=\u0026#34;my-class\u0026#34; style=\u0026#34;color: red;\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MyComponent from \u0026#39;./MyComponent.vue\u0026#39;; export default { components: { MyComponent } } \u0026lt;/script\u0026gt; 在这个例子中，id, class和style就是非prop的attribute。它们会被添加到MyComponent的根元素上。\n禁用 Attribute 继承 如果你不希望非prop的attribute被添加到根元素上，你可以在组件中定义一个inheritAttrs: false选项。这样，非prop的attribute将只能通过$attrs变量来访问，而不会被添加到根元素上。\nexport default { inheritAttrs: false } 禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素； 我们可以通过 $attrs来访问所有的 非props的attribute； \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 v-bind=\u0026#34;$attrs\u0026#34;\u0026gt;{{title}}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{content}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 如上, \u0026lt;h2\u0026gt; 仍然会继承非prop的attribute 多个根节点的attribute 多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：\n\u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;$attrs.class\u0026#34;\u0026gt; 我是NotPropAttribue组件1 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 我是NotPropAttribue组件2 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 我是NotPropAttribue组件3 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 子传父 什么情况下子组件需要传递内容到父组件呢？\n当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容； 子组件有一些内容想要传递给父组件的时候； 我们如何完成上面的操作呢？\n首先，我们需要在子组件中定义好在某些情况下触发的事件名称； 其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中； 最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件； 以下是一个简单的示例\n\u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendDataToParent\u0026#34;\u0026gt;传递数据给父组件\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendDataToParent() { const data = \u0026#39;Hello, parent!\u0026#39;; // 传递参数给父组件 this.$emit(\u0026#39;data-to-parent\u0026#39;, data); } } }; \u0026lt;/script\u0026gt; \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component @data-to-parent=\u0026#34;handleDataFromChild\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, methods: { handleDataFromChild(data) { console.log(data); // 在控制台打印子组件传递的数据 // 在这里处理从子组件接收到的数据 } } }; \u0026lt;/script\u0026gt; emits 当使用Vue 3时，你可以使用emits选项来对子组件触发的自定义事件进行校验: 使用emits选项可以提供类型检查和错误提示，确保子组件只触发被允许的自定义事件。这有助于提高代码的可维护性和可靠性。以下是一个示例：\nexport default { // 一般写法 emits: [\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;, \u0026#34;addN\u0026#34;], // 对象写法的目的是为了进行参数的验证 emits: { add: null, sub: null, addN: (num, name, age) =\u0026gt; { console.log(num, name, age); if (num \u0026gt; 10) { return true } return false; } } } 非父子组件之间的通信 在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。\n这里我们主要讲两种方式：\nProvide/Inject Mitt全局事件总线； Provide/Inject Provide/Inject用于非父子组件之间共享数据：\n比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容； 在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦； 对于这种情况下，我们可以使用 Provide 和 Inject ：\n无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者； 父组件有一个 provide 选项来提供数据； 子组件有一个 inject 选项来开始使用这些数据； 实际上，你可以将依赖注入看作是“long range props”，除了：\n父组件不需要知道哪些子组件使用它 provide的 property 子组件不需要知道 inject的 property来自哪里 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, provide() { return { message: \u0026#39;Hello from the parent component\u0026#39; }; } }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { inject: [\u0026#39;message\u0026#39;] }; \u0026lt;/script\u0026gt; 当然, 我们也可以通过 this 获取到当前组件定义的 data import VueHome from \u0026#39;./VueHome.vue\u0026#39;; import { computed } from \u0026#39;vue\u0026#39;; export default { components: { VueHome }, provide() { return { name: \u0026#34;why\u0026#34;, age: 18, length: computed(() =\u0026gt; this.names.length) // ref对象 .value } }, data() { return { names: [\u0026#34;abc\u0026#34;, \u0026#34;cba\u0026#34;, \u0026#34;nba\u0026#34;] } }, methods: { addName() { this.names.push(\u0026#34;why\u0026#34;); console.log(this.names); } } } 全局事件总线 mitt 库 在 Vue 3 中，全局事件总线是一种用于在不同组件之间进行通信的机制。它允许你在任何组件中触发事件并在其他组件中监听和响应这些事件。\nhttps://cn.vuejs.org/api/application.html#app-config-globalproperties\n在 Vue 3 中，可以使用 app.config.globalProperties 来创建一个全局事件总线。通过将事件总线实例添加到全局属性中，你可以在任何组件中访问它，从而实现跨组件的事件通信。\n以下是一个示例：\n// 在 main.js 中创建全局事件总线 import { createApp } from \u0026#39;vue\u0026#39;; const app = createApp(App); app.config.globalProperties.$bus = createEventBus(); app.mount(\u0026#39;#app\u0026#39;); 创建一个名为 createEventBus 的函数来创建事件总线实例：\nfunction createEventBus() { const listeners = {}; function on(event, callback) { if (!listeners[event]) { listeners[event] = []; } listeners[event].push(callback); } function emit(event, ...args) { if (listeners[event]) { listeners[event].forEach(callback =\u0026gt; { callback(...args); }); } } return { on, emit }; } 现在，你可以在任何组件中使用 $bus来触发事件和监听事件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;发送消息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$bus.emit(\u0026#39;message\u0026#39;, \u0026#39;Hello from component A\u0026#39;); } } }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;发送消息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$bus.emit(\u0026#39;message\u0026#39;, \u0026#39;Hello from component A\u0026#39;); } } }; \u0026lt;/script\u0026gt; 在上述示例中，当点击按钮时，组件 A 使用$bus.emit 发送了一个名为 'message' 的事件，并传递了消息 'Hello from component A'。组件 B 使用 ​$bus.on 监听了 'message'事件，并将接收到的消息显示在页面上。\n通过全局事件总线，你可以在不同组件之间进行简单而方便的通信，而无需显式地通过 props 或其他方式传递数据。 [TOC]\n认识组件的嵌套 在之前的案例中，我们只是创建了一个组件App； 如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护； 所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件； 再将这些组件组合嵌套在一起，最终形成我们的应用程序； 我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;NavBar\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Banner\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;商品列表1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Footer\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;免责声明\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。\n所有，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。\n组件的拆分 如上代码, 我们可以按照如下的方式进行拆分：\nApp.vue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;VueHeader\u0026gt;\u0026lt;/VueHeader\u0026gt; \u0026lt;VueMain\u0026gt;\u0026lt;/VueMain\u0026gt; \u0026lt;VueFooter\u0026gt;\u0026lt;/VueFooter\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import VueHeader from \u0026#39;./VueHeader.vue\u0026#39;; import VueMain from \u0026#39;./VueMain.vue\u0026#39;; import VueFooter from \u0026#39;./VueFooter.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { VueHeader, VueMain, VueFooter } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; Header.vue组件\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Header\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;NavBar\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Main.vue组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;vue-banner\u0026gt;\u0026lt;/vue-banner\u0026gt; \u0026lt;vue-product-list\u0026gt;\u0026lt;/vue-product-list\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import VueBanner from \u0026#39;./VueBanner.vue\u0026#39;; import VueProductList from \u0026#39;./VueProductList.vue\u0026#39;; export default { name: \u0026#39;VueMain\u0026#39;, components: { VueBanner, VueProductList } }; \u0026lt;/script\u0026gt; Banner.vue组件：\n\u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;Banner\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; ProductList组件：\n\u0026lt;template\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;商品列表1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表4\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;商品列表5\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; Footer.vue组件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;Footer\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;免责声明\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。\n组件的通信 上面的嵌套逻辑如下，它们存在如下关系：\nApp组件是Header、Main、Footer组件的父组件； Main组件是Banner、ProductList组件的父组件； 在开发过程中，我们会经常遇到需要组件之间相互进行通信：\n比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示； 又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给他们来进行展示； 也可能是子组件中发生了事件，需要有父组件来完成某些操作，那就需要子组件向父组件传递事件； 父子组件之间如何进行通信呢？\n父组件传递给子组件：通过props属性； 子组件传递给父组件：通过$emit触发事件； 父传子 在开发中很常见的就是父子组件之间通信，比如父组件有一些数据，需要子组件来进行展示：\n这个时候我们可以通过props来完成组件之间的通信； 什么是 props?\n在Vue3中，props是一种用于向组件传递数据的机制。它允许父组件向子组件传递数据，并在子组件中使用这些数据。\n在Vue3中，每个组件都可以定义自己的props，并指定每个prop的类型、默认值和其他验证规则。当父组件向子组件传递数据时，子组件可以使用这些props来访问传递过来的数据。\nprops 的定义 在Vue3中，props可以使用两种方式来定义：\n字符串数组，数组中的字符串就是attribute的名称； 对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等； 字符串数组 使用字符串数组的方式，可以简单地指定需要接收的属性名称。在这种情况下，属性类型默认为any。\n在下面的示例中，父组件使用message=\u0026quot;Hello from parent\u0026quot;将message属性作为字符串传递给子组件。在子组件中，使用props选项并传递一个字符串数组来定义message属性。这样子组件就可以使用message属性来访问父组件传递过来的数据了。\n\u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component message=\u0026#34;Hello from parent\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39; export default { components: { ChildComponent } } \u0026lt;/script\u0026gt; \u0026lt;!--ChildComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;message\u0026#39;] } \u0026lt;/script\u0026gt; 对象类型 使用对象类型的方式，可以更详细地指定需要接收的属性名称、类型、是否必须、默认值等等。\n在下面的示例中，父组件使用:message=\u0026quot;parentMessage\u0026quot;将parentMessage属性作为字符串传递给子组件。在子组件中，使用props选项并传递一个对象来定义message属性。在这个对象中，我们指定了type为字符串、required为true、default为\u0026rsquo;Hello from child\u0026rsquo;、以及一个自定义的验证函数。\n这样子组件就可以使用message属性来访问父组件传递过来的数据了。\n\u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component :message=\u0026#34;parentMessage\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39; export default { components: { ChildComponent }, data() { return { parentMessage: \u0026#39;Hello from parent\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;!--ChildComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { message: { type: String, // 必须传输? required: true, // 默认值 default: \u0026#39;Hello from child\u0026#39;, // 传递的数据是否符合要求? validator: (value) =\u0026gt; { return value.length \u0026gt; 0 }, info: String } } } \u0026lt;/script\u0026gt; 其他 Type的类型都可以是哪些？ String：用于指定字符串类型的属性。 Number：用于指定数字类型的属性。 Boolean：用于指定布尔类型的属性。 Array：用于指定数组类型的属性。 Object：用于指定对象类型的属性。 Date：用于指定日期类型的属性。 Function：用于指定函数类型的属性。 Symbol：用于指定符号类型的属性。 对象类型的其他写法 props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取, 因为每个实例需要维护一份被返回对象的独立的副本 default: function () { return { message: \u0026#39;hello\u0026#39; } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].indexOf(value) !== -1 } }, // 具有默认值的函数 propG: { type: Function, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: \u0026#39;hello\u0026#39; } } } } Prop 的大小写命名(camelCase vs kebab-case) 在Vue.js中，你可以使用驼峰式(camelCase)或短横线分隔(kebab-case)来命名你的props。然而，由于HTML属性不区分大小写，所以在模板中使用驼峰式命名的props时，需要转换为短横线分隔的形式。\n例如，如果你在JavaScript中定义了一个名为myProp的prop，你需要在模板中使用my-prop来引用它。\n这是一个例子：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 在模板中使用短横线分隔的形式 --\u0026gt; \u0026lt;child-component :my-prop=\u0026#34;parentValue\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, data() { return { parentValue: \u0026#39;Hello from Parent Component\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;!--ChildComponent.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 使用prop的值 --\u0026gt; \u0026lt;h2\u0026gt;{{ myProp }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: { // 在JavaScript中使用驼峰式命名 myProp: String } } \u0026lt;/script\u0026gt; 在这个例子中，父组件将其数据parentValue传递给子组件的myProp prop。注意在父组件模板中，我们使用短横线分隔的形式:my-prop，而在子组件的JavaScript代码中，我们使用驼峰式命名myProp, 这也是官方推荐的写法。\n非 Prop 的Attribute 在Vue.js中，非prop的attribute是指那些被绑定到组件，但没有对应的prop定义的attribute。这些attribute会被添加到组件的根元素上。\n例如，如果你有一个组件，它的模板是一个\u0026lt;div\u0026gt;元素，然后你在使用这个组件时添加了一个class或style属性，那么这个class或style属性就会被添加到\u0026lt;div\u0026gt;元素上，即使你没有在组件的props中定义它们。\n这是一个例子：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-component id=\u0026#34;abc\u0026#34; class=\u0026#34;my-class\u0026#34; style=\u0026#34;color: red;\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MyComponent from \u0026#39;./MyComponent.vue\u0026#39;; export default { components: { MyComponent } } \u0026lt;/script\u0026gt; 在这个例子中，id, class和style就是非prop的attribute。它们会被添加到MyComponent的根元素上。\n禁用 Attribute 继承 如果你不希望非prop的attribute被添加到根元素上，你可以在组件中定义一个inheritAttrs: false选项。这样，非prop的attribute将只能通过$attrs变量来访问，而不会被添加到根元素上。\nexport default { inheritAttrs: false } 禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素； 我们可以通过 $attrs来访问所有的 非props的attribute； \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 v-bind=\u0026#34;$attrs\u0026#34;\u0026gt;{{title}}\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;{{content}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 如上, \u0026lt;h2\u0026gt; 仍然会继承非prop的attribute 多个根节点的attribute 多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：\n\u0026lt;template\u0026gt; \u0026lt;div :class=\u0026#34;$attrs.class\u0026#34;\u0026gt; 我是NotPropAttribue组件1 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 我是NotPropAttribue组件2 \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; 我是NotPropAttribue组件3 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 子传父 什么情况下子组件需要传递内容到父组件呢？\n当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容； 子组件有一些内容想要传递给父组件的时候； 我们如何完成上面的操作呢？\n首先，我们需要在子组件中定义好在某些情况下触发的事件名称； 其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中； 最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件； 以下是一个简单的示例\n\u0026lt;!-- 子组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;sendDataToParent\u0026#34;\u0026gt;传递数据给父组件\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendDataToParent() { const data = \u0026#39;Hello, parent!\u0026#39;; // 传递参数给父组件 this.$emit(\u0026#39;data-to-parent\u0026#39;, data); } } }; \u0026lt;/script\u0026gt; \u0026lt;!-- 父组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component @data-to-parent=\u0026#34;handleDataFromChild\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, methods: { handleDataFromChild(data) { console.log(data); // 在控制台打印子组件传递的数据 // 在这里处理从子组件接收到的数据 } } }; \u0026lt;/script\u0026gt; emits 当使用Vue 3时，你可以使用emits选项来对子组件触发的自定义事件进行校验: 使用emits选项可以提供类型检查和错误提示，确保子组件只触发被允许的自定义事件。这有助于提高代码的可维护性和可靠性。以下是一个示例：\nexport default { // 一般写法 emits: [\u0026#34;add\u0026#34;, \u0026#34;sub\u0026#34;, \u0026#34;addN\u0026#34;], // 对象写法的目的是为了进行参数的验证 emits: { add: null, sub: null, addN: (num, name, age) =\u0026gt; { console.log(num, name, age); if (num \u0026gt; 10) { return true } return false; } } } 动态组件 Vue.js 的动态组件是指可以根据不同的数据渲染不同的组件的功能。你可以使用 Vue.js 的 \u0026lt;component\u0026gt;元素来实现动态组件。\n例如，你可以在父组件中定义一个数据属性，根据这个属性的值来决定渲染哪个子组件。然后，在模板中使用 \u0026lt;component\u0026gt;元素，并将该数据属性绑定到 is 属性上，这样就可以动态地渲染不同的子组件了。\n\u0026lt;script\u0026gt; import Home from \u0026#39;./Home.vue\u0026#39; import Posts from \u0026#39;./Posts.vue\u0026#39; import Archive from \u0026#39;./Archive.vue\u0026#39; export default { components: { Home, Posts, Archive }, data() { return { currentTab: \u0026#39;Home\u0026#39;, tabs: [\u0026#39;Home\u0026#39;, \u0026#39;Posts\u0026#39;, \u0026#39;Archive\u0026#39;] } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;button v-for=\u0026#34;tab in tabs\u0026#34; :key=\u0026#34;tab\u0026#34; :class=\u0026#34;[\u0026#39;tab-button\u0026#39;, { active: currentTab === tab }]\u0026#34; @click=\u0026#34;currentTab = tab\u0026#34; \u0026gt; {{ tab }} \u0026lt;/button\u0026gt; \u0026lt;component :is=\u0026#34;currentTab\u0026#34; class=\u0026#34;tab\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 非父子组件之间的通信 在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信。\n这里我们主要讲两种方式：\nProvide/Inject Mitt全局事件总线； Provide/Inject Provide/Inject用于非父子组件之间共享数据：\n比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容； 在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常的麻烦； 对于这种情况下，我们可以使用 Provide 和 Inject ：\n无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者； 父组件有一个 provide 选项来提供数据； 子组件有一个 inject 选项来开始使用这些数据； 实际上，你可以将依赖注入看作是“long range props”，除了：\n父组件不需要知道哪些子组件使用它 provide的 property 子组件不需要知道 inject的 property来自哪里 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;child-component\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ChildComponent from \u0026#39;./ChildComponent.vue\u0026#39;; export default { components: { ChildComponent }, provide() { return { message: \u0026#39;Hello from the parent component\u0026#39; }; } }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { inject: [\u0026#39;message\u0026#39;] }; \u0026lt;/script\u0026gt; 当然, 我们也可以通过 this 获取到当前组件定义的 data import VueHome from \u0026#39;./VueHome.vue\u0026#39;; import { computed } from \u0026#39;vue\u0026#39;; export default { components: { VueHome }, provide() { return { name: \u0026#34;why\u0026#34;, age: 18, length: computed(() =\u0026gt; this.names.length) // ref对象 .value } }, data() { return { names: [\u0026#34;abc\u0026#34;, \u0026#34;cba\u0026#34;, \u0026#34;nba\u0026#34;] } }, methods: { addName() { this.names.push(\u0026#34;why\u0026#34;); console.log(this.names); } } } 全局事件总线 mitt 库 在 Vue 3 中，全局事件总线是一种用于在不同组件之间进行通信的机制。它允许你在任何组件中触发事件并在其他组件中监听和响应这些事件。\nhttps://cn.vuejs.org/api/application.html#app-config-globalproperties\n在 Vue 3 中，可以使用 app.config.globalProperties 来创建一个全局事件总线。通过将事件总线实例添加到全局属性中，你可以在任何组件中访问它，从而实现跨组件的事件通信。\n以下是一个示例：\n// 在 main.js 中创建全局事件总线 import { createApp } from \u0026#39;vue\u0026#39;; const app = createApp(App); app.config.globalProperties.$bus = createEventBus(); app.mount(\u0026#39;#app\u0026#39;); 创建一个名为 createEventBus 的函数来创建事件总线实例：\nfunction createEventBus() { const listeners = {}; function on(event, callback) { if (!listeners[event]) { listeners[event] = []; } listeners[event].push(callback); } function emit(event, ...args) { if (listeners[event]) { listeners[event].forEach(callback =\u0026gt; { callback(...args); }); } } return { on, emit }; } 现在，你可以在任何组件中使用 $bus来触发事件和监听事件：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;发送消息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$bus.emit(\u0026#39;message\u0026#39;, \u0026#39;Hello from component A\u0026#39;); } } }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;sendMessage\u0026#34;\u0026gt;发送消息\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { sendMessage() { this.$bus.emit(\u0026#39;message\u0026#39;, \u0026#39;Hello from component A\u0026#39;); } } }; \u0026lt;/script\u0026gt; 在上述示例中，当点击按钮时，组件 A 使用$bus.emit 发送了一个名为 'message' 的事件，并传递了消息 'Hello from component A'。组件 B 使用 ​$bus.on 监听了 'message'事件，并将接收到的消息显示在页面上。\n通过全局事件总线，你可以在不同组件之间进行简单而方便的通信，而无需显式地通过 props 或其他方式传递数据。\n插槽 https://cn.vuejs.org/guide/components/slots.html#slots\n认识组件 Slot 在开发中，我们会经常封装一个个可复用的组件： 前面我们会通过props传递给组件一些数据，让组件来进行展示； 但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素； 比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片； 我们应该让使用者可以决定某一块区域到底存放什么内容和元素； 举个栗子：假如我们定制一个通用的导航组件 - NavBar 这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定； 左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示； 中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等； 右边可能是一个文字，也可能是一个图标，也可能什么都不显示； 如何使用插槽slot？ 这个时候我们就可以来定义插槽slot： 插槽的使用过程其实是抽取共性、预留不同； 我们会将共同的元素、内容依然在组件内进行封装； 同时会将不同的元素使用 slot 作为占位，让外部决定到底显示什么样的元素； 如何使用slot呢？ Vue中将 元素作为承载分发内容的出口； 在封装组件中，使用特殊的元素就可以为封装组件开启一个插槽； 该插槽插入什么内容取决于父组件如何使用； 插槽的基本使用 \u0026lt;script\u0026gt; import FancyButton from \u0026#39;./FancyButton.vue\u0026#39; export default { components: { FancyButton } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;FancyButton\u0026gt; Click me \u0026lt;!-- slot content --\u0026gt; \u0026lt;/FancyButton\u0026gt; \u0026lt;FancyButton\u0026gt; \u0026lt;/FancyButton\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button class=\u0026#34;fancy-btn\u0026#34;\u0026gt; \u0026lt;slot\u0026gt; Hello \u0026lt;/slot\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; .fancy-btn { color: #fff; background: linear-gradient(315deg, #42d392 25%, #647eff); border: none; padding: 5px 10px; margin: 5px; border-radius: 8px; cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;slot\u0026gt; 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。\n通过使用插槽，\u0026lt;FancyButton\u0026gt; 仅负责渲染外层的 \u0026lt;button\u0026gt; (以及相应的样式)，而其内部的内容由父组件提供。\n理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的：\n// 父元素传入插槽内容 FancyButton(\u0026#39;Click me!\u0026#39;) // FancyButton 在自己的模板中渲染插槽内容 function FancyButton(slotContent) { return `\u0026lt;button class=\u0026#34;fancy-btn\u0026#34;\u0026gt; ${slotContent} \u0026lt;/button\u0026gt;` } 插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：\n\u0026lt;FancyButton\u0026gt; \u0026lt;span style=\u0026#34;color:red\u0026#34;\u0026gt;Click me!\u0026lt;/span\u0026gt; \u0026lt;AwesomeIcon name=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;/FancyButton\u0026gt; 插槽的默认内容 在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 \u0026lt;SubmitButton\u0026gt; 组件：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/button\u0026gt; 如果我们想在父组件没有提供任何插槽内容时在 \u0026lt;button\u0026gt; 内渲染“Submit”，只需要将“Submit”写在 \u0026lt;slot\u0026gt; 标签之间来作为默认内容：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;slot\u0026gt; Submit \u0026lt;!-- 默认内容 --\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;/button\u0026gt; 现在，当我们在父组件中使用 \u0026lt;SubmitButton\u0026gt; 且没有提供任何插槽内容时：\n\u0026lt;SubmitButton /\u0026gt; “Submit”将会被作为默认内容渲染：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; 但如果我们提供了插槽内容：\n\u0026lt;SubmitButton\u0026gt;Save\u0026lt;/SubmitButton\u0026gt; 那么被显式提供的内容会取代默认内容：\n\u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Save\u0026lt;/button\u0026gt; 多个插槽的效果 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;my-slot-cpn\u0026gt; \u0026lt;button\u0026gt;我是按钮\u0026lt;/button\u0026gt; \u0026lt;/my-slot-cpn\u0026gt; \u0026lt;my-slot-cpn\u0026gt; 我是普通的文本 \u0026lt;/my-slot-cpn\u0026gt; \u0026lt;my-slot-cpn\u0026gt;\u0026lt;/my-slot-cpn\u0026gt; \u0026lt;my-slot-cpn\u0026gt; \u0026lt;h2\u0026gt;哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;button\u0026gt;我是按钮\u0026lt;/button\u0026gt; \u0026lt;strong\u0026gt;我是strong\u0026lt;/strong\u0026gt; \u0026lt;/my-slot-cpn\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import MySlotCpn from \u0026#39;./MySlotCpn.vue\u0026#39;; export default { components: { MySlotCpn, } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;组件开始\u0026lt;/h2\u0026gt; \u0026lt;slot\u0026gt; \u0026lt;i\u0026gt;我是默认的i元素\u0026lt;/i\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;slot\u0026gt; \u0026lt;i\u0026gt;我是默认的i元素\u0026lt;/i\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;slot\u0026gt; \u0026lt;i\u0026gt;我是默认的i元素\u0026lt;/i\u0026gt; \u0026lt;/slot\u0026gt; \u0026lt;h2\u0026gt;组件结束\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 具名插槽的使用 有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 \u0026lt;BaseLayout\u0026gt; 组件中，有如下模板：\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- 标题内容放这里 --\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;!-- 主要内容放这里 --\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;!-- 底部内容放这里 --\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; 对于这种场景，\u0026lt;slot\u0026gt; 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; 这类带 name 的插槽被称为具名插槽 (named slots)。没有提供 name 的 \u0026lt;slot\u0026gt; 出口会隐式地命名为“default”。\n在父组件中使用 \u0026lt;BaseLayout\u0026gt; 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到具名插槽了：\n要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 \u0026lt;template\u0026gt; 元素，并将目标插槽的名字传给该指令：\n\u0026lt;BaseLayout\u0026gt; \u0026lt;template v-slot:header\u0026gt; \u0026lt;!-- header 插槽的内容放这里 --\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/BaseLayout\u0026gt; v-slot 有对应的简写 #，因此 \u0026lt;template v-slot:header\u0026gt; 可以简写为 \u0026lt;template #header\u0026gt;。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。\n\u0026lt;script\u0026gt; import BaseLayout from \u0026#39;./BaseLayout.vue\u0026#39; export default { components: { BaseLayout } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;BaseLayout\u0026gt; \u0026lt;template #header\u0026gt; \u0026lt;h1\u0026gt;Here might be a page title\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;p\u0026gt;A paragraph for the main content.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;And another one.\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #footer\u0026gt; \u0026lt;p\u0026gt;Here\u0026#39;s some contact info\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/BaseLayout\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style\u0026gt; footer { border-top: 1px solid #ccc; color: #666; font-size: 0.8em; } \u0026lt;/style\u0026gt; 使用 JavaScript 函数来类比可能更有助于你来理解具名插槽：\n// 传入不同的内容给不同名字的插槽 BaseLayout({ header: `...`, default: `...`, footer: `...` }) // \u0026lt;BaseLayout\u0026gt; 渲染插槽内容到对应位置 function BaseLayout(slots) { return `\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt;${slots.header}\u0026lt;/header\u0026gt; \u0026lt;main\u0026gt;${slots.default}\u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt;${slots.footer}\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt;` } 动态插槽名 在Vue 3中，动态插槽名可以使用v-slot指令来实现。你可以将插槽名作为一个变量来传递给v-slot指令，以实现动态插槽名的效果。\n例如，如果你有一个动态的插槽名变量slotName，你可以这样使用动态插槽名：\n\u0026lt;template v-slot:[slotName]\u0026gt; \u0026lt;!-- 插槽内容 --\u0026gt; \u0026lt;/template\u0026gt; 这样，slotName变量的值将作为插槽名来动态指定插槽的位置。\n渲染作用域 插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：\n\u0026lt;span\u0026gt;{{ message }}\u0026lt;/span\u0026gt; \u0026lt;FancyButton\u0026gt;{{ message }}\u0026lt;/FancyButton\u0026gt; 这里的两个 {{ message }} 插值表达式渲染的内容都是一样的。\n插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：\n父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。\n作用域插槽 然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。\n我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：\n\u0026lt;script\u0026gt; export default { data() { return { greetingMessage: \u0026#39;hello\u0026#39; } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot :text=\u0026#34;greetingMessage\u0026#34; :count=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象：\n\u0026lt;script\u0026gt; import MyComponent from \u0026#39;./MyComponent.vue\u0026#39; export default { components: { MyComponent } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;MyComponent v-slot=\u0026#34;slotProps\u0026#34;\u0026gt; {{ slotProps.text }} {{ slotProps.count }} \u0026lt;/MyComponent\u0026gt; \u0026lt;/template\u0026gt; 子组件传入插槽的 props 作为了 v-slot 指令的值，可以在插槽内的表达式中访问。\n你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\nMyComponent({ // 类比默认插槽，将其想成一个函数 default: (slotProps) =\u0026gt; { return `${slotProps.text} ${slotProps.count}` } }) function MyComponent(slots) { const greetingMessage = \u0026#39;hello\u0026#39; return `\u0026lt;div\u0026gt;${ // 在插槽函数调用时传入 props slots.default({ text: greetingMessage, count: 1 }) }\u0026lt;/div\u0026gt;` } 实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写渲染函数时使用作用域插槽的方式非常类似了。\nv-slot=\u0026quot;slotProps\u0026quot; 可以类比这里的函数签名，和函数的参数类似，我们也可以在 v-slot 中使用解构：\n\u0026lt;MyComponent v-slot=\u0026#34;{ text, count }\u0026#34;\u0026gt; {{ text }} {{ count }} \u0026lt;/MyComponent\u0026gt; 具名作用域插槽 具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name=\u0026quot;slotProps\u0026quot;。\n\u0026lt;script\u0026gt; import MyComponent from \u0026#39;./MyComponent.vue\u0026#39; export default { components: { MyComponent } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;MyComponent\u0026gt; \u0026lt;template #header=\u0026#34;slotProps\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{ slotProps.title }}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template #content=\u0026#34;slotProps\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ slotProps.text }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/MyComponent\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34; :title=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;content\u0026#34; :text=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { title: \u0026#39;Hello\u0026#39;, content: \u0026#39;This is the content\u0026#39; }; } }; \u0026lt;/script\u0026gt; 独占默认插槽的缩写 如果我们的插槽是默认插槽default，那么在使用的时候 v-slot:default=\u0026quot;slotProps\u0026quot;可以简写为v-slot=“slotProps” 并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 v-slot 直接用在组件上 默认插槽和具名插槽混合 但是，如果我们有默认插槽和具名插槽，那么按照完整的template来编写。 只要出现多个插槽，请始终为所有的插槽使用完整的基于 动态组件 切换组件案例 比如我们现在想要实现了一个功能：\n点击一个tab-bar，切换不同的组件显示； 这个案例我们可以通过两种不同的实现思路来实现：\n方式一：通过v-if来判断，显示不同的组件； 方式二：动态组件的方式； v-if显示不同的组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-for=\u0026#34;item in tabs\u0026#34; :key=\u0026#34;item\u0026#34; @click=\u0026#34;itemClick(item)\u0026#34; :class=\u0026#34;{ active: currentTab === item }\u0026#34;\u0026gt; {{ item }} \u0026lt;/button\u0026gt; \u0026lt;!-- 1.v-if的判断实现 --\u0026gt; \u0026lt;template v-if=\u0026#34;currentTab === \u0026#39;home\u0026#39;\u0026#34;\u0026gt; \u0026lt;home\u0026gt;\u0026lt;/home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else-if=\u0026#34;currentTab === \u0026#39;about\u0026#39;\u0026#34;\u0026gt; \u0026lt;about\u0026gt;\u0026lt;/about\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;category\u0026gt;\u0026lt;/category\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 动态组件 Vue.js 的动态组件是指可以根据不同的数据渲染不同的组件的功能。你可以使用 Vue.js 的 \u0026lt;component\u0026gt;元素来实现动态组件。\n例如，你可以在父组件中定义一个数据属性，根据这个属性的值来决定渲染哪个子组件。然后，在模板中使用 \u0026lt;component\u0026gt;元素，并将该数据属性绑定到 is 属性上，这样就可以动态地渲染不同的子组件了。\n\u0026lt;script\u0026gt; import Home from \u0026#39;./Home.vue\u0026#39; import Posts from \u0026#39;./Posts.vue\u0026#39; import Archive from \u0026#39;./Archive.vue\u0026#39; export default { components: { Home, Posts, Archive }, data() { return { currentTab: \u0026#39;Home\u0026#39;, tabs: [\u0026#39;Home\u0026#39;, \u0026#39;Posts\u0026#39;, \u0026#39;Archive\u0026#39;] } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;button v-for=\u0026#34;tab in tabs\u0026#34; :key=\u0026#34;tab\u0026#34; :class=\u0026#34;[\u0026#39;tab-button\u0026#39;, { active: currentTab === tab }]\u0026#34; @click=\u0026#34;currentTab = tab\u0026#34; \u0026gt; {{ tab }} \u0026lt;/button\u0026gt; \u0026lt;component :is=\u0026#34;currentTab\u0026#34; class=\u0026#34;tab\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 动态组件的传值 \u0026lt;component :is=\u0026#34;currentTab\u0026#34; name=\u0026#34;coderwhy\u0026#34; :age=\u0026#34;18\u0026#34; @pageClick=\u0026#34;pageClick\u0026#34;\u0026gt; \u0026lt;/component\u0026gt; pageClick() { console.log(\u0026#34;page内部发生了点击\u0026#34;); } export default { name: \u0026#34;home\u0026#34;, props: { name: { type: String, default: \u0026#34;\u0026#34; }, age: { type: Number, default: 0 } } } keep-alive https://cn.vuejs.org/guide/built-ins/keep-alive.html#keepalive\n\u0026lt;KeepAlive\u0026gt; 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。\n默认情况下，一个组件实例在被替换掉后会被销毁。这会导致它丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例。\n在切换时创建新的组件实例通常是有意义的，但在这个例子中，我们的确想要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 \u0026lt;KeepAlive\u0026gt; 内置组件将这些动态组件包装起来：\n\u0026lt;!-- 非活跃的组件将会被缓存！ --\u0026gt; \u0026lt;KeepAlive\u0026gt; \u0026lt;component :is=\u0026#34;activeComponent\u0026#34; /\u0026gt; \u0026lt;/KeepAlive\u0026gt; 在 DOM 内模板中使用时，它应该被写为 \u0026lt;keep-alive\u0026gt;。\n包含/排除 \u0026lt;KeepAlive\u0026gt; 默认会缓存内部的所有组件实例，但我们可以通过 include 和 exclude prop 来定制该行为。这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：\n\u0026lt;!-- 以英文逗号分隔的字符串 --\u0026gt; \u0026lt;KeepAlive include=\u0026#34;a,b\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;view\u0026#34; /\u0026gt; \u0026lt;/KeepAlive\u0026gt; \u0026lt;!-- 正则表达式 (需使用 `v-bind`) --\u0026gt; \u0026lt;KeepAlive :include=\u0026#34;/a|b/\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;view\u0026#34; /\u0026gt; \u0026lt;/KeepAlive\u0026gt; \u0026lt;!-- 数组 (需使用 `v-bind`) --\u0026gt; \u0026lt;KeepAlive :include=\u0026#34;[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;view\u0026#34; /\u0026gt; \u0026lt;/KeepAlive\u0026gt; 它会根据组件的 name 选项进行匹配，所以组件如果想要条件性地被 KeepAlive 缓存，就必须显式声明一个 name 选项。\n最大缓存实例数 我们可以通过传入 max prop 来限制可被缓存的最大组件实例数。\u0026lt;KeepAlive\u0026gt; 的行为在指定了 max 后类似一个 LRU 缓存：如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。\n\u0026lt;KeepAlive :max=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;component :is=\u0026#34;activeComponent\u0026#34; /\u0026gt; \u0026lt;/KeepAlive\u0026gt; 异步组件 https://cn.vuejs.org/guide/components/async.html#async-components\n基本用法 在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能：\nimport { defineAsyncComponent } from \u0026#39;vue\u0026#39; const AsyncComp = defineAsyncComponent(() =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // ...从服务器获取组件 resolve(/* 获取到的组件 */) }) }) // ... 像使用其他一般组件一样使用 `AsyncComp` 如你所见，defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。\nES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：\nimport { defineAsyncComponent } from \u0026#39;vue\u0026#39; const AsyncComp = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./components/MyComponent.vue\u0026#39;) ) 最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。\ndefineAsyncComponent接受两种类型的参数：\n类型一：工厂函数，该工厂函数需要返回一个Promise对象； import { defineAsyncComponent } from \u0026#39;vue\u0026#39;; const AsyncCategory = defineAsyncComponent(() =\u0026gt; import(\u0026#34;./AsyncCategory.vue\u0026#34;)) export default { components: { Home, AsyncCategory, Loading } } 类型二：接受一个对象类型，对异步函数进行配置； 异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态： const AsyncCategory = defineAsyncComponent({ loader: () =\u0026gt; import(\u0026#34;./AsyncCategory.vue\u0026#34;), loadingComponent: Loading, // errorComponent, // 在显示loadingComponent组件之前, 等待多长时间 delay: 2000, // 加载失败后展示的组件 errorComponent: ErrorComponent, // 如果提供了一个 timeout 时间限制，并超时了 // 也会显示这里配置的报错组件，默认值是：Infinity timeout: 3000 }) function defineAsyncComponent( source: AsyncComponentLoader | AsyncComponentOptions ): Component type AsyncComponentLoader = () =\u0026gt; Promise\u0026lt;Component\u0026gt; interface AsyncComponentOptions { loader: AsyncComponentLoader loadingComponent?: Component errorComponent?: Component delay?: number timeout?: number suspensible?: boolean onError?: ( error: Error, retry: () =\u0026gt; void, fail: () =\u0026gt; void, attempts: number ) =\u0026gt; any } 如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。 如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。 搭配 Suspense 使用 https://cn.vuejs.org/guide/built-ins/suspense.html\n\u0026lt;Suspense\u0026gt; 是一项实验性功能。它不一定会最终成为稳定功能，并且在稳定之前相关 API 也可能会发生变化。\n\u0026lt;Suspense\u0026gt; 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。\n\u0026lt;Suspense\u0026gt; 组件有两个插槽：#default 和 #fallback。两个插槽都只允许一个直接子节点。在可能的时候都将显示默认槽中的节点。否则将显示后备槽中的节点。\n\u0026lt;suspense\u0026gt; \u0026lt;!-- 具有深层异步依赖的组件 --\u0026gt; \u0026lt;template #default\u0026gt; \u0026lt;async-category\u0026gt;\u0026lt;/async-category\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 在 #fallback 插槽中显示 “正在加载中” --\u0026gt; \u0026lt;template #fallback\u0026gt; \u0026lt;loading\u0026gt;\u0026lt;/loading\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/suspense\u0026gt; 在初始渲染时，\u0026lt;Suspense\u0026gt; 将在内存中渲染其默认的插槽内容。如果在这个过程中遇到任何异步依赖，则会进入挂起状态。在挂起状态期间，展示的是后备内容。当所有遇到的异步依赖都完成后，\u0026lt;Suspense\u0026gt; 会进入完成状态，并将展示出默认插槽的内容。\n如果在初次渲染时没有遇到异步依赖，\u0026lt;Suspense\u0026gt; 会直接进入完成状态。\n进入完成状态后，只有当默认插槽的根节点被替换时，\u0026lt;Suspense\u0026gt; 才会回到挂起状态。组件树中新的更深层次的异步依赖不会造成 \u0026lt;Suspense\u0026gt; 回退到挂起状态。\n发生回退时，后备内容不会立即展示出来。相反，\u0026lt;Suspense\u0026gt; 在等待新内容和异步依赖完成时，会展示之前 #default 插槽的内容。这个行为可以通过一个 timeout prop 进行配置：在等待渲染新内容耗时超过 timeout 之后，\u0026lt;Suspense\u0026gt; 将会切换为展示后备内容。若 timeout 值为 0 将导致在替换默认内容时立即显示后备内容。\n和其他组件结合 我们常常会将 \u0026lt;Suspense\u0026gt; 和 ](https://cn.vuejs.org/guide/built-ins/transition.html)、[ 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要。\n另外，这些组件都通常与 Vue Router 中的 \u0026lt;RouterView\u0026gt; 组件结合使用。\n下面的示例展示了如何嵌套这些组件，使它们都能按照预期的方式运行。若想组合得更简单，你也可以删除一些你不需要的组件：\n\u0026lt;RouterView v-slot=\u0026#34;{ Component }\u0026#34;\u0026gt; \u0026lt;template v-if=\u0026#34;Component\u0026#34;\u0026gt; \u0026lt;Transition mode=\u0026#34;out-in\u0026#34;\u0026gt; \u0026lt;KeepAlive\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;!-- 主要内容 --\u0026gt; \u0026lt;component :is=\u0026#34;Component\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;!-- 加载中状态 --\u0026gt; \u0026lt;template #fallback\u0026gt; 正在加载... \u0026lt;/template\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/KeepAlive\u0026gt; \u0026lt;/Transition\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/RouterView\u0026gt; Vue Router 使用动态导入对懒加载组件进行了内置支持。这些与异步组件不同，目前他们不会触发 \u0026lt;Suspense\u0026gt;。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 \u0026lt;Suspense\u0026gt;。\n","permalink":"https://waite.wang/posts/vue/system-learn-vue-2-component/","summary":"\u003ch2 id=\"认识组件化开发\"\u003e认识组件化开发\u003c/h2\u003e\n\u003ch3 id=\"认识组件化开发-1\"\u003e认识组件化开发\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e人面对复杂问题的处理方式：\n\u003cul\u003e\n\u003cli\u003e任何一个人处理信息的逻辑能力都是有限的\u003c/li\u003e\n\u003cli\u003e所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。\u003c/li\u003e\n\u003cli\u003e但是，我们人有一种天生的能力，就是将问题进行拆解。\u003c/li\u003e\n\u003cli\u003e如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e组件化也是类似的思想：\n\u003cul\u003e\n\u003cli\u003e如果我们将一个页面中所有的处理逻辑 全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展；\u003c/li\u003e\n\u003cli\u003e但如果，我们讲一个页面拆分成一个个 小的功能块，每个功能块完成属于自己 这部分独立的功能，那么之后整个页面 的管理和维护就变得非常容易了；\u003c/li\u003e\n\u003cli\u003e如果我们将一个个功能块拆分后，就可 以像搭建积木一下来搭建我们的项目；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e现在可以说整个的大前端开发都是组件化的天下，无论从三大框架（Vue、React、Angular），还是跨平台方案 的Flutter，甚至是移动端都在转向组件化开发，包括小程序的开发也是采用组件化开发的思想\u003c/li\u003e\n\u003cli\u003e所以，学习组件化最重要的是它的思想，每个框架或者平台可能实现方法不同，但是思想都是一样的。\u003c/li\u003e\n\u003cli\u003e我们需要通过组件化的思想来思考整个应用程序：\n\u003cul\u003e\n\u003cli\u003e我们将一个完整的页面分成很多个组件；\u003c/li\u003e\n\u003cli\u003e每个组件都用于实现页面的一个功能块；\u003c/li\u003e\n\u003cli\u003e而每一个组件又可以进行细分；\u003c/li\u003e\n\u003cli\u003e而组件本身又可以在多个地方进行复用；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"vue的组件化\"\u003eVue的组件化\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003evue 项目起始文件 \u003ccode\u003ecreateApp\u003c/code\u003e 函数传入了一个对象App，这个对象其实本质上就是一个组件，也是我们应用程序的根 组件；\u003c/li\u003e\n\u003cli\u003e组件化提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用；\u003c/li\u003e\n\u003cli\u003e任何的应用都会被抽象成一颗组件树；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202310312042389.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202310312042389.png\" alt=\"image-20231031204213497\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e","title":"系统学习 Vue -- 2-深入组件"},{"content":"邂逅 Vue 认识 Vue 什么是 Vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 全程是Vue.js或者Vuejs； 什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目； Vue3带来的变化 源码通过monorepo的形式来管理源代码： Mono：单个 Repo：repository仓库 主要是将许多项目的代码存储在同一个 repository 中； 这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理； 而且模块划分的更加清晰，可维护性、可扩展性更强； 源码使用TypeScript来进行重写： 在Vue2.x的时候，Vue使用 Flow 来进行类型检测； 在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了； 性能方面 使用Proxy进行数据劫持 在 Vue2.x 的时候，Vue2 是使用 Object.defineProperty 来劫持数据的 getter 和 setter 方法的； 这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的； 所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 $set 或 $delete ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本； 而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持 删除了一些不必要的API： 移除了实例上的 $on , $off 和 $once； 移除了一些特性：如filter、内联模板等； 包括编译方面的优化： 生成Block Tree、Slot编译优化、diff算法优化； 新的API 由Options API 到 Composition API： 在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象； Options API 包括data、props、methods、computed、生命周期等等这些选项； 存在比较大的问题是多个逻辑可能是在不同的地方： 比如created中会使用某一个method来修改data的数据，代码的内聚性非常差； Composition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找； Hooks函数增加代码的复用性： 在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题； 在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的； 如何使用 Vue 方式一：在页面中通过CDN的方式来引入； 方式二：下载Vue的JavaScript文件，并且自己手动引入； 方式三：通过npm包管理工具安装使用它； 方式四：直接通过Vue CLI创建项目，并且使用它； CDN 引入 \u0026lt;script src=\u0026#34;https://unpkg.com/vue@next\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 下载和引入 下载Vue的源码，可以直接打开CDN的链接： 打开链接，复制其中所有的代码； 创建一个新的文件，比如vue.js，将代码复制到其中； \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 声明式编程和命令式编程 原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程 命令式编程关注的是“ how to do”,声明式编程关注的是\u0026quot; what to do\u0026quot;,由框架(机器)完成\u0026quot;how\u0026quot;的过程 MVVM模型 MVC和MVVM都是一种软件的体系结构 MVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端 MVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式 通常情况下,我们也经常称vue是一个MVVM的框架 vue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的 template属性 在使用 createApp的时候,我们传入了一个对象,接下来我们详细解析一下之前传入的属性分别代表什么含义。 template属性:表示的是Vue需要帮助我们渲染的模板信息 目前我们看到它里面有很多的HTML标签,这些标签会替换掉我们挂载到的元素(比如id为app的dⅳv)的innerHTML 模板中有一些奇怪的语法,比如{},比如@ )click,这些都是模板特有的语法 但是这个模板的写法有点过于别扭了,并且IDE很有可能没有任何提示,阻碍我们编程的效率 vue提供了两种方式: 方式一:使用 script标签,并且标记它的类型为 X-template; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;hhhh\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;x-template\u0026#34; id=\u0026#34;why\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#39;increment\u0026#39;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#39;decrement\u0026#39;\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;../js//Vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ template: \u0026#39;#why\u0026#39;, data: function(){ return{ message:\u0026#34;Hello World\u0026#34;, counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\u0026#34;#app\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 方式二:使用任意标签(通常使用 template标签,因为不会被浏览器渲染),设置id;v template元素是一种用于保存客户端内容的机制,该内容再加载页面时不会被呈现,但随后可以在运行时使用 JavaScript 实例化 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;why\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#39;increment\u0026#39;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#39;decrement\u0026#39;\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js//Vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ template: \u0026#39;#why\u0026#39;, data: function(){ return{ message:\u0026#34;Hello World\u0026#34;, counter: 100 } }, methods: { increment(){ this.counter++ }, decrement(){ this.counter-- } } }).mount(\u0026#34;#app\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; data属性 data属性是传入一个函数,并且该函数需要返回一个对象\n在Vue2x的时候,也可以传入一个对象(虽然官方推荐是一个函数); 在Vue3x的时候,必须传入一个函数,否则就会直接在浏览器中报错 data中返回的对象会被vue的响应式系统劫持,之后对该对象的修改或者访问都会在劫持中被处理\n所以我们在 template中通过{ counter} 访问 counter,可以从对象中获取到数据 所以我们修改 counter的值时, template中的{ counter)也会发生改变; methods属性（重点） methods属性是一个对象,通常我们会在这个对象中定义很多的方法\n这些方法可以被绑定到 template模板中; 在该方法中,我们可以使用this关键字来直接访问到data中返回的对象的属性; 问题：官方文档有这个描述，即不能使用箭头函数\n为什么不能使用箭头函数(VUE3.0)？\n我们在methods中要使用data返回对象中的数据：\n那么这个this是必须有值的，并且应该可以通过this获取到data返回对象中的数据。 那么我们这个this能不能是window呢？\n不可以是window，因为window中我们无法获取到data返回对象中的数据； 但是如果我们使用箭头函数，那么这个this就会是window了； 为什么是window呢？\n这里涉及到箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this； 最终刚好找到的是script作用于中的this，所以就是window； this到底是如何查找和绑定的呢？\n前端面试之彻底搞懂this指向 不使用箭头函数的情况下，this到底指向什么\n事实上Vue的源码当中就是对methods中的所有函数进行了遍历，并且通过 bind 绑定了 this 具体看 https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA\n// window 隐式绑定 foo(); const obj = { bar: foo }; obj.bar(); /* Window{} {bar: f()} */ const foo2 = () =\u0026gt; { console.log(this); } const obj2 = { bar: foo2 }; obj2.bar(); /* Window{} Window{} */ 编写DOM元素的模板方式 方式一：template模板的方式：使用 \u0026lt;template\u0026gt; 标签编写模板。这种方式是之前经常使用的方式。 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ description }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 方式二：render函数的方式：使用h函数来编写渲染的内容。在这种方式中，h函数可以直接返回一个虚拟节点（Vnode节点）。 export default { render(h) { return h(\u0026#39;div\u0026#39;, [ h(\u0026#39;h1\u0026#39;, this.message), h(\u0026#39;p\u0026#39;, this.description) ]) } } 方式三：通过.vue文件中的template来编写模板：在.vue文件中使用\u0026lt;template\u0026gt;标签编写模板。这种方式需要通过特定的代码来对模板进行解析： 对于方式三，即.vue文件中的template，可以通过vue-loader对其进行编译和处理。 对于方式一，即template模板，我们必须通过源码中的一部分代码来进行编译。 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ message }}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ description }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 因此，Vue在让我们选择版本时，提供了\u0026quot;运行时+编译器\u0026quot;和\u0026quot;仅运行时\u0026quot;两种选项：\n运行时+编译器：这个版本包含了Vue的完整功能，包括对template模板的编译代码。在使用这个版本时，我们可以直接在代码中使用template模板，并且Vue会在运行时将其编译成渲染函数。这使得我们可以在开发过程中更方便地编写和调试模板。然而，由于包含了编译代码，这个版本的文件体积相对较大。 仅运行时：这个版本不包含对template模板的编译代码。它更小巧，文件体积更小。在使用这个版本时，我们需要使用render函数来手动编写渲染逻辑，而不是直接使用template模板。这意味着我们需要更多的代码来实现相同的功能，但也带来了更好的性能和更小的文件大小。 选择哪个版本取决于项目的需求和优化目标。如果我们需要更完整的功能，并且对文件大小没有太大的担忧，可以选择运行时+编译器版本。如果我们对文件大小敏感，并且愿意手动编写渲染逻辑，可以选择仅运行时版本。 VSCode对SFC文件的支持 Vue 的单文件组件 (即 *.vue 文件，英文 Single-File Component，简称 SFC) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：\n为什么要使用 SFC​ 使用 SFC 必须使用构建工具，但作为回报带来了以下优点：\n使用熟悉的 HTML、CSS 和 JavaScript 语法编写模块化的组件\n让本来就强相关的关注点自然内聚\n预编译模板，避免运行时的编译开销\n组件作用域的 CSS\n在使用组合式 API 时语法更简单\n通过交叉分析模板和逻辑代码能进行更多编译时优化\n更好的 IDE 支持，提供自动补全和对模板中表达式的类型检查\n开箱即用的模块热更新 (HMR) 支持\nSFC 是 Vue 框架提供的一个功能，并且在下列场景中都是官方推荐的项目组织方式：\n单页面应用 (SPA)\n静态站点生成 (SSG)\n任何值得引入构建步骤以获得更好的开发体验 (DX) 的项目\nhttps://cn.vuejs.org/guide/scaling-up/sfc.html\n插件一：Vetur，从Vue2开发就一直在使用的VSCode支持Vue的插件； 插件二：Volar，官方推荐的插件（后续会基于Volar开发官方的VSCode插件）； 如何阅读Vue源码 需要的环境 npm，yarn 操作步骤 安装yarn npm install yarn -g 在项目中配置yarn yarn install 在package.json中的dev后加上\u0026ndash;sourcemap 打包项目 yarn dev （在vue/dist文件夹下有两个文件，vue.global.js和vue.global.js.map） 在vue/examplex新建自己的文件夹以及测试demo 在demo中打下断点—debugger 在浏览器中打开调试面板，选择其中的source面板，查看执行对应的源码 Vue3 基本指令 VSCode 代码片段 我们在前面练习Vue的过程中，有些代码片段是需要经常写的，我们再VSCode中我们可以生成一个代码片段，方便我们快速生成。 VSCode中的代码片段有固定的格式，所以我们一般会借助于一个在线工具来完成。 具体的步骤如下： 第一步，复制自己需要生成代码片段的代码； 第二步，https://snippet-generator.app/在该网站中生成代码片段； 第三步，在VSCode中配置代码片段； 直接 Tab trigger 即可自动填充 模板语法 React的开发模式[了解] React使用的jsx,所以对应的代码都是编写的类似于js的一种语法 之后通过Babe将js编译成 React. create Element函数调用 function () { return \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; } vue也支持 jsx 的开发模式: 但是大多数情况下,使用基于HTML的模板语法 在模板中,允许开发者以声明式的方式将 DOM 和底层组件实例的数据绑定在-起;口在底层的实现中,vue将模板编译成虚拟DOM渲染函数 \u0026lt;template\u0026gt; \u0026lt;div @click v-bind v-once\u0026gt; {{}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; Mustache 语法 双大括号语法 如果我们希望把数据显示到模板（template）中，使用最多的语法是 “Mustache”语法 (双大括号) 的文本插值。 并且我们前端提到过，data返回的对象是有添加到Vue的响应式系统中； 当data中的数据发生改变时，对应的内容也会发生更新。 当然，Mustache中不仅仅可以是data中的属性，也可以是一个JavaScript的表达式。 mustache的使用 基本使用 2. 表达式 3. 函数 4. 三元运算符 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.mustache的基本使用 --\u0026gt; \u0026lt;h2\u0026gt;{{message}} - {{message}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 2.是一个表达式 --\u0026gt; \u0026lt;h2\u0026gt;{{counter * 10}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ message.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;) }}\u0026lt;/h2\u0026gt; \u0026lt;!-- 3.也可以调用函数 --\u0026gt; \u0026lt;!-- 可以使用computed(计算属性) --\u0026gt; \u0026lt;h2\u0026gt;{{getReverseMessage()}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 4.三元运算符 --\u0026gt; \u0026lt;h2\u0026gt;{{ isShow ? \u0026#34;哈哈哈\u0026#34;: \u0026#34;\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, counter: 100, isShow: true } }, methods: { getReverseMessage() { return this.message.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;); }, toggle() { this.isShow = !this.isShow; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 以下为错误写法\n\u0026lt;!-- 错误用法 --\u0026gt; var name = \u0026#34;abc\u0026#34; ; \u0026lt;h2\u0026gt;{{var name = \u0026#34;abc\u0026#34;}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ if(isShow) { return \u0026#34;哈哈哈\u0026#34; } }}\u0026lt;/h2\u0026gt; 不常用指令 v-once指令 v-once用于指定元素或者组件只渲染一次\n当数据发生变化时,元素或者组件以及其所有的子元素将视为静态内容并且跳过;\n该指令可以用于性能优化;\n\u0026lt;h2 v-once\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; 如果是子节点的化，也只能渲染一次\n\u0026lt;div v-once\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; 完整代码\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;div v-once\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { counter: 100, message: \u0026#34;abc\u0026#34; } }, methods: { increment() { this.counter++; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; v-html 默认情况下，如果我们展示的内容本身是 html 的，那么vue并不会对其进行特殊的解析。 如果我们希望这个内容被Vue可以解析出来，那么可以使用 v-html 来展示 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{{msg}}\u0026lt;/div\u0026gt; \u0026lt;div v-html=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { msg: \u0026#39;\u0026lt;span style=\u0026#34;color:red; background: blue;\u0026#34;\u0026gt;哈哈哈\u0026lt;/span\u0026gt;\u0026#39; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; v-text 用于更新元素的 textContent \u0026lt;h2 v-text=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;!-- 等价于 --\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; v-pre v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签： 跳过不需要编译的节点，加快编译的速度 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2 v-pre\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- {{message}} --\u0026gt; v-cloak 用于隐藏尚未完成编译的 DOM 模板。 无需传入 详细信息 该指令只在没有构建步骤的环境下需要使用。 当使用直接在 DOM 中书写的模板时，可能会出现一种叫做“未编译模板闪现”的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。 v-cloak 会保留在所绑定的元素上，直到相关组件实例被挂载后才移除。配合像 [v-cloak] { display: none } 这样的 CSS 规则，它可以在组件编译完毕前隐藏原始模板。 [v-cloak] { display: none; } \u0026lt;div v-cloak\u0026gt; {{ message }} \u0026lt;/div\u0026gt; 直到编译完成前，\u0026lt;div\u0026gt; 将不可见。\nv-bind 动态的绑定一个或多个 attribute，也可以是组件的 prop。\n缩写：: 或者 . (当使用 .prop 修饰符)\n期望：any (带参数) | Object (不带参数)\n参数：attrOrProp (可选的)\n修饰符\n.camel - 将短横线命名的 attribute 转变为驼峰式命名。 .prop - 强制绑定为 DOM property。3.2+ .attr - 强制绑定为 DOM attribute。3.2+ 用途\n当用于绑定 class 或 style attribute，v-bind 支持额外的值类型如数组或对象。详见下方的指南链接。\n在处理绑定时，Vue 默认会利用 in 操作符来检查该元素上是否定义了和绑定的 key 同名的 DOM property。如果存在同名的 property，则 Vue 会将它作为 DOM property 赋值，而不是作为 attribute 设置。这个行为在大多数情况都符合期望的绑定值类型，但是你也可以显式用 .prop 和 .attr 修饰符来强制绑定方式。有时这是必要的，特别是在和自定义元素打交道时。\n当用于组件 props 绑定时，所绑定的 props 必须在子组件中已被正确声明。\n当不带参数使用时，可以用于绑定一个包含了多个 attribute 名称-绑定值对的对象。\n用法\n动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。 小知识: vue3 是允许template中有多个根元素\n\u0026lt;!-- vue2 template模板中只能有一个根元素 --\u0026gt; \u0026lt;!-- vue3 是允许template中有多个根元素 --\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.v-bind的基本使用 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a v-bind:href=\u0026#34;link\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; \u0026lt;!-- 2.v-bind提供一个语法糖 : --\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; 基本使用 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.v-bind的基本使用 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a v-bind:href=\u0026#34;link\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt; \u0026lt;!-- 2.v-bind提供一个语法糖 : --\u0026gt; \u0026lt;img :src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- 以下报错 --\u0026gt; \u0026lt;img src=\u0026#34;imgUrl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { imgUrl: \u0026#34;https://avatars.githubusercontent.com/u/10335230?s=60\u0026amp;v=4\u0026#34;, link: \u0026#34;https://www.baidu.com\u0026#34; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 绑定 class 在开发中,有时候我们的元素 class也是动态的,比如 当数据为某个状态时,字体显示红色。 当数据另一个状态时,字体显示黑色 绑定class有两种方式： 对象语法 数组语法 对象语法 对象语法：我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;className\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- 对象语法: {\u0026#39;active\u0026#39;: boolean} --\u0026gt; \u0026lt;div :class=\u0026#34;{\u0026#39;active\u0026#39;: isActive}\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;toggle\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;!-- 也可以有多个键值对 --\u0026gt; \u0026lt;div :class=\u0026#34;{active: isActive, title: true}\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;!-- 默认的class和动态的class结合 --\u0026gt; \u0026lt;div class=\u0026#34;abc cba\u0026#34; :class=\u0026#34;{active: isActive, title: true}\u0026#34;\u0026gt; 呵呵呵呵 \u0026lt;/div\u0026gt; \u0026lt;!-- 将对象放到一个单独的属性中 --\u0026gt; \u0026lt;div class=\u0026#34;abc cba\u0026#34; :class=\u0026#34;classObj\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;!-- 将返回的对象放到一个methods(computed)方法中 --\u0026gt; \u0026lt;div class=\u0026#34;abc cba\u0026#34; :class=\u0026#34;getClassObj()\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#34;#my-app\u0026#34;, data() { return { className: \u0026#34;why\u0026#34;, isActive: true, title: \u0026#34;abc\u0026#34;, classObj: { active: true, title: true }, }; }, methods: { toggle() { this.isActive = !this.isActive; this.classObj.active = !this.classObj.active; }, getClassObj() { return this.classObj; } }, }; Vue.createApp(App).mount(\u0026#34;#app\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; .active { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/body\u0026gt; 数组语法 绑定class – 数组语法 数组语法：我们可以把一个数组传给 :class，以应用一个 class 列表 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;abc\u0026#39;, title]\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- class=\u0026#34;abc cba active\u0026#34; --\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;abc\u0026#39;, title, isActive ? \u0026#39;active\u0026#39;: \u0026#39;\u0026#39;]\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- 可以嵌套对象语法 --\u0026gt; \u0026lt;div :class=\u0026#34;[\u0026#39;abc\u0026#39;, title, {active: isActive}]\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, title: \u0026#34;cba\u0026#34;, isActive: true } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 绑定 style 我们可以利用 v-bind:style 来绑定一些CSS内联样式 这次因为某些样式我们需要根据数据动态来决定 比如某段文字的颜色，大小等等 CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名 绑定class有两种方式 对象语法 数组语法 CSS property 名短横线分隔 (kebab-case，记得用引号括起来)\n对象语法 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- :style=\u0026#34;{cssPropertyName: cssPropertyValue}\u0026#34; --\u0026gt; \u0026lt;div :style=\u0026#34;{color: finalColor, \u0026#39;font-size\u0026#39;: \u0026#39;30px\u0026#39;}\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div :style=\u0026#34;{color: finalColor, fontSize: \u0026#39;30px\u0026#39;}\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div :style=\u0026#34;{color: finalColor, fontSize: finalFontSize + \u0026#39;px\u0026#39;}\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;!-- 绑定一个data中的属性值, 并且是一个对象 --\u0026gt; \u0026lt;div :style=\u0026#34;finalStyleObj\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;!-- 调用一个方法 --\u0026gt; \u0026lt;div :style=\u0026#34;getFinalStyleObj()\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, finalColor: \u0026#39;red\u0026#39;, finalFontSize: 50, finalStyleObj: { \u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;, fontWeight: 700, backgroundColor: \u0026#39;red\u0026#39; } } }, methods: { getFinalStyleObj() { return { \u0026#39;font-size\u0026#39;: \u0026#39;50px\u0026#39;, fontWeight: 700, backgroundColor: \u0026#39;red\u0026#39; } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 数组语法 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div :style=\u0026#34;[style1Obj, style2Obj]\u0026#34;\u0026gt;哈哈哈\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, style1Obj: { color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;30px\u0026#39; }, style2Obj: { textDecoration: \u0026#34;underline\u0026#34; } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body 动态绑定属性 在某些情况下，我们属性的名称可能也不是固定的 前端我们无论绑定src、href、class、style，属性名称都是固定的 如果属性名称不是固定的，我们可以使用 :[属性名]=“值” 的格式来定义 这种绑定的方式，我们称之为 动态绑定属性；如下: \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div cba=\u0026#34;kobe\u0026#34;\u0026gt;哈哈哈\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div :[name]=\u0026#34;value\u0026#34;\u0026gt;哈哈哈\u0026lt;/div\u0026gt; \u0026lt;img :src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a :href=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;div :class\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { name: \u0026#34;cba\u0026#34;, value: \u0026#34;kobe\u0026#34; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 属性直接绑定一个对象 如果我们希望将一个对象的所有属性，绑定到元素上的所有属性，应该怎么做呢？ 非常简单，我们可以直接使用 v-bind 绑定一个 对象 案例：info对象会被拆解成div的各个属性 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;div name=\u0026#34;why\u0026#34; age=\u0026#34;18\u0026#34; height=\u0026#34;1.88\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; --\u0026gt; \u0026lt;div v-bind=\u0026#34;info\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;div :=\u0026#34;info\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { info: { name: \u0026#34;why\u0026#34;, age: 18, height: 1.88 } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-on v-on绑定事件\n前面我们绑定了元素的内容和属性，在前端开发中另外一个非常重要的特性就是交互。 在前端开发中，我们需要经常和用户进行各种各样的交互 这个时候，我们就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等 在Vue中如何监听事件呢？使用v-on指令。 v-on的用法\n缩写：@\n预期：Function | Inline Statement | Object\n参数：event p 修饰符：\n.stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyAlias} - 仅当事件是从特定键触发时才触发回调。 .once - 只触发一次回调。 .left - 只当点击鼠标左键时触发。 .right - 只当点击鼠标右键时触发。 .middle - 只当点击鼠标中键时触发。 .passive - { passive: true } 模式添加侦听器 用法：绑定事件监听\nevent 事件可以参考 https://developer.mozilla.org/en-US/docs/Web/Events\n基本使用 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 完整写法: v-on:监听的事件=\u0026#34;methods中方法\u0026#34; --\u0026gt; \u0026lt;button v-on:click=\u0026#34;btn1Click\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;area\u0026#34; v-on:mousemove=\u0026#34;mouseMove\u0026#34;\u0026gt;div\u0026lt;/div\u0026gt; \u0026lt;!-- 语法糖 --\u0026gt; \u0026lt;button @click=\u0026#34;btn1Click\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;!-- 绑定一个表达式: inline statement --\u0026gt; \u0026lt;button @click=\u0026#34;counter++\u0026#34;\u0026gt;{{counter}}\u0026lt;/button\u0026gt; \u0026lt;!-- 绑定一个对象 --\u0026gt; \u0026lt;div class=\u0026#34;area\u0026#34; v-on=\u0026#34;{click: btn1Click, mousemove: mouseMove}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;area\u0026#34; @=\u0026#34;{click: btn1Click, mousemove: mouseMove}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34;, counter: 100 } }, methods: { btn1Click() { console.log(\u0026#34;按钮1发生了点击\u0026#34;); }, mouseMove() { console.log(\u0026#34;鼠标移动\u0026#34;); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 参数传递 当通过methods中定义方法，以供 @click调用时，需要注意参数问题： 情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。 但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去 情况二：如果需要同时传入某个参数，同时需要 event 时，可以通过 $event 传入事件。 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 默认传入event对象, 可以在方法中获取 --\u0026gt; \u0026lt;button @click=\u0026#34;btn1Click\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;!-- $event可以获取到事件发生时的事件对象 --\u0026gt; \u0026lt;button @click=\u0026#34;btn2Click($event, \u0026#39;coderwhy\u0026#39;, 18)\u0026#34;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34; } }, methods: { btn1Click(event) { console.log(event); }, btn2Click(event, name, age) { console.log(name, age, event); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-on 的修饰符 v-on支持修饰符，修饰符相当于对事件进行了一些特殊的处理： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyAlias} - 仅当事件是从特定键触发时才触发回调。 .once - 只触发一次回调。 .left - 只当点击鼠标左键时触发。 .right - 只当点击鼠标右键时触发。 .middle - 只当点击鼠标中键时触发。 .passive - { passive: true } 模式添加侦听器 stopPropagation 是一个事件修饰符，用于阻止事件冒泡。在 Vue.js 中，当一个元素上的事件被触发时，它会先执行该元素上的事件处理函数，然后再冒泡到该元素的父元素，继续执行父元素的事件处理函数。使用 stopPropagation 可以阻止事件继续冒泡到父元素。在给元素绑定事件时，可以使用 @click.stop 来阻止 click 事件冒泡到父元素。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;div @click=\u0026#34;divClick\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;button @click.stop=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;enterKeyup\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { message: \u0026#34;Hello World\u0026#34; } }, methods: { divClick() { console.log(\u0026#34;divClick\u0026#34;); }, btnClick() { console.log(\u0026#39;btnClick\u0026#39;); }, enterKeyup(event) { console.log(\u0026#34;keyup\u0026#34;, event.target.value); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 条件渲染 在某些情况下，我们需要根据当前的条件决定某些元素或组件是否渲染，这个时候我们就需要进行条件判断了。 Vue提供了下面的指令来进行条件判断： v-if v-else v-else-if v-show 基本使用 v-if、v-else、v-else-if用于根据条件来渲染某一块的内容： 这些内容只有在条件为true时，才会被渲染出来； 这三个指令与JavaScript的条件语句if、else、else if类似； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;score\u0026#34;\u0026gt; \u0026lt;h2 v-if=\u0026#34;score \u0026gt; 90\u0026#34;\u0026gt;优秀\u0026lt;/h2\u0026gt; \u0026lt;h2 v-else-if=\u0026#34;score \u0026gt; 60\u0026#34;\u0026gt;良好\u0026lt;/h2\u0026gt; \u0026lt;h2 v-else\u0026gt;不及格\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { score: 95 } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; template 和 v-if 结合使用 v-if的渲染原理： v-if是惰性的； 当条件为false时，其判断的内容完全不会被渲染或者会被销毁掉； 当条件为true时，才会真正渲染条件块中的内容; template元素 因为v-if是一个指令，所以必须将其添加到一个元素上： 但是如果我们希望切换的是多个元素呢？ 此时我们渲染div，但是我们并不希望div这种元素被渲染； 这个时候，我们可以选择使用template； template元素可以当做不可见的包裹元素，并且在v-if上使用，但是最终template不会被渲染出来： 有点类似于小程序中的block \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;template v-if=\u0026#34;isShowHa\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;h2\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;button @click=\u0026#34;isShowHa = !isShowHa\u0026#34;\u0026gt;切换\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { isShowHa: true } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-show v-show和v-if的用法看起来是一致的，也是根据一个条件决定是否显示元素或者组件 \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2 v-show=\u0026#34;isShow\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; v-show和v-if的区别 首先，在用法上的区别： v-show是不支持template； v-show不可以和v-else一起使用； 其次，本质的区别： v-show元素无论是否需要显示到浏览器上，它的DOM实际都是有渲染的，只是通过CSS的display属性来进行 切换； v-if当条件为false时，其对应的元素压根不会被渲染到DOM中； 开发中如何进行选择呢？ 如果我们的元素需要在显示和隐藏之间频繁的切换，那么使用v-show； 如果不会频繁的发生切换，那么使用v-if； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2 v-if=\u0026#34;isShow\u0026#34;\u0026gt;哈哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;h2 v-show=\u0026#34;isShow\u0026#34;\u0026gt;呵呵呵呵\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; 列表渲染 在真实开发中，我们往往会从服务器拿到一组数据，并且需要对其进行渲染。 这个时候我们可以使用v-for来完成； v-for类似于JavaScript的for循环，可以用于遍历一组数据； 基本使用 n v-for的基本格式是 \u0026ldquo;item in 数组\u0026rdquo;：\n数组通常是来自data或者prop，也可以是其他方式； item是我们给每项元素起的一个别名，这个别名可以自定来定义； 我们知道，在遍历一个数组的时候会经常需要拿到数组的索引：\n如果我们需要索引，可以使用格式： \u0026ldquo;(item, index) in 数组\u0026rdquo;； 注意上面的顺序：数组元素项item是在前面的，索引项index是在后面的； v-for支持的类型\nv-for也支持遍历对象，并且支持有一二三个参数： 一个参数： \u0026ldquo;value in object\u0026rdquo;; 二个参数： \u0026ldquo;(value, key) in object\u0026rdquo;; 三个参数： \u0026ldquo;(value, key, index) in object\u0026rdquo;; v-for同时也支持数字的遍历： 每一个item都是一个数字； \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;电影列表\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 遍历数组 --\u0026gt; \u0026lt;li v-for=\u0026#34;(movie, index) in movies\u0026#34;\u0026gt;{{index+1}}.{{movie}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;个人信息\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!-- 遍历对象 --\u0026gt; \u0026lt;li v-for=\u0026#34;(value, key, index) in info\u0026#34;\u0026gt;{{value}}-{{key}}-{{index}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h2\u0026gt;遍历数字\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(num, index) in 10\u0026#34;\u0026gt;{{num}}-{{index}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { movies: [ \u0026#34;星际穿越\u0026#34;, \u0026#34;盗梦空间\u0026#34;, \u0026#34;大话西游\u0026#34;, \u0026#34;教父\u0026#34;, \u0026#34;少年派\u0026#34; ], info: { name: \u0026#34;why\u0026#34;, age: 18, height: 1.88 } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; template元素使用 类似于v-if，你可以使用 template 元素来循环渲染一段包含多个元素的内容： 我们使用template来对多个元素进行包裹，而不是使用div来完成； \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;template v-for=\u0026#34;(value, key) in info\u0026#34;\u0026gt; \u0026lt;li\u0026gt;{{key}}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;{{value}}\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;divider\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { info: { name: \u0026#34;why\u0026#34;, age: 18, height: 1.88 } } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 数组更新检测 Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push() pop() shift() unshift() splice() sort() reverse() 替换数组的方法 上面的方法会直接修改原来的数组，但是某些方法不会替换原来的数组，而是会生成新的数组，比如 filter()、 concat() 和 slice()。 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;电影列表\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(movie, index) in movies\u0026#34;\u0026gt;{{index+1}}.{{movie}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;newMovie\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;addMovie\u0026#34;\u0026gt;添加电影\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { newMovie: \u0026#34;\u0026#34;, movies: [ \u0026#34;星际穿越\u0026#34;, \u0026#34;盗梦空间\u0026#34;, \u0026#34;大话西游\u0026#34;, \u0026#34;教父\u0026#34;, \u0026#34;少年派\u0026#34; ] } }, methods: { addMovie() { this.movies.push(this.newMovie); this.newMovie = \u0026#34;\u0026#34;; // filter 是过滤的意思, 下文中的代码的意思是: 过滤掉长度小于等于2的电影 // this.movies = this.movies.filter(item =\u0026gt; item.length \u0026gt; 2); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; v-for 中的 key 是什么作用？ https://cn.vuejs.org/api/built-in-special-attributes.html#key\n在使用v-for进行列表渲染时，我们通常会给元素或者组件绑定一个key属性。\n这个key属性有什么作用呢？我们先来看一下官方的解释：\nkey属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes；\n如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法；\n而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素；\n官方的解释对于初学者来说并不好理解，比如下面的问题：\n什么是新旧nodes，什么是VNode？ 没有key的时候，如何尝试修改和复用的？ 有key的时候，如何基于key重新排列的？ 认识 VNode 我们先来解释一下VNode的概念： 因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解HTML元素创建出来的VNode； VNode的全称是Virtual Node，也就是虚拟节点； 事实上，无论是组件还是元素，它们最终在Vue中表示出来的都是一个个VNode； VNode的本质是一个JavaScript的对象；可以用于描述某一个标签/ 元素 的样子 好处: 多平台的渲染, 跨平台(主要好处) 虚拟 DOM 如果我们不只是一个简单的div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree 虚拟 DOM 与 真实 DOM 不一定一一对应 插入 F 的案例 我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个f；\n我们可以确定的是，这次更新对于ul和button是不需要进行更新，需要更新的是我们 li 的列表：\n在Vue中，对于相同父元素的子元素节点并不会重新渲染整个列 表；\n因为对于列表中 a、b、c、d它们都是没有变化的；\n在操作真实DOM的时候，我们只需要在中间插入一个 f 的 li 即可；\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;item in letters\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt;{{item}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;button @click=\u0026#34;insertF\u0026#34;\u0026gt;插入F元素\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { letters: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;] } }, methods: { insertF() { this.letters.splice(2, 0, \u0026#39;f\u0026#39;) } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 那么Vue中对于列表的更新究竟是如何操作的呢？ Vue事实上会对于有key和没有key会调用两个不同的方法； Vue源码对于key的判断 有key，那么就使用 patchKeyedChildren方法； 没有key，那么久使用 patchUnkeyedChildren方法； diff算法: diff 算法是指生成更新补丁的方式,主要应用于虚拟 DOM 树变化后,更新真实 DOM。所以 diff 算法一定存在这样一个过程:触发更新 → 生成补丁 → 应用补丁。\n没有key的操作过程 我们会发现上面的diff算法效率并不高： c和d来说它们事实上并不需要有任何的改动； 但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增； 有key的操作过程-diff算法 第一步的操作是从头开始进行遍历、比较： a和b是一致的会继续进行比较； c和f因为key不一致，所以就会break跳出循环 第二步的操作是从尾部开始进行遍历、比较 第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点： 第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点： 第五步是最特色的情况，中间还有很多未知的或者乱序的节点： 有无key的结论 有无key的结论 所以我们可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作： 在没有key的时候我们的效率是非常低效的； 在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效； Vue 的 Options API Computed 认识计算属性 我们知道，在模板中可以直接通过插值语法显示一些data中的数据。\n但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示；\n比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示； 在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算； 在模板中放入太多的逻辑会让模板过重和难以维护； 并且如果多个地方都使用到，那么会有大量重复的代码； 我们有没有什么方法可以将逻辑抽离出去呢？\n可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中； 但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用； 另外一种方式就是使用计算属性computed； 什么是计算属性呢？\nhttps://cn.vuejs.org/api/reactivity-core.html#computed 官方并没有给出直接的概念解释； 而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性； 计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例； 基本使用 计算属性的用法：\n选项： computed 类型：{ [key: string]: Function | { get: Function, set: Function } } 我们来看三个案例：\n我们有两个变量：firstName 和 lastName，希望它们拼接之后在界面上显示； 我们有一个分数：score 当score大于60的时候，在界面上显示及格； 当score小于60的时候，在界面上显示不及格； 我们有一个变量message，记录一段文字：比如Hello World 某些情况下我们是直接显示这段文字； 某些情况下我们需要对这段文字进行反转； 我们可以有三种实现思路： 思路一：在模板语法中直接使用表达式； 思路二：使用method对逻辑进行抽取； 思路三：使用计算属性computed； 在模板语法中直接使用表达式 缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）； 缺点二：当有多次一样的逻辑时，存在重复的代码； 缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.实现思路一: --\u0026gt; \u0026lt;h2\u0026gt;{{ firstName + lastName }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ score \u0026gt;= 60 ? \u0026#34;及格\u0026#34;: \u0026#34;不及格\u0026#34; }}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{ message.split(\u0026#34;\u0026#34;).reverse().join(\u0026#34; \u0026#34;) }}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; 使用method对逻辑进行抽取 缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用； 缺点二：多次使用方法的时候，没有缓存，也需要多次计算； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getResult()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getReverseMessage()}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { firstName: \u0026#34;Kobe\u0026#34;, lastName: \u0026#34;Bryant\u0026#34;, score: 80, message: \u0026#34;Hello World\u0026#34; } }, methods: { getFullName() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, getResult() { return this.score \u0026gt;= 60 ? \u0026#34;及格\u0026#34;: \u0026#34;不及格\u0026#34;; }, getReverseMessage() { return this.message.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; computed 实现 注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会讲到； 我们会发现无论是直观上，还是效果上计算属性都是更好的选择； 并且计算属性是有缓存的； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{result}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{reverseMessage}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { firstName: \u0026#34;Kobe\u0026#34;, lastName: \u0026#34;Bryant\u0026#34;, score: 80, message: \u0026#34;Hello World\u0026#34; } }, computed: { // 定义了一个计算属性叫fullname fullName() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, result() { return this.score \u0026gt;= 60 ? \u0026#34;及格\u0026#34;: \u0026#34;不及格\u0026#34;; }, reverseMessage() { return this.message.split(\u0026#34; \u0026#34;).reverse().join(\u0026#34; \u0026#34;); } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 计算属性 vs methods 在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存。\n接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：\n\u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;changeFirstName\u0026#34;\u0026gt;修改firstName\u0026lt;/button\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getFullName()}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { firstName: \u0026#34;Kobe\u0026#34;, lastName: \u0026#34;Bryant\u0026#34; } }, computed: { // 计算属性是有缓存的, 当我们多次使用计算属性时, 计算属性中的运算只会执行一次. // 计算属性会随着依赖的数据(firstName)的改变, 而进行重新计算. fullName() { console.log(\u0026#34;computed的fullName中的计算\u0026#34;); return this.firstName + \u0026#34; \u0026#34; + this.lastName; } }, methods: { getFullName() { console.log(\u0026#34;methods的getFullName中的计算\u0026#34;); return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, changeFirstName() { this.firstName = \u0026#34;Coder\u0026#34; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 打印结果如下：\n我们会发现methods在多次使用时，会调用多次； 而计算属性虽然使用了多次，但是计算的过程只调用了一次； 这是因为计算属性会基于它们的依赖关系进行缓存； 在数据不发生变化时，计算属性是不需要重新计算的； 但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；如下: \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;score\u0026#34;\u0026gt; \u0026lt;!-- 1.使用methods --\u0026gt; \u0026lt;h2\u0026gt;{{getResult()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getResult()}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{getResult()}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 2.使用computed --\u0026gt; \u0026lt;h2\u0026gt;{{result}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{result}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;{{result}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { score: 90 } }, computed: { result() { console.log(\u0026#34;调用了计算属性result的getter\u0026#34;); return this.score \u0026gt;= 60 ? \u0026#34;及格\u0026#34;: \u0026#34;不及格\u0026#34;; } }, methods: { getResult() { console.log(\u0026#34;调用了getResult方法\u0026#34;); return this.score \u0026gt;= 60 ? \u0026#34;及格\u0026#34;: \u0026#34;不及格\u0026#34;; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 当 score 变化, console 输出如下:\n调用了getResult方法 调用了getResult方法 调用了getResult方法 调用了计算属性result的getter 计算属性的 setter 和 getter 计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数。\n但是，如果我们确实想设置计算属性的值呢？\n这个时候我们也可以给计算属性设置一个setter的方法； \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;changeFullName\u0026#34;\u0026gt;修改fullName\u0026lt;/button\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { firstName: \u0026#34;Kobe\u0026#34;, lastName: \u0026#34;Bryant\u0026#34; } }, computed: { // fullName 的 getter方法 fullName() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, // fullName的getter和setter方法 fullName: { get: function() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, set: function(newValue) { console.log(newValue); const names = newValue.split(\u0026#34; \u0026#34;); this.firstName = names[0]; this.lastName = names[1]; } } }, methods: { changeFullName() { this.fullName = \u0026#34;Coder Why\u0026#34;; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; 以下为内部判断\n侦听器 watch 用于声明在数据更改时调用的侦听回调。watch 选项期望接受一个对象，其中键是需要侦听的响应式组件实例属性 (例如，通过 data 或 computed 声明的属性)——值是相应的回调函数。该回调函数接受被侦听源的新值和旧值。\n什么是侦听器？ 开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中; 当数据变化时，template会自动进行更新来显示最新的数据; 但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了; 用法如下： 选项：watch 类型: {[key: string]: string | Function | Object | Array} 简单案例 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; 您的问题: \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;question\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;queryAnswer\u0026#34;\u0026gt;查找答案\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;您的问题是: {{ question }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;答案是: {{ anwser }}\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { // 侦听question的变化时, 去进行一些逻辑的处理(JavaScript, 网络请求) question: \u0026#34;Hello World\u0026#34;, anwser: \u0026#34;\u0026#34; } }, watch: { // question侦听的data中的属性的名称 // newValue变化后的新值 // oldValue变化前的旧值 question: function(newValue, oldValue) { console.log(\u0026#34;新值: \u0026#34;, newValue, \u0026#34;旧值\u0026#34;, oldValue); this.queryAnswer(); } }, methods: { queryAnswer() { // console.log(`你的问题${this.question}的答案是哈哈哈哈哈`); this.anwser = `你的问题${this.question}的答案是哈哈哈哈哈`; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 配置选项 watch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器： 以下为不使用深度监听, 当 info.name 在方法中被赋值改变时, 页面会改变, 但是watch不会侦听到, 理由如上 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{info.name}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeInfo\u0026#34;\u0026gt;改变info\u0026lt;/button\u0026gt; \u0026lt;!-- 页面会改变, 但是watch不会侦听到 --\u0026gt; \u0026lt;button @click=\u0026#34;changeInfoName\u0026#34;\u0026gt;改变info.name\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeInfoNbaName\u0026#34;\u0026gt;改变info.nba.name\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { info: { name: \u0026#34;why\u0026#34;, age: 18, nba: {name: \u0026#39;kobe\u0026#39;} } } }, watch: { // 默认情况下我们的侦听器只会针对监听的数据本身的改变(内部发生的改变是不能侦听) info(newInfo, oldInfo) { console.log(\u0026#34;newValue:\u0026#34;, newInfo, \u0026#34;oldValue:\u0026#34;, oldInfo); } }, methods: { changeInfo() { this.info = {name: \u0026#34;kobe\u0026#34;}; }, changeInfoName() { this.info.name = \u0026#34;kobe\u0026#34;; }, changeInfoNbaName() { this.info.nba.name = \u0026#34;james\u0026#34;; } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 将 watch 中更改如下, 不管多深都会侦听到 watch: { // 深度侦听/立即执行(一定会执行一次) info: { handler: function(newInfo, oldInfo) { console.log(\u0026#34;newValue:\u0026#34;, newInfo, \u0026#34;oldValue:\u0026#34;, oldInfo); }, deep: true, // 深度侦听 // immediate: true // 立即执行 } } immediate: true 立即执行, 这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；即当刷新页面时会立刻执行一次, 回调函数的初次执行就发生在 created 钩子之前。Vue 此时已经处理了 data、computed 和 methods 选项，所以这些属性在第一次调用时就是可用的。 newValue: Proxy(Object) {name: \u0026#39;why\u0026#39;, age: 18, nba: {…}} oldValue: undefined 注意: 引用对象 or watch 不能侦听到旧值, 可以利用 计算属性 缓存旧值, 或者自己深拷贝一份作为保存\n其他方式 https://cn.vuejs.org/api/options-state.html#watch\nexport default { data() { return { a: 1, b: 2, c: { d: 4 }, e: 5, f: 6 } }, watch: { // 侦听根级属性 a(val, oldVal) { console.log(`new: ${val}, old: ${oldVal}`) }, // 字符串方法名称 b: \u0026#39;someMethod\u0026#39;, // 该回调将会在被侦听的对象的属性改变时调动，无论其被嵌套多深 c: { handler(val, oldVal) { console.log(\u0026#39;c changed\u0026#39;) }, deep: true }, // 侦听单个嵌套属性： \u0026#39;c.d\u0026#39;: function (val, oldVal) { // do something }, // 该回调将会在侦听开始之后立即调用 e: { handler(val, oldVal) { console.log(\u0026#39;e changed\u0026#39;) }, immediate: true }, // 你可以传入回调数组，它们将会被逐一调用 f: [ \u0026#39;handle1\u0026#39;, function handle2(val, oldVal) { console.log(\u0026#39;handle2 triggered\u0026#39;) }, { handler: function handle3(val, oldVal) { console.log(\u0026#39;handle3 triggered\u0026#39;) } /* ... */ } ] }, methods: { someMethod() { console.log(\u0026#39;b changed\u0026#39;) }, handle1() { console.log(\u0026#39;handle 1 triggered\u0026#39;) } }, created() { this.a = 3 // =\u0026gt; new: 3, old: 1 } } $watch 的API https://cn.vuejs.org/api/component-instance.html#watch\n我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听；\n第一个参数是要侦听的源； 第二个参数是侦听的回调函数callback； 第三个参数是额外的其他选项，比如deep、immediate； created() { const unwatch = this.$watch(\u0026#34;info\u0026#34;, function(newInfo, oldInfo) { console.log(newInfo, oldInfo); }, { deep: true, immediate: true }) // unwatch() } 阶段案例 现在我们来做一个相对综合一点的练习：书籍购物车\ncss table { border: 1px solid #e9e9e9; border-collapse: collapse; border-spacing: 0; } th, td { padding: 8px 16px; border: 1px solid #e9e9e9; text-align: left; } th { background-color: #f7f7f7; color: #5c6b77; font-weight: 600; } .counter { margin: 0 5px; } index \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;template v-if=\u0026#34;books.length \u0026gt; 0\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;书籍名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;出版日期\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;价格\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;购买数量\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;(book, index) in books\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{book.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{book.date}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{formatPrice(book.price)}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button :disabled=\u0026#34;book.count \u0026lt;= 1\u0026#34; @click=\u0026#34;decrement(index)\u0026#34;\u0026gt; - \u0026lt;/button\u0026gt; \u0026lt;span class=\u0026#34;counter\u0026#34;\u0026gt;{{book.count}}\u0026lt;/span\u0026gt; \u0026lt;button @click=\u0026#34;increment(index)\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button @click=\u0026#34;removeBook(index)\u0026#34;\u0026gt;移除\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;h2\u0026gt;总价格: {{formatPrice(totalPrice)}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;h2\u0026gt;购物车为空~\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;./index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.createApp({ template: \u0026#34;#my-app\u0026#34;, data() { return { books: [ { id: 1, name: \u0026#34;《算法导论》\u0026#34;, date: \u0026#34;2006-9\u0026#34;, price: 85.0, count: 1, }, { id: 2, name: \u0026#34;《UNIX编程艺术》\u0026#34;, date: \u0026#34;2006-2\u0026#34;, price: 59.0, count: 1, }, { id: 3, name: \u0026#34;《编程珠玑》\u0026#34;, date: \u0026#34;2008-10\u0026#34;, price: 39.0, count: 1, }, { id: 4, name: \u0026#34;《代码大全》\u0026#34;, date: \u0026#34;2006-3\u0026#34;, price: 128.0, count: 1, }, ], }; }, computed: { totalPrice() { let finalPrice = 0; for (let book of this.books) { finalPrice += book.count * book.price; } return finalPrice; }, // Vue3不支持过滤器了, 推荐两种做法: 使用计算属性/使用全局的方法 filterBooks() { return this.books.map((item) =\u0026gt; { const newItem = Object.assign({}, item); newItem.price = \u0026#34;¥\u0026#34; + item.price; return newItem; }); }, }, methods: { increment(index) { // 通过索引值获取到对象 this.books[index].count++; }, decrement(index) { this.books[index].count--; }, removeBook(index) { this.books.splice(index, 1); }, formatPrice(price) { return \u0026#34;¥\u0026#34; + price; }, }, }).mount(\u0026#34;#app\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; v-model v-model 可以在组件上使用以实现双向绑定。\n首先让我们回忆一下 v-model 在原生元素上的用法：\ntemplate\n\u0026lt;input v-model=\u0026#34;searchText\u0026#34; /\u0026gt; 在代码背后，模板编译器会对 v-model 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：\n\u0026lt;input :value=\u0026#34;searchText\u0026#34; @input=\u0026#34;searchText = $event.target.value\u0026#34; /\u0026gt; 而当使用在一个组件上时，v-model 会被展开为如下的形式：\n\u0026lt;CustomInput :model-value=\u0026#34;searchText\u0026#34; @update:model-value=\u0026#34;newValue =\u0026gt; searchText = newValue\u0026#34; /\u0026gt; 要让这个例子实际工作起来，\u0026lt;CustomInput\u0026gt; 组件内部需要做两件事：\n将内部原生 \u0026lt;input\u0026gt; 元素的 value attribute 绑定到 modelValue prop 当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件 内部实现 绑定其他表单 具体可以看: https://cn.vuejs.org/guide/essentials/forms.html#modifiers\n在 HTML 中，\u0026lt;label\u0026gt; 标签的 for 属性被用来关联 \u0026lt;label\u0026gt; 标签和表单控件（如 \u0026lt;input\u0026gt;、\u0026lt;textarea\u0026gt;、\u0026lt;select\u0026gt; 等）。for 属性的值应该是你想要关联的表单控件的 id。 当 \u0026lt;label\u0026gt; 被点击时，与其关联的表单控件会获得焦点。\n\u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;my-app\u0026#34;\u0026gt; \u0026lt;!-- 1.绑定textarea --\u0026gt; \u0026lt;label for=\u0026#34;intro\u0026#34;\u0026gt; 自我介绍 \u0026lt;textarea name=\u0026#34;intro\u0026#34; id=\u0026#34;intro\u0026#34; cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34; v-model=\u0026#34;intro\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;h2\u0026gt;intro: {{intro}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 2.checkbox --\u0026gt; \u0026lt;!-- 2.1.单选框 --\u0026gt; \u0026lt;label for=\u0026#34;agree\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;agree\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;isAgree\u0026#34;\u0026gt; 同意协议 \u0026lt;/label\u0026gt; \u0026lt;h2\u0026gt;isAgree: {{isAgree}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 2.2.多选框 --\u0026gt; \u0026lt;span\u0026gt;你的爱好: \u0026lt;/span\u0026gt; \u0026lt;label for=\u0026#34;basketball\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;basketball\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobbies\u0026#34; value=\u0026#34;basketball\u0026#34;\u0026gt; 篮球 \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;football\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;football\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobbies\u0026#34; value=\u0026#34;football\u0026#34;\u0026gt; 足球 \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;tennis\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;tennis\u0026#34; type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;hobbies\u0026#34; value=\u0026#34;tennis\u0026#34;\u0026gt; 网球 \u0026lt;/label\u0026gt; \u0026lt;h2\u0026gt;hobbies: {{hobbies}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 3.radio --\u0026gt; \u0026lt;span\u0026gt;你的爱好: \u0026lt;/span\u0026gt; \u0026lt;label for=\u0026#34;male\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;male\u0026#34; type=\u0026#34;radio\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;male\u0026#34;\u0026gt;男 \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;female\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;female\u0026#34; type=\u0026#34;radio\u0026#34; v-model=\u0026#34;gender\u0026#34; value=\u0026#34;female\u0026#34;\u0026gt;女 \u0026lt;/label\u0026gt; \u0026lt;h2\u0026gt;gender: {{gender}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 4.select --\u0026gt; \u0026lt;span\u0026gt;喜欢的水果: \u0026lt;/span\u0026gt; \u0026lt;select v-model=\u0026#34;fruit\u0026#34; multiple size=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;apple\u0026#34;\u0026gt;苹果\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;orange\u0026#34;\u0026gt;橘子\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;banana\u0026#34;\u0026gt;香蕉\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;h2\u0026gt;fruit: {{fruit}}\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const App = { template: \u0026#39;#my-app\u0026#39;, data() { return { intro: \u0026#34;Hello World\u0026#34;, isAgree: false, hobbies: [\u0026#34;basketball\u0026#34;], gender: \u0026#34;\u0026#34;, fruit: \u0026#34;orange\u0026#34; } }, methods: { commitForm() { axios } } } Vue.createApp(App).mount(\u0026#39;#app\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 目前我们在前面的案例中大部分的值都是在template中固定好的：\n比如gender的两个输入框值male、female； 比如hobbies的三个输入框值basketball、football、tennis； 在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是值绑定。\n修饰符 内置修饰符 .lazy 默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据：\n\u0026lt;!-- 在 \u0026#34;change\u0026#34; 事件后同步更新而不是 \u0026#34;input\u0026#34; --\u0026gt; \u0026lt;input v-model.lazy=\u0026#34;msg\u0026#34; /\u0026gt; .number 如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入：\n另外，在我们进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的：\n下面的score在进行判断的过程中会进行隐式转化的； const score = \u0026#34;100\u0026#34;;if (score \u0026gt; 90) { console.log(\u0026#34;优秀\u0026#34;);} \u0026lt;input v-model.number=\u0026#34;age\u0026#34; /\u0026gt; 如果该值无法被 parseFloat() 处理，那么将返回原始值。\nnumber 修饰符会在输入框有 type=\u0026quot;number\u0026quot; 时自动启用。\n.trim 如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符：\n\u0026lt;input v-model.trim=\u0026#34;msg\u0026#34; /\u0026gt; 自定义的修饰符 在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。\n我们来创建一个自定义的修饰符 capitalize，它会自动将 v-model 绑定输入的字符串值第一个字母转为大写：\n\u0026lt;MyComponent v-model.capitalize=\u0026#34;myText\u0026#34; /\u0026gt; 组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象：\n\u0026lt;script\u0026gt; export default { props: { modelValue: String, modelModifiers: { default: () =\u0026gt; ({}) } }, emits: [\u0026#39;update:modelValue\u0026#39;], created() { console.log(this.modelModifiers) // { capitalize: true } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:modelValue\u0026#39;, $event.target.value)\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 注意这里组件的 modelModifiers prop 包含了 capitalize 且其值为 true，因为它在模板中的 v-model 绑定 v-model.capitalize=\u0026quot;myText\u0026quot; 上被使用了。\n有了这个 prop，我们就可以检查 modelModifiers 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 \u0026lt;input /\u0026gt; 元素触发 input 事件时将值的首字母大写：\n\u0026lt;script\u0026gt; export default { props: { modelValue: String, modelModifiers: { default: () =\u0026gt; ({}) } }, emits: [\u0026#39;update:modelValue\u0026#39;], methods: { emitValue(e) { let value = e.target.value if (this.modelModifiers.capitalize) { value = value.charAt(0).toUpperCase() + value.slice(1) } this.$emit(\u0026#39;update:modelValue\u0026#39;, value) } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;modelValue\u0026#34; @input=\u0026#34;emitValue\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 多个 v-model 绑定 我们可以在单个组件实例上创建多个 v-model 双向绑定。\n组件上的每一个 v-model 都会同步不同的 prop，而无需额外的选项：\n\u0026lt;UserName v-model:first-name=\u0026#34;first\u0026#34; v-model:last-name=\u0026#34;last\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; export default { props: { firstName: String, lastName: String }, emits: [\u0026#39;update:firstName\u0026#39;, \u0026#39;update:lastName\u0026#39;] } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;firstName\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:firstName\u0026#39;, $event.target.value)\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;lastName\u0026#34; @input=\u0026#34;$emit(\u0026#39;update:lastName\u0026#39;, $event.target.value)\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 生命周期 什么是生命周期? 什么是生命周期呢？\n每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程； 在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服 务器数据）； 生命周期函数：\n生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调； 通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段； 那么我们就可以在该生命周期中编写属于自己的逻辑代码了； 注册周期钩子 举例来说，mounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码：\nexport default { mounted() { console.log(`the component is now mounted.`) } } 还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 mounted、updated 和 unmounted。\n所有生命周期钩子函数的 this 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 this 获取组件实例。\n组件的生命周期 https://cn.vuejs.org/api/options-lifecycle.html#options-lifecycle\nbeforeCreate( )——准备创建 created( )——创建完成 beforeMount( )—挂载之前 mounted( )——挂载完成 beforeUpdate( )——更新之前 updated( )——更新完成 activated( )——当组件在 keep-alive 内被切换的时候它的 monnted( ) 被取代为activated deactivated( )——当组件在 keep-alive 内被切换的时候它的 unmonnted( ) 被取代为deactivated beforeUnmount( )—卸载之前 unmounted( )——卸载完成 errorCaptured——返回子孙组件中的错误 renderTracked——虚拟 DOM 重新渲染时调用。接收 debugger event 作为参数。告诉你哪个操作跟踪了组件以及该操作的目标对象和键。 renderTiggered——虚拟 DOM 重新渲染被触发时调用。接收 debugger event 作为参数。告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeMessage\u0026#34;\u0026gt;修改message\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: \u0026#34;Hello Home\u0026#34; } }, methods: { changeMessage() { this.message = \u0026#34;你好啊, 李银河\u0026#34; } }, beforeCreate() { console.log(\u0026#34;home beforeCreate\u0026#34;); }, created() { console.log(\u0026#34;home created\u0026#34;); }, beforeMount() { console.log(\u0026#34;home beforeMount\u0026#34;); }, mounted() { console.log(\u0026#34;home mounted\u0026#34;); }, beforeUnmount() { console.log(\u0026#34;home beforeUnmount\u0026#34;); }, unmounted() { console.log(\u0026#34;home unmounted\u0026#34;); }, beforeUpdate() { console.log(this.$refs.title.innerHTML); console.log(\u0026#34;home beforeUpdate\u0026#34;); }, updated() { console.log(this.$refs.title.innerHTML); console.log(\u0026#34;home updated\u0026#34;); } } \u0026lt;/script\u0026gt; Mixins，Extends以及组合式函数 认识 Mixin 在 Vue 2 中，mixins 是创建可重用组件逻辑的主要方式。尽管在 Vue 3 中保留了 mixins 支持，但对于组件间的逻辑复用，使用组合式 API 的组合式函数是现在更推荐的方式。\n目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。 在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成： Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能； 一个Mixin对象可以包含任何组件选项； 当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中； 基本使用 mixins 选项接受一个 mixin 对象数组。这些 mixin 对象可以像普通的实例对象一样包含实例选项，它们将使用一定的选项合并逻辑与最终的选项进行合并。举例来说，如果你的 mixin 包含了一个 created 钩子，而组件自身也有一个，那么这两个函数都会被调用。\nMixin 钩子的调用顺序与提供它们的选项顺序相同，且会在组件自身的钩子前被调用。\ninterface ComponentOptions { mixins?: ComponentOptions[] } \u0026lt;!-- App.vue --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;foo\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { demoMixin } from \u0026#39;./mixins/demoMixin\u0026#39;; export default { mixins: [demoMixin], data() { return { title: \u0026#34;Hello World\u0026#34; } }, methods: { } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; // ./mixins/demoMixin.js export const demoMixin = { data() { return { message: \u0026#34;Hello DemoMixin\u0026#34; } }, methods: { foo() { console.log(\u0026#34;demo mixin foo\u0026#34;); } }, created() { console.log(\u0026#34;执行了demo mixin created\u0026#34;); } } Mixin的合并规则 如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？ 这里分成不同的情况来进行处理； 情况一：如果是data函数的返回值对象 返回值对象默认情况下会进行合并； 如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据； 情况二：如何生命周期钩子函数 生命周期的钩子函数会被合并到数组中，都会被调用； 情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。 比如都有methods选项，并且都定义了方法，那么它们都会生效； 但是如果对象的key相同，那么会取组件对象的键值对； 全局混入 Mixin 如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin：\n全局的Mixin可以使用 应用app的方法 mixin 来完成注册； 一旦注册，那么全局混入的选项将会影响每一个组件； const app = createApp(App); app.mixin({ data() { return {} }, methods: { }, created() { console.log(\u0026#34;全局的created生命周期\u0026#34;); } }); app.mount(\u0026#34;#app\u0026#34;); externds 另外一个类似与Mixin的方式是通过extends属性 允许声明拓展另外一个组件，类似与Mixins； 使一个组件可以继承另一个组件的组件选项。\n从实现角度来看，extends 几乎和 mixins 相同。通过 extends 指定的组件将会当作第一个 mixin 来处理。\n然而，extends 和 mixins 表达的是不同的目标。mixins 选项基本用于组合功能，而 extends 则一般更关注继承关系。\n同 mixins 一样，所有选项 (setup() 除外) 都将使用相关的策略进行合并。\nconst CompA = { ... } const CompB = { extends: CompA, ... } \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; Home Page \u0026lt;h2\u0026gt;{{title}}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;bar\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import BasePage from \u0026#39;./BasePage.vue\u0026#39;; export default { extends: [BasePage], data() { return { content: \u0026#34;Hello Home\u0026#34; } } } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; extends 是为选项式 API 设计的，不会处理 setup() 钩子的合并。\n在组合式 API 中，逻辑复用的首选模式是“组合”而不是“继承”。如果一个组件中的逻辑需要复用，考虑将相关逻辑提取到组合式函数中。\n如果你仍然想要通过组合式 API 来“继承”一个组件，可以在继承组件的 setup() 中调用基类组件的 setup()：\nimport Base from \u0026#39;./Base.js\u0026#39; export default { extends: Base, setup(props, ctx) { return { ...Base.setup(props, ctx), // 本地绑定 } } } 组合式函数 https://cn.vuejs.org/guide/reusability/composables.html\n什么是“组合式函数”？ 在 Vue 应用的概念中，“组合式函数”(Composables) 是一个利用 Vue 的组合式 API 来封装和复用有状态逻辑的函数。\n当构建前端应用时，我们常常需要复用公共任务的逻辑。例如为了在不同地方格式化时间，我们可能会抽取一个可复用的日期格式化函数。这个函数封装了无状态的逻辑：它在接收一些输入后立刻返回所期望的输出。复用无状态逻辑的库有很多，比如你可能已经用过的 lodash 或是 date-fns。\n相比之下，有状态逻辑负责管理会随时间而变化的状态。一个简单的例子是跟踪当前鼠标在页面中的位置。在实际应用中，也可能是像触摸手势或与数据库的连接状态这样的更复杂的逻辑。\n鼠标跟踪器示例 如果我们要直接在组件中使用组合式 API 实现鼠标跟踪功能，它会是这样的：\n\u0026lt;script setup\u0026gt; import { ref, onMounted, onUnmounted } from \u0026#39;vue\u0026#39; const x = ref(0) const y = ref(0) function update(event) { x.value = event.pageX y.value = event.pageY } onMounted(() =\u0026gt; window.addEventListener(\u0026#39;mousemove\u0026#39;, update)) onUnmounted(() =\u0026gt; window.removeEventListener(\u0026#39;mousemove\u0026#39;, update)) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt;Mouse position is at: {{ x }}, {{ y }}\u0026lt;/template\u0026gt; 但是，如果我们想在多个组件中复用这个相同的逻辑呢？我们可以把这个逻辑以一个组合式函数的形式提取到外部文件中：\n// mouse.js import { ref, onMounted, onUnmounted } from \u0026#39;vue\u0026#39; // 按照惯例，组合式函数名以“use”开头 export function useMouse() { // 被组合式函数封装和管理的状态 const x = ref(0) const y = ref(0) // 组合式函数可以随时更改其状态。 function update(event) { x.value = event.pageX y.value = event.pageY } // 一个组合式函数也可以挂靠在所属组件的生命周期上 // 来启动和卸载副作用 onMounted(() =\u0026gt; window.addEventListener(\u0026#39;mousemove\u0026#39;, update)) onUnmounted(() =\u0026gt; window.removeEventListener(\u0026#39;mousemove\u0026#39;, update)) // 通过返回值暴露所管理的状态 return { x, y } } 下面是它在组件中使用的方式：\n\u0026lt;script setup\u0026gt; import { useMouse } from \u0026#39;./mouse.js\u0026#39; const { x, y } = useMouse() \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt;Mouse position is at: {{ x }}, {{ y }}\u0026lt;/template\u0026gt; 如你所见，核心逻辑完全一致，我们做的只是把它移到一个外部函数中去，并返回需要暴露的状态。和在组件中一样，你也可以在组合式函数中使用所有的组合式 API。现在，useMouse() 的功能可以在任何组件中轻易复用了。\n更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的 API 集合命名为组合式 API。\n举例来说，我们可以将添加和清除 DOM 事件监听器的逻辑也封装进一个组合式函数中：\n// event.js import { onMounted, onUnmounted } from \u0026#39;vue\u0026#39; export function useEventListener(target, event, callback) { // 如果你想的话， // 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素 onMounted(() =\u0026gt; target.addEventListener(event, callback)) onUnmounted(() =\u0026gt; target.removeEventListener(event, callback)) } 有了它，之前的 useMouse() 组合式函数可以被简化为：\n// mouse.js import { ref } from \u0026#39;vue\u0026#39; import { useEventListener } from \u0026#39;./event\u0026#39; export function useMouse() { const x = ref(0) const y = ref(0) useEventListener(window, \u0026#39;mousemove\u0026#39;, (event) =\u0026gt; { x.value = event.pageX y.value = event.pageY }) return { x, y } } 异步状态示例 useMouse() 组合式函数没有接收任何参数，因此让我们再来看一个需要接收一个参数的组合式函数示例。在做异步数据请求时，我们常常需要处理不同的状态：加载中、加载成功和加载失败。\n\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const data = ref(null) const error = ref(null) fetch(\u0026#39;...\u0026#39;) .then((res) =\u0026gt; res.json()) .then((json) =\u0026gt; (data.value = json)) .catch((err) =\u0026gt; (error.value = err)) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div v-if=\u0026#34;error\u0026#34;\u0026gt;Oops! Error encountered: {{ error.message }}\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;data\u0026#34;\u0026gt; Data loaded: \u0026lt;pre\u0026gt;{{ data }}\u0026lt;/pre\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;Loading...\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 如果在每个需要获取数据的组件中都要重复这种模式，那就太繁琐了。让我们把它抽取成一个组合式函数：\n// fetch.js import { ref } from \u0026#39;vue\u0026#39; export function useFetch(url) { const data = ref(null) const error = ref(null) fetch(url) .then((res) =\u0026gt; res.json()) .then((json) =\u0026gt; (data.value = json)) .catch((err) =\u0026gt; (error.value = err)) return { data, error } } 现在我们在组件里只需要：\n\u0026lt;script setup\u0026gt; import { useFetch } from \u0026#39;./fetch.js\u0026#39; const { data, error } = useFetch(\u0026#39;...\u0026#39;) \u0026lt;/script\u0026gt; 接收响应式状态 useFetch() 接收一个静态 URL 字符串作为输入——因此它只会执行一次 fetch 并且就此结束。如果我们想要在 URL 改变时重新 fetch 呢？为了实现这一点，我们需要将响应式状态传入组合式函数，并让它基于传入的状态来创建执行操作的侦听器。\n举例来说，useFetch() 应该能够接收一个 ref：\nconst url = ref(\u0026#39;/initial-url\u0026#39;) const { data, error } = useFetch(url) // 这将会重新触发 fetch url.value = \u0026#39;/new-url\u0026#39; 或者接收一个 getter 函数：\n// 当 props.id 改变时重新 fetch const { data, error } = useFetch(() =\u0026gt; `/posts/${props.id}`) 我们可以用 watchEffect() 和 toValue() API 来重构我们现有的实现：\n// fetch.js import { ref, watchEffect, toValue } from \u0026#39;vue\u0026#39; export function useFetch(url) { const data = ref(null) const error = ref(null) const fetchData = () =\u0026gt; { // reset state before fetching.. data.value = null error.value = null fetch(toValue(url)) .then((res) =\u0026gt; res.json()) .then((json) =\u0026gt; (data.value = json)) .catch((err) =\u0026gt; (error.value = err)) } watchEffect(() =\u0026gt; { fetchData() }) return { data, error } } toValue() 是一个在 3.3 版本中新增的 API。它的设计目的是将 ref 或 getter 规范化为值。如果参数是 ref，它会返回 ref 的值；如果参数是函数，它会调用函数并返回其返回值。否则，它会原样返回参数。它的工作方式类似于 unref()，但对函数有特殊处理。\n注意 toValue(url) 是在 watchEffect 回调函数的内部调用的。这确保了在 toValue() 规范化期间访问的任何响应式依赖项都会被侦听器跟踪。\n这个版本的 useFetch() 现在能接收静态 URL 字符串、ref 和 getter，使其更加灵活。watch effect 会立即运行，并且会跟踪 toValue(url) 期间访问的任何依赖项。如果没有跟踪到依赖项（例如 url 已经是字符串），则 effect 只会运行一次；否则，它将在跟踪到的任何依赖项更改时重新运行。\n约定和最佳实践 命名 组合式函数约定用驼峰命名法命名，并以“use”作为开头。\n输入参数 即便不依赖于 ref 或 getter 的响应性，组合式函数也可以接收它们作为参数。如果你正在编写一个可能被其他开发者使用的组合式函数，最好处理一下输入参数是 ref 或 getter 而非原始值的情况。可以利用 toValue() 工具函数来实现：\nimport { toValue } from \u0026#39;vue\u0026#39; function useFeature(maybeRefOrGetter) { // 如果 maybeRefOrGetter 是一个 ref 或 getter， // 将返回它的规范化值。 // 否则原样返回。 const value = toValue(maybeRefOrGetter) } 如果你的组合式函数在输入参数是 ref 或 getter 的情况下创建了响应式 effect，为了让它能够被正确追踪，请确保要么使用 watch() 显式地监视 ref 或 getter，要么在 watchEffect() 中调用 toValue()。\n前面讨论过的 useFetch() 实现提供了一个接受 ref、getter 或普通值作为输入参数的组合式函数的具体示例。\n返回值 你可能已经注意到了，我们一直在组合式函数中使用 ref() 而不是 reactive()。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：\n// x 和 y 是两个 ref const { x, y } = useMouse() 从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。\n如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 reactive() 包装一次，这样其中的 ref 会被自动解包，例如：\nconst mouse = reactive(useMouse()) // mouse.x 链接到了原来的 x ref console.log(mouse.x) Mouse position is at: {{ mouse.x }}, {{ mouse.y }} 副作用 在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：\n如果你的应用用到了服务端渲染 (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：onMounted()。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。 确保在 onUnmounted() 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 onUnmounted() 中被移除 (就像我们在 useMouse() 示例中看到的一样)。当然也可以像之前的 useEventListener() 示例那样，使用一个组合式函数来自动帮你做这些事。 使用限制 组合式函数只能在 \u0026lt;script setup\u0026gt; 或 setup() 钩子中被调用。在这些上下文中，它们也只能被同步调用。在某些情况下，你也可以在像 onMounted() 这样的生命周期钩子中调用它们。\n这些限制很重要，因为这些是 Vue 用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能：\n将生命周期钩子注册到该组件实例上 将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。 \u0026lt;script setup\u0026gt; 是唯一在调用 await 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。\n通过抽取组合式函数改善代码结构 抽取组合式函数不仅是为了复用，也是为了代码组织。随着组件复杂度的增高，你可能会最终发现组件多得难以查询和理解。组合式 API 会给予你足够的灵活性，让你可以基于逻辑问题将组件代码拆分成更小的函数：\n\u0026lt;script setup\u0026gt; import { useFeatureA } from \u0026#39;./featureA.js\u0026#39; import { useFeatureB } from \u0026#39;./featureB.js\u0026#39; import { useFeatureC } from \u0026#39;./featureC.js\u0026#39; const { foo, bar } = useFeatureA() const { baz } = useFeatureB(foo) const { qux } = useFeatureC(baz) \u0026lt;/script\u0026gt; 在某种程度上，你可以将这些提取出的组合式函数看作是可以相互通信的组件范围内的服务。\n在选项式 API 中使用组合式函数 如果你正在使用选项式 API，组合式函数必须在 setup() 中调用。且其返回的绑定必须在 setup() 中返回，以便暴露给 this 及其模板：\nimport { useMouse } from \u0026#39;./mouse.js\u0026#39; import { useFetch } from \u0026#39;./fetch.js\u0026#39; export default { setup() { const { x, y } = useMouse() const { data, error } = useFetch(\u0026#39;...\u0026#39;) return { x, y, data, error } }, mounted() { // setup() 暴露的属性可以在通过 `this` 访问到 console.log(this.x) } // ...其他选项 } 对比 Composition API Options API的弊端 在Vue2中，我们编写组件的方式是Options API：\nOptions API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子； 但是这种代码有一个很大的弊端：\n当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； 下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：\n这种碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题； 并且当我们处理单个逻辑关注点时，需要不断的跳到相应的代码块中； 如果我们能将同一个逻辑关注 点相关的代码收集在一起会更 好。 这就是Composition API想 要做的事情，以及可以帮助我 们完成的事情。 也有人把Vue Composition API简称为VCA。 我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。 认识 组合式 API (Composition API) https://cn.vuejs.org/guide/extras/composition-api-faq.html#what-is-composition-api\n组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：\n响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。 生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。 依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。 组合式 API 是 Vue 3 及 Vue 2.7 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 @vue/composition-api。在 Vue 3 中，组合式 API 基本上都会配合 `` 语法在单文件组件中使用。下面是一个使用组合式 API 的组件示例：\n\u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39; // 响应式状态 const count = ref(0) // 更改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() =\u0026gt; { console.log(`计数器初始值为 ${count.value}。`) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;点击了：{{ count }} 次\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 虽然这套 API 的风格是基于函数的组合，但组合式 API 并不是函数式编程。组合式 API 是以 Vue 中数据可变的、细粒度的响应性系统为基础的，而函数式编程通常强调数据不可变。\nsetup() 以下的代码 均会采用选项式的写法, 组合式 Api 的写法可以参考官方文档, 但基本原理差不多, 而且 Vue3 选项式写法是基于组合式写法产生的!\nsetup() 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：\n需要在非单文件组件中使用组合式 API 时。 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。 setup函数的参数 主要有两个参数: 第一个参数：props 第二个参数：context setup 函数的第一个参数是组件的 props。和标准的组件一致，一个 setup 函数的 props 是响应式的，并且会在传入新的 props 时同步更新。： 对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义； 并且在template中依然是可以正常去使用props中的属性，比如message； 如果我们在setup函数中想要使用props，那么不可以通过 this 去获取 \u0026lt;!-- 推荐使用以下写法 --\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) // 返回值会暴露给模板和其他的选项式 API 钩子 return { count } }, mounted() { console.log(this.count) // 0 } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 当然也可以使用以下写法 --\u0026gt; \u0026lt;script\u0026gt; export default { props: { message: { type: String, required: true } }, data() { return { counter: 100 } }, setup(props, ....){ ..... } ... } \u0026lt;/script\u0026gt; setup 函数的第一个参数是组件的 props。和标准的组件一致，一个 setup 函数的 props 是响应式的，并且会在传入新的 props 时同步更新。 export default { props: { title: String }, setup(props) { console.log(props.title) } } 请注意如果你解构了 props 对象，解构出的变量将会丢失响应性。因此我们推荐通过 props.xxx 的形式来使用其中的 props。\n如果你确实需要解构 props 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 toRefs() 和 toRef() 这两个工具函数：\nimport { toRefs, toRef } from \u0026#39;vue\u0026#39; export default { setup(props) { // 将 `props` 转为一个其中全是 ref 的对象，然后解构 const { title } = toRefs(props) // `title` 是一个追踪着 `props.title` 的 ref console.log(title.value) // 或者，将 `props` 的单个属性转为一个 ref const title = toRef(props, \u0026#39;title\u0026#39;) } } 另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性： attrs：所有的非prop的attribute； slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）； emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）； export default { setup(props, context) { // 透传 Attributes（非响应式的对象，等价于 $attrs） console.log(context.attrs) // 插槽（非响应式的对象，等价于 $slots） console.log(context.slots) // 触发事件（函数，等价于 $emit） console.log(context.emit) // 暴露公共属性（函数） console.log(context.expose) } // 该上下文对象是非响应式的，可以安全地解构： setup(props, {attrs, slots, emit}) { console.log(props.message); console.log(attrs.id, attrs.class); console.log(slots); console.log(emit); } } attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外还需注意，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。\n代码示例\n\u0026lt;template\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34; class=\u0026#34;app-attr\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 使用接受过来的参数 --\u0026gt; {{ msg }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, // 组件接受的参数 props: { msg: String }, // 发射的事件这里可以标注一下 emits:[\u0026#39;change\u0026#39;], setup(props, context) { // 这样可以拿到传递过来的msg的值 console.log(props.msg); // attrs console.log(context.attrs); // 发射事件 context.emit(\u0026#39;change\u0026#39;); } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; setup函数的返回值 setup 也可以返回一个渲染函数，此时在渲染函数中可以直接使用在同一作用域下声明的响应式状态：\nimport { h, ref } from \u0026#39;vue\u0026#39; export default { setup() { const count = ref(0) return () =\u0026gt; h(\u0026#39;div\u0026#39;, count.value) } } 返回一个渲染函数将会阻止我们返回其他东西。对于组件内部来说，这样没有问题，但如果我们想通过模板引用将这个组件的方法暴露给父组件，那就有问题了。\n我们可以通过调用 expose() 解决这个问题：\nimport { h, ref } from \u0026#39;vue\u0026#39; export default { setup(props, { expose }) { const count = ref(0) const increment = () =\u0026gt; ++count.value expose({ increment }) return () =\u0026gt; h(\u0026#39;div\u0026#39;, count.value) } } 此时父组件可以通过模板引用来访问这个 increment 方法。\nexport default { props: { message: { type: String, required: true } }, setup() { let counter = 100; // 局部函数 const increment = () =\u0026gt; { counter++; console.log(counter); } return { title: \u0026#34;Hello Home\u0026#34;, counter, increment } } } setup的返回值可以在模板template中被使用 也就是说可以通过setup的返回值来替代data选项 最后导出的一定要是个对象\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 使用导出的变量 --\u0026gt; \u0026lt;h1\u0026gt;{{ count }}\u0026lt;/h1\u0026gt; \u0026lt;!-- 使用导出的方法 --\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+ 1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { // 定义普通的变量，可以被正常使用 // 缺点 : 数据不是响应式的 let count = 100; // 定义方法 const increment = () =\u0026gt; { count++; console.log(count); }; // 导出 return { count, increment }; } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 因为只是定义了个变量，然后导出了，并没有使它响应式\n补充: 为什么 setup 不能使用 this 在Vue 3中，setup函数是用来替代以前的 data, computed, methods等选项的。setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。\n定义响应式数据的两种方式 Reactive API 如果想为在setup中定义的数据提供响应式的特性，那么可以使用reactive的函数\nps : 如果传入一个基本数据类型（String、Number、Boolean）会报一个警告\n应用场景 : reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型，最好相互有关联的数据时使用\n比如说想要上面的例子实现响应式, 我们可以做如下操作\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 这样使用即可 --\u0026gt; \u0026lt;h1\u0026gt;{{ state.count }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+ 1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 从vue中导入reactive import { reactive } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { // 使用reactive，会返回一个响应式对象 const state = reactive({ // 在对象中编写自己所需要的属性 count: 100 }); const increment = () =\u0026gt; { // 这样使用 state.count++; console.log(state.count); }; return { // 导出响应式state对象 state, increment }; } }; \u0026lt;/script\u0026gt; Reactive判断的API isProxy : 检查对象是否是由 reactive 或 readonly创建的 proxy isReactive : 检查对象是否是由 reactive创建的响应式代理，如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true isReadonly : 检查对象是否是由 readonly 创建的只读代理 toRaw : 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用） shallowReactive : 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换 (深层还是原生对象)，只响应第一层 shallowReadonly : 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）只检查第一层 import { reactive, readonly, isProxy, isReactive, isReadonly, toRaw, shallowReactive, shallowReadonly } from \u0026#39;vue\u0026#39;; // 创建一个响应式对象 const original = { count: 0 }; const obj = reactive(original); // 检查对象是否是代理对象 console.log(isProxy(obj)); // true // 检查对象是否是由 reactive 创建的响应式代理 console.log(isReactive(obj)); // true // 检查对象是否是由 readonly 创建的只读代理 const ro = readonly(obj); console.log(isReadonly(ro)); // true // 返回 reactive 或 readonly 代理的原始对象 const rawObj = toRaw(obj); // 创建一个浅层响应式代理 const shallowObj = shallowReactive({ nested: { count: 0 } }); // 创建一个浅层只读代理 const shallowRo = shallowReadonly({ nested: { count: 0 } }); 以下是一些名词解释:\n代理对象：在Vue 3中，代理对象是由 reactive 或 readonly 创建的对象的代理，用于跟踪对象的属性的变化。 readonly：readonly 是一个函数，用于创建一个只读的代理对象，该代理对象只能读取属性值，不能修改属性值。 浅层响应式：浅层响应式是指只有对象的第一层属性会被设置为响应式，而嵌套对象的属性不会被设置为响应式。 浅层只读代理：浅层只读代理是指只有对象的第一层属性会被设置为只读，而嵌套对象的属性不会被设置为只读。 import { reactive, readonly, shallowReactive, shallowReadonly } from \u0026#39;vue\u0026#39;; // 创建一个普通对象 const original = { count: 0, nested: { count: 1 } }; // 创建一个响应式代理对象 const reactiveObj = reactive(original); reactiveObj.count = 1; // 可以修改属性值 reactiveObj.nested.count = 2; // 嵌套对象的属性也会被设置为响应式 // 创建一个只读代理对象 const readonlyObj = readonly(original); // readonlyObj.count = 2; // 试图修改只读属性会报错 // readonlyObj.nested.count = 2; // 嵌套对象的属性也是只读的 // 创建一个浅层响应式代理对象 const shallowReactiveObj = shallowReactive(original); shallowReactiveObj.count = 2; // 可以修改属性值 shallowReactiveObj.nested.count = 2; // 嵌套对象的属性不会被设置为响应式 // 创建一个浅层只读代理对象 const shallowReadonlyObj = shallowReadonly(original); shallowReadonlyObj.count = 2; // 试图修改只读属性会报错 shallowReadonlyObj.nested.count = 2; // 嵌套对象的属性不会被设置为只读 Ref API Ref函数 : 定义简单类型的数据，也可以定义复杂类型的数据\n应用场景 : 定义一些简单的数据，或者从接口中获得的数据\nref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值，这就是ref名称的来源 它内部的值是在ref的 value 属性中被维护的 不管传入的是基本类型还是引用类型，都放在.value中 使用的时候是用 .value，但是有两个注意事项:\n在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以并不需要在模板中通过 ref.value 的方式，直接使用即可 在 setup 函数内部，它依然是一个 ref引用， 所以对其进行操作时，依然需要使用 ref.value的方式 基本使用 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;!-- 这样使用即可，不需要使用count.value，会自动解包，取出其中的value --\u0026gt; \u0026lt;h1\u0026gt;{{ count }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+ 1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 从vue中导入ref import { ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { // 使用Ref，会返回一个响应式对象 let count = ref(100); const increment = () =\u0026gt; { // 这样使用,需要使用 .value count.value++; console.log(count.value); }; return { // 直接导出count即可 count, increment }; } }; \u0026lt;/script\u0026gt; Ref自动解包 模板中的解包是浅层的解包，如果我们的代码是下面的方式： 如果我们将ref放到一个reactive的属性当中，那么在模板中使用时，它会自动解包： const count = ref(1) const obj = reactive({ count }) // ref 会被解包 console.log(obj.count === count.value) // true // 会更新 `obj.count` count.value++ console.log(count.value) // 2 console.log(obj.count) // 2 // 也会更新 `count` ref obj.count++ console.log(obj.count) // 3 console.log(count.value) // 3 注意当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包：\nconst books = reactive([ref(\u0026#39;Vue 3 Guide\u0026#39;)]) // 这里需要 .value console.log(books[0].value) const map = reactive(new Map([[\u0026#39;count\u0026#39;, ref(0)]])) // 这里需要 .value console.log(map.get(\u0026#39;count\u0026#39;).value) Ref判断的API isRef : 判断值是否是一个ref对象 unref : 如果我们想要获取一个ref引用中的value，那么也可以通过unref方法 如果参数是一个 ref，则返回内部值，否则返回参数本身 这是 val = isRef(val) ? val.value : val 的语法糖函数 shallowRef：shallowRef 是用来创建一个浅层的 ref 对象的函数。浅层的意思是只有对象的第一层属性会被设置为响应式，而嵌套对象的属性不会被设置为响应式。这意味着对嵌套对象属性的修改不会触发响应。 triggerRef：triggerRef 用于手动触发与 shallowRef 相关联的副作用。当 shallowRef 关联的数据发生变化时，相关的副作用将被触发执行。 import { ref, isRef, unref, shallowRef, triggerRef } from \u0026#39;vue\u0026#39;; // 判断值是否是一个 ref 对象 const count = ref(0); console.log(isRef(count)); // true // 获取 ref 引用中的值 const value = unref(count); // 语法糖函数示例 const val = isRef(count) ? count.value : count; // 创建一个浅层的 ref 对象 const shallowCount = shallowRef({ value: 0 }); shallowCount.value = 1; // 可以直接修改 value 属性 // 手动触发与 shallowRef 相关联的副作用 triggerRef(shallowCount); 自定义Ref =\u0026gt; customRef 创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制： 它需要一个工厂函数，该函数接受 track和 trigger函数作为参数； 并且应该返回一个带有 get和 set 的对象； 这里我们使用一个的案例： 对双向绑定的属性进行debounce(节流)的操作 import { customRef } from \u0026#39;vue\u0026#39;; // 自定义ref export default function(value, delay = 300) { let timer = null; return customRef((track, trigger) =\u0026gt; { return { get() { track(); return value; }, set(newValue) { clearTimeout(timer); timer = setTimeout(() =\u0026gt; { value = newValue; trigger(); }, delay); } } }) } \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input v-model=\u0026#34;message\u0026#34;/\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import debounceRef from \u0026#39;./hook/useDebounceRef\u0026#39;; export default { setup() { const message = debounceRef(\u0026#34;Hello World\u0026#34;); return { message } } } \u0026lt;/script\u0026gt; readonly 概念 在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用 readonly了；\n只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 reactive() 相同，但解包得到的值是只读的。 要避免深层级的转换行为，请使用 shallowReadonly() 作替代。 在开发中常见的readonly方法会传入三个类型的参数： 类型一：普通对象 类型二：reactive返回的对象 类型三：ref的对象 在readonly的使用过程中，有如下规则 : readonly返回的对象都是不允许修改的 但是经过readonly处理的原来的对象是允许被修改的 比如 const info = readonly(obj)，info对象是不允许被修改的 当obj被修改时，readonly返回的info对象也会被修改 但是不能去修改readonly返回的对象info \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { reactive, readonly, watchEffect } from \u0026#39;vue\u0026#39; const original = reactive({ count: 0 }) const copy = readonly(original) const btnClick = () =\u0026gt; { original.count++ } watchEffect(() =\u0026gt; { // 用来做响应性追踪 console.log(copy.count) }) // 更改源属性会触发其依赖的侦听器 original.count++ // 更改该只读副本将会失败，并会得到一个警告 copy.count++ // warning! \u0026lt;/script\u0026gt; toRefs \u0026amp;\u0026amp; toRef toRefs 如果使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改结构后的变量，还是修改reactive 返回的state对象，数据都不再是响应式的\n如何改成响应式呢，Vue提供了一个toRefs的函数 可以将reactive返回的对象中的属性都转成ref，这样解构出来的就是响应式的了 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ age }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;+age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 从vue中导入ref import { reactive, ref, readonly, toRefs } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;HelloWorld\u0026#39;, setup() { const info = reactive({ name: \u0026#39;star\u0026#39;, age: 18 }); // 使用toRefs包裹需要结构的reactive对象，这样解构出来的值也是响应式的 let { name, age } = toRefs(info); const increment = () =\u0026gt; { info.age++; // 👆这样都可以修改age，都是响应式的👇 // 相当于已经建立了链接，任何一个修改都会引起另外一个变化 age.value++; console.log(age, info.age); }; return { name, age, increment }; } }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; toRef 如果只希望转换reactive对象中的其中某个属性为ref, 那么可以使用toRef的方法\nps : 这个效率会更高点, 这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化\nlet age = toRef(info, \u0026#34;age\u0026#34;); const changeAge = () =\u0026gt; { age.value++; } computed 在前面的Options API中，我们是使用computed选项来完成的；\n在Composition API中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性；\n如何使用computed呢？\n方式一：接收一个getter函数，并为 getter 函数返回的值，返回一个不变的 ref 对象； 方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象； 方式一 \u0026lt;template\u0026gt; \u0026lt;!-- coderstar --\u0026gt; {{ fullName }} \u0026lt;!-- 一般 --\u0026gt; {{ scoreState }} \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { computed, reactive, ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, setup() { const names = reactive({ firstName: \u0026#39;coder\u0026#39;, lastName: \u0026#39;star\u0026#39; }); // 直接使用getter函数，正常来说都这么使用 const fullName = computed(() =\u0026gt; names.firstName + names.lastName); const score = ref(88); const scoreState = computed(() =\u0026gt; (score.value \u0026gt; 90 ? \u0026#39;优秀\u0026#39; : \u0026#39;一般\u0026#39;)); return { fullName, scoreState }; } }; \u0026lt;/script\u0026gt; 方式二 \u0026lt;template\u0026gt; {{ fullName }} \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;change\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { computed, reactive } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, setup() { const names = reactive({ firstName: \u0026#39;冲啊\u0026#39;, lastName: \u0026#39;迪迦奥特曼\u0026#39; }); // 会返回一个ref对象 const fullName = computed({ set(newValue) { const tempNames = newValue.split(\u0026#39; \u0026#39;); names.firstName = tempNames[0]; names.lastName = tempNames[1]; }, get() { return names.firstName + names.lastName; } }); // 设置值 const changeName = () =\u0026gt; { fullName.value = fullName.value === \u0026#39;冲啊迪迦奥特曼\u0026#39; ? \u0026#39;神秘的 宇宙人\u0026#39; : \u0026#39;冲啊 迪迦奥特曼\u0026#39;; }; return { fullName, changeName }; } }; \u0026lt;/script\u0026gt; 生命周期钩子 https://cn.vuejs.org/api/composition-api-lifecycle.html\nsetup中可以直接使用导入的onX函数注册生命周期，并且同一个生命周期可以使用多次\n所有罗列在本页的 API 都应该在组件的 setup() 阶段被同步调用。相关细节请看指南 - 生命周期钩子。\n可以使用直接导入的 onX 函数注册生命周期钩子； beforeCreate和create在setup中没有相对应的onX的函数 如果想要在beforeCreate和create中进行操作 可以把代码直接写入到setup中 setup的执行时序比beforeCreate和create还要早 import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from \u0026#39;vue\u0026#39;; // 注册生命周期钩子 export default { setup() { onBeforeMount(() =\u0026gt; { console.log(\u0026#39;Before Mount\u0026#39;); // 组件挂载前 }); onMounted(() =\u0026gt; { console.log(\u0026#39;Mounted\u0026#39;); // 组件挂载后 }); onBeforeUpdate(() =\u0026gt; { console.log(\u0026#39;Before Update\u0026#39;); // 组件更新前 }); onUpdated(() =\u0026gt; { console.log(\u0026#39;Updated\u0026#39;); // 组件更新后 }); onBeforeUnmount(() =\u0026gt; { console.log(\u0026#39;Before Unmount\u0026#39;); // 组件卸载前 }); onUnmounted(() =\u0026gt; { console.log(\u0026#39;Unmounted\u0026#39;); // 组件卸载后 }); // 同一个生命周期可以使用多次 onMounted(() =\u0026gt; { console.log(\u0026#39;Another Mounted\u0026#39;); // 另一个组件挂载后 }); return {}; } }; setup中使用ref获取元素或组件 要定义一个ref对象，绑定到元素或者组件的ref属性上即可\n只有在挂载完成后才能拿到值, 所以需要在生命周期中调用拿值\n获取元素 \u0026lt;template\u0026gt; \u0026lt;!-- 1. 指定ref --\u0026gt; \u0026lt;h2 ref=\u0026#34;titleRef\u0026#34;\u0026gt;我是迪迦\u0026lt;/h2\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, setup() { // 2. 生成ref对象 const titleRef = ref(); // 4. 可以在生命周期中获取到值 onMounted(() =\u0026gt; { console.log(titleRef.value); // \u0026lt;h2\u0026gt;我是迪迦\u0026lt;/h2\u0026gt; }); return { // 3. 返回出去，会自动匹配到对应的ref的 titleRef }; } }; \u0026lt;/script\u0026gt; 获取组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;我是子组件\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;home-layout\u0026#39;, setup() { const showMessage = () =\u0026gt; { console.log(\u0026#39;home-layout function exection\u0026#39;); }; return { showMessage }; } }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 1. 指定ref --\u0026gt; \u0026lt;home ref=\u0026#34;homeCompRef\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; import home from \u0026#39;./home.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { home }, setup() { // 2. 生成ref对象 const homeCompRef = ref(); // 4. 可以在生命周期中获取到值 onMounted(() =\u0026gt; { console.log(homeCompRef.value); // proxy对象 console.log(homeCompRef.value.$el); // \u0026lt;div\u0026gt;我是子组件\u0026lt;/div\u0026gt; homeCompRef.value.showMessage(); // 调用子组件方法 }); return { // 3. 返回出去，会自动匹配到对应的ref的 homeCompRef }; } }; \u0026lt;/script\u0026gt; 侦听数据的变化 在前面的Options API中，我们可以通过watch选项来侦听data或者props的数据变化，当数据变化时执行某一些 操作。\n在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听；\nwatchEffect用于自动收集响应式数据的依赖； watch需要手动指定侦听的数据源； watchEffect 基本使用 自动收集响应式数据的依赖 watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖 只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ name }} - {{ age }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;changeName\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;changeAge\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { let name = ref(\u0026#39;star\u0026#39;); let age = ref(18); const changeName = () =\u0026gt; (name.value === \u0026#39;star\u0026#39; ? (name.value = \u0026#39;xuanyu\u0026#39;) : (name.value = \u0026#39;star\u0026#39;)); const changeAge = () =\u0026gt; age.value++; watchEffect(() =\u0026gt; { // 因为这里只使用了name，所以只会监听name，如果把age也写进来，那么两个都会监听 console.log(\u0026#39;name:\u0026#39;, name.value); }); return { name, age, changeName, changeAge }; } }; \u0026lt;/script\u0026gt; 停止监听 如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可。 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{{ name }} - {{ age }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;changeName\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;changeAge\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { let name = ref(\u0026#39;star\u0026#39;); let age = ref(18); const changeName = () =\u0026gt; (name.value === \u0026#39;star\u0026#39; ? (name.value = \u0026#39;xuanyu\u0026#39;) : (name.value = \u0026#39;star\u0026#39;)); // 获取返回值 const stopWatchEffect = watchEffect(() =\u0026gt; { // 自动监听age console.log(\u0026#39;age:\u0026#39;, age.value); }); const changeAge = () =\u0026gt; { age.value++; if (age.value \u0026gt; 22) { // 停止监听 stopWatchEffect(); } }; return { name, age, changeName, changeAge }; } }; \u0026lt;/script\u0026gt; 清除副作用 什么是清除副作用呢？ 比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器， 或者侦听器侦听函数被再次执行了 那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用； 在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate 当副作用即将重新执行 或者 侦听器被停止 时会执行该函数传入的回调函数； 我们可以在传入的回调函数中，执行一些清除工作； \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{ name }}-{{ age }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeName\u0026#34;\u0026gt;修改name\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;changeAge\u0026#34;\u0026gt;修改age\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { // watchEffect: 自动收集响应式的依赖 const name = ref(\u0026#34;why\u0026#34;); const age = ref(18); const stop = watchEffect((onInvalidate) =\u0026gt; { const timer = setTimeout(() =\u0026gt; { console.log(\u0026#34;网络请求成功~\u0026#34;); }, 2000) // 根据name和age两个变量发送网络请求 onInvalidate(() =\u0026gt; { // 在这个函数中清除额外的副作用 // request.cancel() clearTimeout(timer); console.log(\u0026#34;onInvalidate\u0026#34;); }) console.log(\u0026#34;name:\u0026#34;, name.value, \u0026#34;age:\u0026#34;, age.value); }); const changeName = () =\u0026gt; name.value = name.value === \u0026#34;why\u0026#34; ? \u0026#34;kobe\u0026#34; : \u0026#34;why\u0026#34;; const changeAge = () =\u0026gt; age.value++; return { name, age, changeName, changeAge } } } \u0026lt;/script\u0026gt; watchEffect的执行时机 默认情况下，组件的更新会在副作用函数执行之前： 如果我们希望在副作用函数中获取到元素，是否可行呢？ \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;哈哈哈\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { const title = ref(null); watchEffect(() =\u0026gt; { console.log(title.value); }) return { title } } } \u0026lt;/script\u0026gt; 我们会发现打印结果打印了两次： 这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null； 而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素； 这个时候我们需要改变副作用函数的执行时机； 它的默认值是pre，它会在元素 挂载 或者 更新 之前执行； 所以我们会先打印出来一个空的，当依赖的title发生改变时，就会再次执行一次，打印出元素； 我们可以设置副作用函数的执行时机： pre : 默认值,它会在元素 挂载 或者 更新 之前执行 post : 元素 挂载 或者 更新 之后执行 sync : 强制同步一起执行，效率很低，不推荐 \u0026lt;script\u0026gt; import { ref, watchEffect } from \u0026#39;vue\u0026#39;; export default { setup() { const title = ref(null); watchEffect(() =\u0026gt; { console.log(title.value); }, { flush: \u0026#34;post\u0026#34; }) return { title } } } \u0026lt;/script\u0026gt; Watch watch的API完全等同于组件watch选项的Property： watch需要侦听特定的数据源，并在回调函数中执行副作用； 默认情况下它是惰性的，只有当被侦听的源发 生变化时才会执行回调； 与watchEffect的比较，watch允许我们： 懒执行副作用（第一次不会直接执行）； 更具体的说明当哪些状态发生变化时，触发侦听器的执行； 访问侦听状态变化前后的值； 侦听单个数据源 watch侦听函数的数据源有两种类型：\n一个getter函数：但是该getter函数必须引用可响应式的对象（比如reactive或者ref）； 直接写入一个可响应式的对象，ref（如果是一个 reactive 的对象的侦听, 需要进行某些转换 ）； import { watch, reactive, ref, toRefs } from \u0026#39;vue\u0026#39;; // 一个getter函数引用可响应式的对象 const state = reactive({ count: 0 }); watch( () =\u0026gt; state.count, (newValue, oldValue) =\u0026gt; { console.log(`Count changed from ${oldValue} to ${newValue}`); }); // 直接写入一个可响应式的对象 const count = ref(0); watch(count, (newValue, oldValue) =\u0026gt; { console.log(`Count changed from ${oldValue} to ${newValue}`); }); // 直接写入一个可响应式的对象，需要进行某些转换 const reactiveState = reactive({ count: 0 }); const { count } = toRefs(reactiveState); watch(count, (newValue, oldValue) =\u0026gt; { console.log(`Count changed from ${oldValue} to ${newValue}`); }); 注意: reactive对象获取到的 newValue以及 oldValue本身都是 reactive 对象\nwatch( info, (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) 如果希望两者都是一个普通对象, 可以使用以下写法(JavaScript中的展开运算符):\nwatch( () =\u0026gt; ({ ...info }), (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) 以下是完整代码:\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;{{ info.name }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeData\u0026#34;\u0026gt;修改数据\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive, watch } from \u0026#39;vue\u0026#39;; export default { setup() { const info = reactive({ name: \u0026#34;why\u0026#34;, age: 18 }); watch( () =\u0026gt; ({ ...info }), (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) watch( info, (newInfo, oldInfo) =\u0026gt; { console.log(newInfo, oldInfo); } ) const changeData = () =\u0026gt; info.name = info.name === \u0026#34;why\u0026#34; ? \u0026#34;kobe\u0026#34; : \u0026#34;why\u0026#34;; return { changeData, info } } } \u0026lt;/script\u0026gt; 侦听多个数据源 当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：\nwatch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =\u0026gt; { /* ... */ }) \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2 ref=\u0026#34;title\u0026#34;\u0026gt;{{ info.name }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;changeData\u0026#34;\u0026gt;修改数据\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive, watch } from \u0026#39;vue\u0026#39;; export default { setup() { const info = reactive({ name: \u0026#34;why\u0026#34;, age: 18 }); const name = ref(\u0026#34;why\u0026#34;); watch([() =\u0026gt; ({ ...info }), name], ([newInfo, newName], [oldInfo, oldName]) =\u0026gt; { console.log(newInfo, newName, oldInfo, oldName); }) const changeData = () =\u0026gt; { info.name = \u0026#34;kobe\u0026#34;; } return { changeData, info } } } \u0026lt;/script\u0026gt; watch的选项 deep : 是否深度监听 immediate ： 是否立即执行 watch 侦听 reactive时默认是深度侦听的, 但是在使用 {...info}展开运算符时, 是不会深度监听的, 所以我们要设置 deep: True\nimmediate: 第一次会执行\nwatch( () =\u0026gt; { const obj = { ...info } obj.friend = { ...obj.friend } return obj }, (newValue, oldValue) =\u0026gt; { console.log(newValue, oldValue) }, { // 如果有多层，需要加上deep deep: true, // 立即执行 immediate: true } ) 停止侦听 const stop = watch(source, callback) // 当已不再需要该侦听器时： stop() 副作用清理 watch(id, async (newId, oldId, onCleanup) =\u0026gt; { const { response, cancel } = doAsyncWork(newId) // 当 `id` 变化时，`cancel` 将被调用， // 取消之前的未完成的请求 onCleanup(cancel) data.value = await response }) provide \u0026amp;\u0026amp; inject provide 和 inject 通常成对一起使用，使一个祖先组件作为其后代组件的依赖注入方，无论这个组件的层级有多深都可以注入成功，只要他们处于同一条组件链上。\nprovide可以传入两个参数 :\nname：提供的属性名称 value：提供的属性值 inject可以传入两个参数 :\n对应provide传过来的name值 默认值 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt;APP count: {{ count }}\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;change\u0026#34;\u0026gt;APP button\u0026lt;/button\u0026gt; \u0026lt;demo /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, provide, readonly } from \u0026#39;vue\u0026#39; import demo from \u0026#39;./components/demo.vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, components: { demo }, setup() { let count = ref(100) // 第一个参数key 第二个参数值，不让子组件随便修改，用readonly包裹一下 provide(\u0026#39;count\u0026#39;, readonly(count)) const change = () =\u0026gt; count.value++ return { count, change } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;h2\u0026gt;demo count:{{ count }}\u0026lt;/h2\u0026gt; \u0026lt;button @click=\u0026#34;change\u0026#34;\u0026gt;demo change\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, inject } from \u0026#39;vue\u0026#39; export default { setup() { // 接收 第二个参数可以给一个默认值 let count = inject(\u0026#39;count\u0026#39;, \u0026#39;\u0026#39;) // 因为设置了readOnly 所以更改不了 const change = () =\u0026gt; count.value++ return { count, change } } } \u0026lt;/script\u0026gt; h函数 Vue在生成真实的DOM之前，会将节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM ( VDOM ) 事实上，编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode 那么，如果想充分的利用JavaScript的编程能力，可以自己来编写 createVNode 函数，生成对应的VNode h() 函数是一个用于创建 vnode 的一个函数 其实更准备的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数 参数 // 完整参数签名 function h( type: string | Component, props?: object | null, children?: Children | Slot | Slots ): VNode // 省略 props function h(type: string | Component, children?: Children | Slot): VNode type Children = string | number | boolean | VNode | null | Children[] type Slot = () =\u0026gt; Children type Slots = { [name: string]: Slot } 第一个参数既可以是一个字符串 (用于原生元素) 也可以是一个 Vue 组件定义。第二个参数是要传递的 prop，第三个参数是子节点。 当创建一个组件的 vnode 时，子节点必须以插槽函数进行传递。如果组件只有默认槽，可以使用单个插槽函数进行传递。否则，必须以插槽函数的对象形式来传递。 为了方便阅读，当子节点不是插槽对象时，可以省略 prop 参数。 基本使用 h函数可以在两个地方使用：\nrender函数选项中； setup函数选项中（setup本身需要是一个函数类型，函数再返回h函数创建的VNode）； 在render函数选项中 \u0026lt;script\u0026gt; // 1. 引入h函数 import { h } from \u0026#39;vue\u0026#39;; export default { data() { return { counter: 0 }; }, // 2. 定义render选项 render() { // 3. 返回自定义的h函数 return h(\u0026#39;div\u0026#39;, { class: \u0026#39;app-view\u0026#39;, name: \u0026#39;abc\u0026#39; }, [ // 4. 定义h2 h(\u0026#39;h2\u0026#39;, { className: \u0026#39;title\u0026#39; }, this.counter), // 5. 定义增加按钮 h( \u0026#39;button\u0026#39;, { className: \u0026#39;add-btn\u0026#39;, onClick: () =\u0026gt; { this.counter++; } }, \u0026#39;加一\u0026#39; ), // 6. 定义减少按钮 h( \u0026#39;button\u0026#39;, { className: \u0026#39;remove-btn\u0026#39;, onClick: () =\u0026gt; { this.counter--; } }, \u0026#39;减一\u0026#39; ) ]); } } \u0026lt;/script\u0026gt; 在setup函数选项中 \u0026lt;script\u0026gt; import { h, ref } from \u0026#39;vue\u0026#39;; export default { setup() { const counter = ref(0); const increment = () =\u0026gt; { counter.value++; }; const decrement = () =\u0026gt; { counter.value--; }; // 返回render函数 return () =\u0026gt; h(\u0026#39;div\u0026#39;, { class: \u0026#39;app-view\u0026#39;, name: \u0026#39;abc\u0026#39; }, [ h(\u0026#39;h2\u0026#39;, { className: \u0026#39;title\u0026#39; }, counter.value), h( \u0026#39;button\u0026#39;, { onClick: increment }, \u0026#39;+1\u0026#39; ), h( \u0026#39;button\u0026#39;, { onClick: decrement }, \u0026#39;-1\u0026#39; ) ]); } }; \u0026lt;/script\u0026gt; 在setup语法糖中 \u0026lt;template\u0026gt; \u0026lt;!-- 2. 使用一下 --\u0026gt; \u0026lt;star-render /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { h, ref } from \u0026#39;vue\u0026#39;; const counter = ref(0); const increment = () =\u0026gt; { counter.value++; }; const decrement = () =\u0026gt; { counter.value--; }; // 1. 拿到render函数 const starRender = () =\u0026gt; h(\u0026#39;div\u0026#39;, { class: \u0026#39;app-view\u0026#39;, name: \u0026#39;abc\u0026#39; }, [ h(\u0026#39;h2\u0026#39;, { className: \u0026#39;title\u0026#39; }, counter.value), h( \u0026#39;button\u0026#39;, { onClick: increment }, \u0026#39;+1\u0026#39; ), h( \u0026#39;button\u0026#39;, { onClick: decrement }, \u0026#39;-1\u0026#39; ) ]); \u0026lt;/script\u0026gt; 其他写法 创建原生元素：\nimport { h } from \u0026#39;vue\u0026#39; // 除了 type 外，其他参数都是可选的 h(\u0026#39;div\u0026#39;) h(\u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }) // attribute 和 property 都可以用于 prop // Vue 会自动选择正确的方式来分配它 h(\u0026#39;div\u0026#39;, { class: \u0026#39;bar\u0026#39;, innerHTML: \u0026#39;hello\u0026#39; }) // class 与 style 可以像在模板中一样 // 用数组或对象的形式书写 h(\u0026#39;div\u0026#39;, { class: [foo, { bar }], style: { color: \u0026#39;red\u0026#39; } }) // 事件监听器应以 onXxx 的形式书写 h(\u0026#39;div\u0026#39;, { onClick: () =\u0026gt; {} }) // children 可以是一个字符串 h(\u0026#39;div\u0026#39;, { id: \u0026#39;foo\u0026#39; }, \u0026#39;hello\u0026#39;) // 没有 prop 时可以省略不写 h(\u0026#39;div\u0026#39;, \u0026#39;hello\u0026#39;) h(\u0026#39;div\u0026#39;, [h(\u0026#39;span\u0026#39;, \u0026#39;hello\u0026#39;)]) // children 数组可以同时包含 vnode 和字符串 h(\u0026#39;div\u0026#39;, [\u0026#39;hello\u0026#39;, h(\u0026#39;span\u0026#39;, \u0026#39;hello\u0026#39;)]) 创建组件：\nimport Foo from \u0026#39;./Foo.vue\u0026#39; // 传递 prop h(Foo, { // 等价于 some-prop=\u0026#34;hello\u0026#34; someProp: \u0026#39;hello\u0026#39;, // 等价于 @update=\u0026#34;() =\u0026gt; {}\u0026#34; onUpdate: () =\u0026gt; {} }) // 传递单个默认插槽 h(Foo, () =\u0026gt; \u0026#39;default slot\u0026#39;) // 传递具名插槽 // 注意，需要使用 `null` 来避免 // 插槽对象被当作是 prop h(MyComponent, null, { default: () =\u0026gt; \u0026#39;default slot\u0026#39;, foo: () =\u0026gt; h(\u0026#39;div\u0026#39;, \u0026#39;foo\u0026#39;), bar: () =\u0026gt; [h(\u0026#39;span\u0026#39;, \u0026#39;one\u0026#39;), h(\u0026#39;span\u0026#39;, \u0026#39;two\u0026#39;)] }) 函数组件和插槽的使用 \u0026lt;script\u0026gt; import { h } from \u0026#34;vue\u0026#34;; export default { render() { return h(\u0026#34;div\u0026#34;, null, [ h(\u0026#34;h2\u0026#34;, null, \u0026#34;Hello World\u0026#34;), this.$slots.default ? this.$slots.default({name: \u0026#34;coderwhy\u0026#34;}): h(\u0026#34;span\u0026#34;, null, \u0026#34;我是HelloWorld的插槽默认值\u0026#34;) ]) } } \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34; scoped\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;template\u0026gt; \u0026lt;starRender /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { h } from \u0026#39;vue\u0026#39;; import HelloWorld from \u0026#39;./HelloWorld.vue\u0026#39;; const starRender = () =\u0026gt; h(\u0026#34;div\u0026#34;, null, [ h(HelloWorld, null, { default: props =\u0026gt; h(\u0026#34;span\u0026#34;, null, `app传入到HelloWorld中的内容: ${props.name}`) }) ]) \u0026lt;/script\u0026gt; Jsx JSX 是 JavaScript 的一个类似 XML 的扩展，有了它，我们可以用以下的方式来书写代码：\nconst vnode = \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt; 在 JSX 表达式中，使用大括号来嵌入动态值：\nconst vnode = \u0026lt;div id={dynamicId}\u0026gt;hello, {userName}\u0026lt;/div\u0026gt; 配置 vue-cli环境 npm install @vue/babel-plugin-jsx -D babel.config.js 中配置 vite环境 npm install @vitejs/plugin-vue-jsx -D vite.config.js 中配置 import { fileURLToPath, URL } from \u0026#39;node:url\u0026#39;; import { defineConfig } from \u0026#39;vite\u0026#39;; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39;; import jsx from \u0026#39;@vitejs/plugin-vue-jsx\u0026#39;; export default defineConfig({ plugins: [vue(), jsx()], resolve: { alias: { \u0026#39;@\u0026#39;: fileURLToPath(new URL(\u0026#39;./src\u0026#39;, import.meta.url)) } } }); 基本使用 在render函数中 \u0026lt;!-- 1. 这里加上注明语言使用jsx --\u0026gt; \u0026lt;script lang=\u0026#34;jsx\u0026#34;\u0026gt; import Home from \u0026#39;./pages/home.vue\u0026#39;; export default { data() { return { counter: 0 }; }, render() { // 2. 返回jsx写法 return ( \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数:{this.counter}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.decrement}\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }, methods: { increment() { this.counter++; }, decrement() { this.counter--; } } }; \u0026lt;/script\u0026gt; 在setup函数中 \u0026lt;!-- 1. 这里加上注明语言使用jsx --\u0026gt; \u0026lt;script lang=\u0026#34;jsx\u0026#34;\u0026gt; export default { data() { return { counter: 0 }; }, render() { // 2. 返回jsx写法 return ( \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数:{this.counter}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={this.increment}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button onClick={this.decrement}\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }, methods: { increment() { this.counter++; }, decrement() { this.counter--; } } }; \u0026lt;/script\u0026gt; 在setup语法糖中 \u0026lt;template\u0026gt; \u0026lt;!-- 3. 使用 --\u0026gt; \u0026lt;star-render /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 1. 这里加上注明语言使用jsx --\u0026gt; \u0026lt;script setup lang=\u0026#34;jsx\u0026#34;\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; const counter = ref(0); const increment = () =\u0026gt; counter.value++; const decrement = () =\u0026gt; counter.value--; // 2. 拿到render函数 const starRender = () =\u0026gt; ( \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;当前计数:{counter.value}\u0026lt;/h2\u0026gt; \u0026lt;button onClick={increment}\u0026gt;+1\u0026lt;/button\u0026gt; \u0026lt;button onClick={decrement}\u0026gt;-1\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); \u0026lt;/script\u0026gt; script setup语法糖 \u0026lt;script setup\u0026gt;是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖，当同时使用 SFC 与组合式 API 时则推荐该语法\n更少的样板内容，更简洁的代码 能够使用纯 Typescript 声明 prop 和抛出事件 更好的运行时性能 更好的 IDE 类型推断性能 顶层的绑定会被暴露给模板 当使用\u0026lt;script setup\u0026gt; 的时候，任何在\u0026lt;script setup\u0026gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 能在模板中直接使用, 导入的组件也可以直接使用\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ mes }}\u0026lt;/div\u0026gt; \u0026lt;button @click=\u0026#34;addClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;!-- 1. 这里加上setup属性 --\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; // 定义数据后，template中可以直接使用，无需返回 const mes = ref(0); // 定义的方法也是，直接可被使用 const addClick = () =\u0026gt; { console.log(\u0026#39;hahah\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 2. 直接使用，不用通过compoents注册 --\u0026gt; \u0026lt;my-home\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // 1. 这是导入的组件 import myHome from \u0026#39;./myHome.vue\u0026#39;; \u0026lt;/script\u0026gt; defineProps() defineProps =\u0026gt; 用来接收从父组件传递过来的数据\n\u0026lt;template\u0026gt; \u0026lt;my-home name=\u0026#34;hello\u0026#34; :age=\u0026#34;18\u0026#34;\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import myHome from \u0026#39;./myHome.vue\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ name }} - {{ age }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // defineProps是内置组件，可以直接使用，不用导入 // 可以接收一下返回的props对象，也可以不用 const props = defineProps({ name: { type: String, default: \u0026#39;\u0026#39; }, age: { type: Number, default: 0 } }); console.log(props); // Proxy {name: \u0026#39;hello\u0026#39;, age: 18} \u0026lt;/script\u0026gt; defineEmits() defineProps =\u0026gt; 用来发射事件给父组件\n\u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;btnClick\u0026#34;\u0026gt;发送\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // 1. 注册一下发射的事件 const emits = defineEmits([\u0026#39;btnClick\u0026#39;]); // 2. 监听按钮的点击 const btnClick = () =\u0026gt; { // 3. 发射 emits(\u0026#39;btnClick\u0026#39;, \u0026#39;我发射了\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 1. 监听子组件发射来的事件 --\u0026gt; \u0026lt;my-home @btnClick=\u0026#34;handleClick\u0026#34;\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import myHome from \u0026#39;./myHome.vue\u0026#39;; // 2. 获取子组件传递过来的值 const handleClick = (message) =\u0026gt; { console.log(message); // 我发射了 }; \u0026lt;/script\u0026gt; defineExpose() defineExpose =\u0026gt; 用来暴露数据\nps : 使用 \u0026lt;script setup\u0026gt;的组件是默认关闭的\n\u0026lt;script setup\u0026gt; const foo = () =\u0026gt; { console.log(\u0026#39;foo\u0026#39;); }; // 暴露出去，才可以被访问到 defineExpose({ foo }); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 1. 定义ref --\u0026gt; \u0026lt;my-home ref=\u0026#34;myHomeRef\u0026#34;\u0026gt;\u0026lt;/my-home\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; import myHome from \u0026#39;../../../Vue3/06_阶段六-Vue3全家桶实战/code/04_learn_composition/src/11_script_setup语法/myHome.vue\u0026#39;; // 2. 定义名称一样 const myHomeRef = ref(); onMounted(() =\u0026gt; { // 3. 在生命周期中访问 console.log(myHomeRef.value); }); \u0026lt;/script\u0026gt; 自定义组件 指令的生命周期 一个指令定义的对象，Vue提供了如下的几个钩子函数： created：在绑定元素的 attribute 或事件监听器被应用之前调用； beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用； mounted：在绑定元素的父组件被挂载后调用； beforeUpdate：在更新包含组件的 VNode 之前调用； updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用； beforeUnmount：在卸载绑定元素的父组件之前调用； unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次； 指令钩子 一个指令的定义对象可以提供几种钩子函数 (都是可选的)：\nconst myDirective = { // 在绑定元素的 attribute 前 // 或事件监听器应用前调用 created(el, binding, vnode, prevVnode) { // 下面会介绍各个参数的细节 }, // 在元素被插入到 DOM 前调用 beforeMount(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都挂载完成后调用 mounted(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件更新前调用 beforeUpdate(el, binding, vnode, prevVnode) {}, // 在绑定元素的父组件 // 及他自己的所有子节点都更新后调用 updated(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载前调用 beforeUnmount(el, binding, vnode, prevVnode) {}, // 绑定元素的父组件卸载后调用 unmounted(el, binding, vnode, prevVnode) {} } 指令的钩子会传递以下几种参数：\nel：指令绑定到的元素。这可以用于直接操作 DOM。 binding：一个对象，包含以下属性。 value：传递给指令的值。例如在 v-my-directive=\u0026quot;1 + 1\u0026quot; 中，值是 2。 oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。 arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 \u0026quot;foo\u0026quot;。 modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。 instance：使用该指令的组件实例。 dir：指令的定义对象。 vnode：代表绑定元素的底层 VNode。 prevNode：代表之前的渲染中指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。 举例来说，像下面这样使用指令：\n\u0026lt;div v-example:foo.bar=\u0026#34;baz\u0026#34;\u0026gt; binding 参数会是一个这样的对象：\n{ arg: \u0026#39;foo\u0026#39;, modifiers: { bar: true }, value: /* `baz` 的值 */, oldValue: /* 上一次更新时 `baz` 的值 */ } 和内置指令类似，自定义指令的参数也可以是动态的。举例来说：\n\u0026lt;div v-example:[arg]=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 这里指令的参数会基于组件的 arg 数据属性响应式地更新。\n除了 el 外，其他参数都是只读的，不要更改它们。若你需要在不同的钩子间共享信息，推荐通过元素的 dataset attribute 实现。\n简单使用 Vue中自带的指令例如v-show、v-for、v-model等等，除了使用这些指令之外，Vue 也允许我们来自定义自己的指令\nps : 一般需要对dom元素进行底层操作时使用\n自定义指令分为两种： 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用； 自定义全局指令：app的 directive 方法，可以在任意组件中被使用； 默认实现方式 一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：\n\u0026lt;script setup\u0026gt; // 在模板中启用 v-focus const vFocus = { mounted: (el) =\u0026gt; el.focus() } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;input v-focus /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; ref=\u0026#34;inputRef\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { onMounted, ref } from \u0026#39;vue\u0026#39;; const inputRef = ref(null); onMounted(() =\u0026gt; { inputRef.value.focus(); }); \u0026lt;/script\u0026gt; 使用局部指令 在 \u0026lt;script setup\u0026gt; 中，任何以 v 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，vFocus 即可以在模板中以 v-focus 的形式使用。\n在没有使用 \u0026lt;script setup\u0026gt; 的情况下，自定义指令需要通过 directives 选项注册：\n\u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-focus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { // 局部指令 directives: { focus: { mounted(el, bindings, vnode, preVnode) { console.log(\u0026#34;focus mounted\u0026#34;); el.focus(); } } } } \u0026lt;/script\u0026gt; 自定义全局指令 main.js中注册 import { createApp } from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; const app = createApp(App) // 指令名称 app.directive(\u0026#39;focus\u0026#39;, { // 使用自定义指令的生命周期，挂载后访问 mounted(el, bindings, vnode, preVnode) { el?.focus() } }) app.mount(\u0026#39;#app\u0026#39;) 进行抽取 注册directives文件夹 /directives/format-time.js import dayjs from \u0026#39;dayjs\u0026#39;; export default function(app) { app.directive(\u0026#34;format-time\u0026#34;, { created(el, bindings) { bindings.formatString = \u0026#34;YYYY-MM-DD HH:mm:ss\u0026#34;; if (bindings.value) { bindings.formatString = bindings.value; } }, mounted(el, bindings) { const textContent = el.textContent; let timestamp = parseInt(textContent); if (textContent.length === 10) { timestamp = timestamp * 1000 } el.textContent = dayjs(timestamp).format(bindings.formatString); } }) } /directives/index.js import registerFormatTime from \u0026#39;./format-time\u0026#39;; export default function registerDirectives(app) { registerFormatTime(app); } mian.js import registerDirectives from \u0026#39;./directives\u0026#39; registerDirectives(app); setup 函数 \u0026lt;template\u0026gt; \u0026lt;h1 v-fomat-time=\u0026#34;timeFormatType\u0026#34;\u0026gt;{{ timeStamp }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref } from \u0026#39;vue\u0026#39; import dayJs from \u0026#39;dayjs\u0026#39; export default { directives: { \u0026#39;fomat-time\u0026#39;: { mounted(el, bindings) { // 默认显示时间类型 let formatType = bindings.value console.log(formatType) // 转换成number类型 let time = el.textContent.length === 10 ? el.textContent * 1000 : el.textContent * 1; // 格式化 el.textContent = dayJs(time).format(formatType) setInterval(() =\u0026gt; { // 定时器 time = dayJs(new Date().valueOf()).format(formatType) el.textContent = time }, 1000) } } }, setup() { // 设置初始时间戳 const timeStamp = ref(new Date().valueOf()) const timeFormatType = ref(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) return { timeStamp, timeFormatType } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-image: linear-gradient(to right, red, blue); } \u0026lt;/style\u0026gt; 语法糖 \u0026lt;template\u0026gt; \u0026lt;h1 v-fomat-time=\u0026#34;timeFormatType\u0026#34;\u0026gt;{{ timeStamp }}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39;; import dayJs from \u0026#39;dayjs\u0026#39;; // 设置初始时间戳 const timeStamp = ref(new Date().valueOf()); // 设置初始时间格式 const timeFormatType = ref(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;); // 自定义时间格式化指令 const vFomatTime = { mounted(el, bindings) { // 获取定义的时间格式 const { value: timeFormatType } = bindings; // 转换成number类型 let time = el.textContent.length === 10 ? el.textContent * 1000 : el.textContent * 1; // 使用dayJs，根据时间格式来格式化时间,并赋值给el el.textContent = dayJs(time).format(timeFormatType); // 定时器，每隔一秒，重新赋值给el setInterval(() =\u0026gt; { time = dayJs(new Date().valueOf()).format(timeFormatType); el.textContent = time; }, 1000); } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, blue); } \u0026lt;/style\u0026gt; 内置组件 Teleport \u0026lt;Teleport\u0026gt; 是一个内置组件，它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。\n在某些情况下，希望组件不是挂载在当前组件树上的，可能是移动到Vue app之外的其他位置 比如移动到body元素上，或者我们有其他的div#app之外的元素上 可以通过teleport来完成 teleport 翻译过来是心灵传输、远距离运输的意思，有两个属性 to : 指定将其中的内容移动到的目标元素，可以使用选择器 disabled : 是否禁用 teleport 的功能 基本使用 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;!-- 把该组件挂载到body元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, green, pink, yellow, blue); } \u0026lt;/style\u0026gt; 挂载到#app之外的指定元素上 \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;star\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;c\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 把该组件挂载到#star元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;#star\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;!-- 把该组件挂载到.b元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;.b\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport123\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;!-- 文档上说是挂载到#app之外的元素，可是我发现自己内部的也可以指定，emmmm，优先是从内部一层层往外找的 --\u0026gt; \u0026lt;!-- 把该组件挂载到.c元素上... --\u0026gt; \u0026lt;teleport to=\u0026#34;.c\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport123\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, green, pink, yellow, blue); } \u0026lt;/style\u0026gt; 多个Teleport 会合并，谁先谁在前面\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;star\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;app-view\u0026#34;\u0026gt; \u0026lt;!-- 把该组件挂载到#star元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;#star\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 把该组件挂载到#star元素上 --\u0026gt; \u0026lt;teleport to=\u0026#34;#star\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Teleport123\u0026lt;/h1\u0026gt; \u0026lt;/teleport\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; h1 { display: inline-block; color: transparent; -webkit-background-clip: text; background-clip: text; background-image: linear-gradient(to right, red, green, pink, yellow, blue); } \u0026lt;/style\u0026gt; 其他 异步组件 defineAsyncComponent/ Suspense : 实验特性\n动态组件 : component\nVue插件 https://cn.vuejs.org/guide/reusability/plugins.html#plugins\n通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式： 对象类型：一个对象，但是必须包含一个 install的函数，该函数会在安装插件时执行； 函数类型：一个function，这个函数会在安装插件时自动执行； 插件可以完成的功能没有限制，比如下面的几种都是可以的： 添加全局方法或者property，通过把它们添加到 config.globalProperties 上实现； 添加全局资源：指令/过滤器/过渡等； 通过全局 mixin来添加一些组件选项； 一个库，提供自己的 API，同时提供上面提到的一个或多个功能； 对象类型 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行\napp.use({ install(app) { console.log(\u0026#39;对象方式，插件被调用了\u0026#39;, app); } }); 函数类型 函数类型：一个function，这个函数会在安装插件时自动执行\napp.use(function(app){ console.log(\u0026#39;函数方式，插件被调用了\u0026#39;, app); }) 改写自定义指令 import { createApp } from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; // 1. 导入指令方法 import installDirectives from \u0026#39;./directives\u0026#39;; // 2。 注册所有指令 // installDirectives(app); // 这样使用use方法注册指令，因为传入的是一个函数，所以会自动执行 // 并且会把app实例传入，这样就可以在函数内部注册指令了 createApp(App).use(installDirectives).mount(\u0026#39;#app\u0026#39;); ","permalink":"https://waite.wang/posts/vue/system-learn-vue-1/","summary":"\u003ch2 id=\"邂逅-vue\"\u003e邂逅 Vue\u003c/h2\u003e\n\u003ch3 id=\"认识-vue\"\u003e认识 Vue\u003c/h3\u003e\n\u003ch4 id=\"什么是-vue\"\u003e什么是 Vue\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。\n\u003cul\u003e\n\u003cli\u003e全程是Vue.js或者Vuejs；\u003c/li\u003e\n\u003cli\u003e什么是渐进式框架呢？表示我们可以在项目中一点点来引入和使用Vue，而不一定需要全部使用Vue来开发整个 项目；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"vue3带来的变化\"\u003eVue3带来的变化\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e源码通过monorepo的形式来管理源代码：\n\u003cul\u003e\n\u003cli\u003eMono：单个\u003c/li\u003e\n\u003cli\u003eRepo：repository仓库\u003c/li\u003e\n\u003cli\u003e主要是将许多项目的代码存储在同一个 repository 中；\u003c/li\u003e\n\u003cli\u003e这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；\u003c/li\u003e\n\u003cli\u003e而且模块划分的更加清晰，可维护性、可扩展性更强；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e源码使用TypeScript来进行重写：\n\u003cul\u003e\n\u003cli\u003e在Vue2.x的时候，Vue使用 Flow 来进行类型检测；\u003c/li\u003e\n\u003cli\u003e在Vue3.x的时候，Vue的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"性能方面\"\u003e性能方面\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e使用Proxy进行数据劫持\n\u003cul\u003e\n\u003cli\u003e在 Vue2.x 的时候，Vue2 是使用 \u003ccode\u003eObject.defineProperty\u003c/code\u003e 来劫持数据的 getter 和 setter 方法的；\u003c/li\u003e\n\u003cli\u003e这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；\u003c/li\u003e\n\u003cli\u003e所以在 Vue2.x 的时候，不得不提供一些特殊的API，比如 \u003ccode\u003e$set\u003c/code\u003e 或 \u003ccode\u003e$delete\u003c/code\u003e ，事实上都是一些 hack 方法，也增加了 开发者学习新的API的成本；\u003c/li\u003e\n\u003cli\u003e而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e删除了一些不必要的API：\n\u003cul\u003e\n\u003cli\u003e移除了实例上的 \u003ccode\u003e$on\u003c/code\u003e , \u003ccode\u003e$off\u003c/code\u003e  和  \u003ccode\u003e$once\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e移除了一些特性：如filter、内联模板等；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e包括编译方面的优化：\n\u003cul\u003e\n\u003cli\u003e生成Block Tree、Slot编译优化、diff算法优化；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"新的api\"\u003e新的API\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e由Options API 到 Composition API：\n\u003cul\u003e\n\u003cli\u003e在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；\u003c/li\u003e\n\u003cli\u003eOptions API 包括data、props、methods、computed、生命周期等等这些选项；\u003c/li\u003e\n\u003cli\u003e存在比较大的问题是多个逻辑可能是在不同的地方：\n\u003cul\u003e\n\u003cli\u003e比如created中会使用某一个method来修改data的数据，代码的内聚性非常差；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eComposition API可以将 相关联的代码 放到同一处 进行处理，而不需要在多个Options之间寻找；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHooks函数增加代码的复用性：\n\u003cul\u003e\n\u003cli\u003e在Vue2.x的时候，我们通常通过mixins在多个组件之间共享逻辑；但是有一个很大的缺陷就是 mixins也是由一大堆的Options组成的，并且多个mixins会存在命名冲突的问题；\u003c/li\u003e\n\u003cli\u003e在Vue3.x中，我们可以通过Hook函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"如何使用-vue\"\u003e如何使用 Vue\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e方式一：在页面中通过CDN的方式来引入；\u003c/li\u003e\n\u003cli\u003e方式二：下载Vue的JavaScript文件，并且自己手动引入；\u003c/li\u003e\n\u003cli\u003e方式三：通过npm包管理工具安装使用它；\u003c/li\u003e\n\u003cli\u003e方式四：直接通过Vue CLI创建项目，并且使用它；\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"cdn-引入\"\u003eCDN 引入\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;https://unpkg.com/vue@next\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"下载和引入\"\u003e下载和引入\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e下载Vue的源码，可以直接打开CDN的链接：\n\u003cul\u003e\n\u003cli\u003e打开链接，复制其中所有的代码；\u003c/li\u003e\n\u003cli\u003e创建一个新的文件，比如vue.js，将代码复制到其中；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-html\" data-lang=\"html\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e \u003cspan class=\"na\"\u003esrc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;../js/vue.js\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u0026lt;/\u003c/span\u003e\u003cspan class=\"nt\"\u003escript\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"声明式编程和命令式编程\"\u003e声明式编程和命令式编程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e原生开发和Vue开发的模式和特点,我们会发现是完全不同的,这里其实涉及到两种不同的编程范式命令式编程和声明式编程\u003c/li\u003e\n\u003cli\u003e命令式编程关注的是“ how to do”,声明式编程关注的是\u0026quot; what to do\u0026quot;,由框架(机器)完成\u0026quot;how\u0026quot;的过程\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"mvvm模型\"\u003eMVVM模型\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eMVC和MVVM都是一种软件的体系结构\n\u003cul\u003e\n\u003cli\u003eMVC是 Model-View-Controller的简称,是在前期被使用非常框架的架构模式,比如iS、前端\u003c/li\u003e\n\u003cli\u003eMVVM是 Model-View- ViewMode的简称,是目前非常流行的架构模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e通常情况下,我们也经常称vue是一个MVVM的框架\n\u003cul\u003e\n\u003cli\u003evue官方其实有说明,vue虽然并没有完全遵守MVVM的模型,但是整个设计是受到它的启发的\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202310161331268.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202310161331268.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e","title":"系统学习 Vue 1"},{"content":"Idea2023.2 创建 Servlet 项目 前期准备 正常创建 Java 项目, 添加框架支持 Web 模块\n2023.2 之后 Idea 新 UI 把添加框架支持移到了 Ctrl + Alt + Shift + S(项目结构) -\u0026gt; 模块 -\u0026gt; + 如果想要之前一样右键添加框架支持, 可以设置 -\u0026gt; 添加按键映射 -\u0026gt; 添加快捷键 -\u0026gt; 之后用快捷键使用即可 项目结构 -\u0026gt; 模块 -\u0026gt; 添加模块\n修改项目结构 配置 Tomcat, 可查看之前文章 开始 在 src 右键创建 Servlet 文件 如果右键new的时候没有servlet? 因为2023版的IDEA已经不支持Servlet了，但是如果还要使用的话，可以自己创建模板使用 设置 -\u0026gt; 编辑器 -\u0026gt; 文件和代码模板 #if (${PACKAGE_NAME} \u0026amp;\u0026amp; ${PACKAGE_NAME} != \u0026#34;\u0026#34;)package ${PACKAGE_NAME};#end #parse(\u0026#34;File Header.java\u0026#34;) import java.io.*; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(\u0026#34;/${Class_Name}\u0026#34;) public class ${Class_Name} extends HttpServlet { private String message; public void init() { } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { } @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException { this.doGet(request, response); } } 简单应用 Hello World\nimport java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\u0026#34;text/html\u0026#34;); resp.getWriter().println(\u0026#34;\u0026lt;h1\u0026gt;Welcome\u0026lt;/h1\u0026gt;\u0026#34;); } } WEB-INF/ web.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;!-- 配置 Servlet --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;helloServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;helloServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 过滤器\nimport java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; @WebFilter(\u0026#34;/*\u0026#34;) public class CharacterEncodingFilter implements Filter { private String encoding; @Override public void init(FilterConfig filterConfig) throws ServletException { encoding = filterConfig.getInitParameter(\u0026#34;encoding\u0026#34;); if (encoding == null) { encoding = \u0026#34;UTF-8\u0026#34;; // 默认使用 UTF-8 编码 } } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(encoding); response.setCharacterEncoding(encoding); chain.doFilter(request, response); } @Override public void destroy() { // 清理资源（如果有需要的话） } } 项目结构如下\n","permalink":"https://waite.wang/posts/jsp/idea-create-project-of-servlet/","summary":"\u003ch2 id=\"idea20232-创建-servlet-项目\"\u003eIdea2023.2 创建 Servlet 项目\u003c/h2\u003e\n\u003ch2 id=\"前期准备\"\u003e前期准备\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e正常创建 Java 项目, 添加框架支持 Web 模块\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e2023.2 之后 Idea 新 UI 把添加框架支持移到了 Ctrl + Alt + Shift + S(项目结构) -\u0026gt; 模块 -\u0026gt; +\u003c/li\u003e\n\u003cli\u003e如果想要之前一样右键添加框架支持, 可以设置 -\u0026gt; 添加按键映射 -\u0026gt; 添加快捷键 -\u0026gt; 之后用快捷键使用即可\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202311021151150.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202311021151150.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e","title":"Idea2023.2 创建 Servlet 项目"},{"content":"JSP 访问数据库 mysql-connector-java的jar包下载 官方下载地址 https://dev.mysql.com/downloads/connector/j/ 解压, 把JDBC驱动放在lib文件夹下（直接复制过来就可以了） 记得导入, 不然会报错\n\u0026lt;%@ page import=\u0026#34;java.sql.*\u0026#34; %\u0026gt; 基本用法 连接MySQL数据库 在JSP中连接MySQL数据库的步骤如下：\n下载并安装MySQL数据库，启动MySQL服务。 在MySQL中创建一个数据库和表，用于存储数据。可以使用MySQL自带的命令行工具或者图形化界面工具，例如phpMyAdmin等。 在JSP中使用JDBC连接MySQL数据库，获取数据库连接对象。 使用数据库连接对象创建Statement或者PreparedStatement对象，执行SQL语句。 处理SQL执行结果，关闭数据库连接。 以下是一个简单的JSP连接MySQL数据库并查询数据的示例代码：\n\u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34;%\u0026gt; \u0026lt;% // 导入JDBC相关的类 \u0026lt;%@ page import=\u0026#34;java.sql.*\u0026#34; %\u0026gt; // 定义数据库连接信息 String url = \u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;; String user = \u0026#34;root\u0026#34;; String password = \u0026#34;123456\u0026#34;; Connection conn = null; Statement stmt = null; ResultSet rs = null; try { // 加载MySQL驱动程序 Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); // 获取数据库连接 conn = DriverManager.getConnection(url, user, password); // 创建Statement对象 stmt = conn.createStatement(); // 执行SQL查询语句 String sql = \u0026#34;SELECT * FROM records\u0026#34;; rs = stmt.executeQuery(sql); // 输出查询结果 while (rs.next()) { out.println(\u0026#34;id: \u0026#34; + rs.getInt(\u0026#34;id\u0026#34;) + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;); out.println(\u0026#34;name: \u0026#34; + rs.getString(\u0026#34;name\u0026#34;) + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;); out.println(\u0026#34;age: \u0026#34; + rs.getInt(\u0026#34;age\u0026#34;) + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;); out.println(\u0026#34;\u0026lt;hr\u0026gt;\u0026#34;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } finally { // 关闭数据库连接 if (rs != null) { rs.close(); } if (stmt != null) { stmt.close(); } if (conn != null) { conn.close(); } } %\u0026gt; 在上面的示例中，我们首先定义了MySQL数据库的连接信息，包括数据库URL、用户名和密码。然后使用Class.forName()方法加载MySQL驱动程序，获取数据库连接对象，并使用createStatement()方法创建Statement对象，执行SQL查询语句，并使用ResultSet对象获取查询结果集，最后遍历结果集输出查询结果。最后，我们在finally代码块中关闭数据库连接。\n需要注意的是，在实际开发中，我们应该将数据库连接信息配置在配置文件中，然后使用Properties对象读取配置文件中的信息，这样可以提高代码的可维护性和安全性。同时，我们也应该尽量避免在JSP页面中直接编写SQL语句，而是应该将数据库操作封装在Java类中，然后在JSP页面中调用这些Java类来执行数据库操作。\n用结果集操作数据库中的表 在JSP中，我们可以使用ResultSet对象来操作数据库中的表，ResultSet对象表示一个结果集，它包含了一组查询结果的数据行。\n在JSP中，我们可以使用ResultSet对象来操作数据库中的表，ResultSet对象表示一个结果集，它包含了一组查询结果的数据行。\n\u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34;%\u0026gt; \u0026lt;% Connection conn = null; Statement stmt = null; ResultSet rs = null; try { // 获取数据库连接 conn = getConnection(); // 创建Statement对象 stmt = conn.createStatement(); // 执行查询语句 String sql = \u0026#34;SELECT * FROM records\u0026#34;; rs = stmt.executeQuery(sql); // 处理查询结果 while (rs.next()) { int id = rs.getInt(\u0026#34;id\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); int age = rs.getInt(\u0026#34;age\u0026#34;); // 输出结果 out.println(\u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#34; + name + \u0026#34;, age=\u0026#34; + age + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;); } } catch (SQLException e) { e.printStackTrace(); } finally { // 关闭数据库连接 if (rs != null) { rs.close(); } if (stmt != null) { stmt.close(); } if (conn != null) { conn.close(); } } %\u0026gt; 在上面的示例中，我们使用了一个名为getConnection()的方法来获取数据库连接，这个方法需要根据具体的数据库类型和配置来实现。另外，我们还使用了Statement对象来执行SQL查询语句，并使用executeQuery()方法获取查询结果的ResultSet对象。然后我们使用ResultSet对象的next()方法逐行读取查询结果，并使用getInt()和getString()等方法获取每一行的数据。\n需要注意的是，在使用ResultSet对象操作数据库时，我们应该尽量避免在JSP页面中直接编写SQL语句，而是应该将数据库操作封装在Java类中，然后在JSP页面中调用这些Java类来执行数据库操作。这样可以提高代码的可维护性和安全性。\n预处理语句 JSP中可以使用预处理语句（PreparedStatement）来执行SQL语句，预处理语句可以有效地防止SQL注入攻击，并提高数据库操作的效率。\n预处理语句通常包含一个带有占位符的SQL语句和一组参数，占位符使用?表示。在执行预处理语句时，我们需要将参数设置到占位符中，然后执行预处理语句。\n以下是一个简单的JSP预处理语句的示例代码：\n\u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34;%\u0026gt; \u0026lt;% Connection conn = null; PreparedStatement stmt = null; ResultSet rs = null; try { // 获取数据库连接 conn = getConnection(); // 定义预处理语句 String sql = \u0026#34;SELECT * FROM records WHERE id = ?\u0026#34;; stmt = conn.prepareStatement(sql); // 设置参数 stmt.setInt(1, 1); // 执行预处理语句 rs = stmt.executeQuery(); while (rs.next()) { // 处理查询结果 int id = rs.getInt(\u0026#34;id\u0026#34;); String name = rs.getString(\u0026#34;name\u0026#34;); int age = rs.getInt(\u0026#34;age\u0026#34;); // 输出结果 out.println(\u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#34; + name + \u0026#34;, age=\u0026#34; + age + \u0026#34;\u0026lt;br\u0026gt;\u0026#34;); } } catch (SQLException e) { e.printStackTrace(); } finally { // 关闭数据库连接 if (rs != null) { rs.close(); } if (stmt != null) { stmt.close(); } if (conn != null) { conn.close(); } } %\u0026gt; 在上面的示例中，我们使用了一个名为getConnection()的方法来获取数据库连接，这个方法需要根据具体的数据库类型和配置来实现。另外，我们还使用了PreparedStatement对象来执行SQL语句，并使用setInt()方法将参数设置到占位符中。\n需要注意的是，预处理语句通常比普通的SQL语句执行速度更快，因为预处理语句可以将SQL语句编译一次，然后多次执行，而普通的SQL语句每次执行都需要重新编译。另外，预处理语句也可以有效地防止SQL注入攻击，因为预处理语句会自动将参数进行转义。\n另外，为了防止SQL注入攻击，我们应该将查询参数使用PreparedStatement来设置，而不是直接拼接SQL语句。例如：\nString sql = \u0026#34;SELECT * FROM records LIMIT ?, ?\u0026#34;; PreparedStatement stmt = conn.prepareStatement(sql); stmt.setInt(1, start); stmt.setInt(2, pageSize); ResultSet rs = stmt.executeQuery(); ","permalink":"https://waite.wang/posts/jsp/jsp-connect-mysql/","summary":"\u003ch1 id=\"jsp-访问数据库\"\u003eJSP 访问数据库\u003c/h1\u003e\n\u003ch2 id=\"mysql-connector-java的jar包下载\"\u003emysql-connector-java的jar包下载\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e官方下载地址 \u003ca href=\"https://dev.mysql.com/downloads/connector/j/\"\u003ehttps://dev.mysql.com/downloads/connector/j/\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202310121220594.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202310121220594.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e解压, 把JDBC驱动放在lib文件夹下（直接复制过来就可以了）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/202310121223954.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/202310121223954.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e记得导入, 不然会报错\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e\u0026lt;%\u003c/span\u003e\u003cspan class=\"err\"\u003e@\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003epage\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eimport\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;java.sql.*\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e%\u0026gt;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"基本用法\"\u003e基本用法\u003c/h2\u003e\n\u003ch3 id=\"连接mysql数据库\"\u003e连接MySQL数据库\u003c/h3\u003e\n\u003cp\u003e在JSP中连接MySQL数据库的步骤如下：\u003c/p\u003e","title":"JSP 访问数据库"},{"content":"nvm 的使用 nvm 可以快速的切换 nodejs 的版本\nnvm 是什么？ nvm 是一个 node 的版本管理工具，可以简单操作 node 版本的切换、安装、查看。。。等等，与 npm 不同的是，npm 是依赖包的管理工具。\nnvm 下载安装\n安装之前需要先把 自己电脑上边的 node 给卸载了!!!! 很重要\n下载地址：https://github.com/coreybutler/nvm-windows/releases\n安装完毕后输入 nvm -v 查看版本。这样 nvm 就已经安装完成了\nnvm 的基本使用\nnrm 的使用 可以快速切换下载镜像 介绍\nnrm(npm registry manager) 是 npm 的镜像源管理工具. 有时候国外资源太慢,使用 nrm 可以快速的在 npm 源之间切换\n安装 npm install -g nrm\n基本使用\n查看可选择的源 nrm ls 切换到对应的镜像源 nrm use 对应的镜像 删除镜像源 nrm del 名字 增加镜像源 nrm add registry http://registry.npm.frp/trmap.cn/ 测试镜像源速度 nrm test npm ","permalink":"https://waite.wang/posts/web/how-to-use-nvm/","summary":"\u003ch1 id=\"nvm-的使用\"\u003e\u003cstrong\u003envm 的使用\u003c/strong\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003envm 可以快速的切换 nodejs 的版本\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"nvm-是什么\"\u003e\u003cstrong\u003envm 是什么？\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003envm 是一个 node 的版本管理工具，可以简单操作 node 版本的切换、安装、查看。。。等等，与 npm 不同的是，npm 是依赖包的管理工具。\u003c/p\u003e","title":"nvm 的使用"},{"content":"Jdk 安装 Tomcat 注意 Tomcat 版本与 Jdk 匹配\n官网地址：https://tomcat.apache.org/\n我这里选择的是Tomcat9.0版本，大家可以选择自己需要的版本\n将下载好的zip文件解压到指定文件夹，例如：D:\\software\\tomcat90，目录不要有中文（建议不要解压到C盘 ）\n配置Tomcat环境变量 Tomcat的环境变量配置跟JDK的环境变量配置几乎一样，只是修改变量名称和对应的路径，具体操作如下:\n右击此电脑\u0026ndash;属性 单击高级系统设置\u0026ndash;高级环境变量(N) 在系统变量下面找到新建，填写变量名：CATALINA_HOME，变量值：D:\\software\\tomcat90\\apache-tomcat-9.0.74（即Tomcat的安装路径） 在系统变量找到变量名Path\u0026ndash;单击Path\u0026ndash;编辑\u0026ndash;新建\u0026ndash;输入\u0026quot;%CATALINA_HOME%\\bin\u0026quot;\u0026ndash;确定\u0026ndash;确定\u0026ndash;确定 测试环境变量是否配置成功 点击屏幕左下角的“开始”按钮\u0026ndash;搜索命令提示符\u0026ndash;右键以管理员身份运行（以管理员身份进入防止权限问题的错误）\u0026ndash;输入cmd回车进入命令行窗口\u0026ndash;进入Tomcat的bin目录，输入service.bat install [服务名,默认为配置文件中名称Tomcat9] 进行window服务安装，我这个已经安装完了，window服务已经存在了所以显示error，如果出现 The service \u0026lsquo;Tomcat9\u0026rsquo; has been installed.则表明安装服务成功！ 在目录下 管理员 cmd 运行 startup.bat 以上页面表示运行成功, 浏览器打开 127.0.0.1:8080 即可看到 Tomcat 起始页面 改端口 找到tomcat目录/conf/server.xml\n选择以记事本打开，把8080改为你想修改的端口号，这里选择修改为8，修改后保存 注意： 1）修改的端口一定不能被占用 2）修改完成后，进入bin目录，先启动shutdown.bat，再启动startup.bat 重启tomcat服务器\nIdea 配置 1.先新建一个正常的java项目\n2.运行下拉框找到编辑配置，点击\n3.找到tomcat服务器，选择本地那个\n4.配置你的tomcat文件的路径，在tomcat项目启动完成后打开浏览器，这里选择你电脑上安装的一款浏览器即可，点击确定\n5.右键点击项目，选择添加框架支持，点击\n6.勾选web应用程序与创建web.xml，点击确定\n7.找到运行箭头左边的tomcat图标，点击，选择编辑配置，点击\n点击部署 添加工件，点击 选择你的项目，上下文那一栏填写一个/即可 运行左边的tomcat图标没有❌时，就代表配置成功，编辑你的项目文件，点击运行即可 运行成功会自动打开你自己设置的默认浏览器 建议开启以下功能, 这样不用每次都要重新部署\n设置JSP代码自动补全 File -\u0026gt; Project Structure，打开项目设置页面；选择到“Dependencies”便签 -\u0026gt; 点击“+”-\u0026gt; 2.Librarys： 在Choose Libraries页面，选择“Tomcat”:\n将Tomcat的Scope设置为Provinced，然后保存设置：\n","permalink":"https://waite.wang/posts/win/tomcat-idea-install/","summary":"\u003ch2 id=\"jdk-安装\"\u003eJdk 安装\u003c/h2\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/0_0_13.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/0_0_13.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003ch2 id=\"tomcat\"\u003eTomcat\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意 Tomcat 版本与 Jdk 匹配\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\n\u003cdiv class=\"post-img-view\"\u003e\n  \u003ca data-fancybox=\"gallery\" href=\"https://qiniu.waite.wang/20230906133609.png\"\u003e\n    \u003cimg src=\"https://qiniu.waite.wang/20230906133609.png\" alt=\"\"  /\u003e\n  \u003c/a\u003e\n\u003c/div\u003e\n\u003c/p\u003e\n\u003cp\u003e官网地址：https://tomcat.apache.org/\u003c/p\u003e\n\u003cp\u003e我这里选择的是Tomcat9.0版本，大家可以选择自己需要的版本\u003c/p\u003e","title":"Tomcat + Idea 配置及使用"},{"content":"安装JDK 1.创建工作路径\nmkdir /usr/cx 2.解压安装包\ntar -zxvf 安装包位置 -C /usr/cx 3.配置环境变量\nvi ~/.bashrc 在打开的~/.bashrc文件中写入一下内容\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi (----------------注：需要在此处增加内容-------------------) --在这添加-- export JAVA_HOME=/usr/cx/jdk名字版本 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar 4.更新环境变量\nsource ~/.bashrc 5.验证jdk是否配置成功\njava -version 主机名配置 1.编辑主机名\nvi /etc/sysconfig/network 打开后的文件如下\nNETWORKING=yes HOSTNAME=CentOS6.5 -----将此地方更改为localhost ----注意若为本地主机则更改为localhost不是则更改为别的地址 更给后输入reboot重启\nreboot 2.IP地址与主机名映射文件配置\nvi /etc/hosts 打开后的文件如下\n127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 (注：在此行增加内容) ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 在第一行的ip地址后面添加一个localhost ----注意若为本地主机则更改为localhost不是则更改为别的地址 3.检测主机名与IP映射是否配置成功\nping localhost -c 4 SElinux安全配置 1.关闭SElinux\n通过命令使用vi编辑器打开SElinux配置文件\nvi /etc/selinux/config 打开后的文件如下\n# This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=permissive ------ 将这里的值更改为disabled (注：需要更改此行内容) # SELINUXTYPE= can take one of these two values: # targeted - Targeted processes are protected, # mls - Multi Level Security protection. SELINUXTYPE=targeted 2.SElinux配置强制生效\nsetenforce 0 配置SSH免密码登录 1.生成密钥\n输入一下命令生成本机密钥文件\nssh-keygen -t dsa 当出现提示的时候，我们直接按回车即可，默认会将秘钥文件生成到~/.ssh/目录下（由于我们实验所使用的登录用户为root，因此~/.ssh/等同于/root/.ssh/）\n通过一下命令查看~/.ssh目录下的文件\nls ~/.ssh 2.密钥分发\n把当前节点的公钥文件id_dsa.pub内容输出追加到任意节点的~/.ssh/authorized_keys文件的末尾，则在被添加的节点上便可以免密码登录到当前的节点（由于我们是单节点部署，因此直接追加到当前节点的~/.ssh/authorized_keys文件中即可\ncat ~/.ssh/id_dsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys 3.验证免密码登录是否配置成功\nssh localhost ----注意若为本地主机则更改为localhost不是则更改为别的地址 第一次登录的时候，会询问呢是否继续连接，输入yes即可\n连接成功后退出连接\nexit 安装Hadoop 1.解压安装文件\ntar -zxvf Hadoop安装包位置 -C /usr/cx 2.配置Hadoop环境变量\nvi ~/.bashrc 打开后的文件如下\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi export JAVA_HOME=/usr/cx/jdk+版本 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar (----------------在此处增加内容-------------------) export HADOOP_HOME=/usr/cx/hadoop+版本 export PATH=$PATH:$HADOOP_HOME/bin:$PATH export PATH=$PATH:$HADOOP_HOME/sbin:$PATH 退出后执行如下命令，更新环境变量\nsource ~/.bashrc 通过下列命令验证Hadoop环境变量是否配置成功\nhadoop 3.编辑Hadoop配置文件\n使用vi命令打开hadoop-env.sh配置文件进行编辑:\nvi /usr/cx/hadoop版本/etc/hadoop/hadoop-env.sh 打开后的文件如下\n# Set Hadoop-specific environment variables here. # The only required environment variable is JAVA_HOME. All others are # optional. When running a distributed configuration it is best to # set JAVA_HOME in this file, so that it is correctly defined on # remote nodes. # The java implementation to use. export JAVA_HOME=${JAVA_HOME} ---更改为 export JAVA_HOME=/usr/cx/jdk+版本 (注：需要对此行内容进行更改，为Hadoop绑定Java运行环境) # The jsvc implementation to use. Jsvc is required to run secure datanodes # that bind to privileged ports to provide authentication of data transfer # protocol. Jsvc is not required if SASL is configured for authentication of # data transfer protocol using non-privileged ports. #export JSVC_HOME=${JSVC_HOME} export HADOOP_CONF_DIR=${HADOOP_CONF_DIR:-\u0026#34;/etc/hadoop\u0026#34;} 使用vi命令打开core-site.xml配置文件进行编辑\nvi /usr/cx/hadoop+版本/etc/hadoop/core-site.xml 打开的文件内容如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) /*设置默认的HDFS访问路径*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://localhost:9000\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /*缓冲区大小：io.file.buffer.size默认是4KB*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;io.file.buffer.size\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;131072\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*临时文件夹路径设置*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:/usr/tmp\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置使用hduser用户可以代理所有主机用户进行任务提交*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.proxyuser.hduser.hosts\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;*\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置使用hduser用户可以代理所有组用户进行任务提交*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.proxyuser.hduser.groups\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;*\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 退出vi编辑器后输入以下vi命令打开yarn-site.xml文件进行配置\nvi /usr/cx/hadoop+版本/etc/hadoop/yarn-site.xml 打开后的文件内容如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;!-- Site specific YARN configuration properties --\u0026gt; /*设置NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.mapred.ShuffleHandler\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置客户端与ResourceManager的通信地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:8032\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /*设置ApplicationMaster调度器与ResourceManager的通信地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.scheduler.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:8030\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /*设置NodeManager与ResourceManager的通信地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.resource-tracker.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:8031\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /*设置管理员与ResourceManager的通信地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.admin.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:8033\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /* ResourceManager的Web地址，监控资源调度*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.webapp.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:8088\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 使用下列命令复制mapred-site.xml.template文件并重命名为mapred-site.xml：\ncp /usr/cx/hadoop+版本/etc/hadoop/mapred-site.xml.template /usr/cx/hadoop+版本/etc/hadoop/mapred-site.xml 使用vi命令打开mapred-site.xml文件进行配置：\nvi /usr/cx/hadoop+版本/etc/hadoop/mapred-site.xml 打开后的文件内容如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) /*Hadoop对MapReduce运行框架一共提供了3种实现，在mapred-site.xml中通过\u0026#34;mapreduce.framework.name\u0026#34;这个属性来设置为\u0026#34;classic\u0026#34;、\u0026#34;yarn\u0026#34;或者\u0026#34;local\u0026#34;*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*MapReduce JobHistory Server地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.jobhistory.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:10020\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /*MapReduce JobHistory Server Web UI访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.jobhistory.webapp.address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:19888\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 执行以下命令创建Hadoop的数据存储目录namenode和datanode\nmkdir -p /hdfs/namenode mkdir -p /hdfs/datanode 使用vi命令打开hdfs-site.xml文件进行配置：\nvi /usr/cx/hadoop+版本/etc/hadoop/hdfs-site.xml 打开的文件内容如下\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) /*配置SecondaryNameNode地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.secondary.http-address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;localhost:9001\u0026lt;/value\u0026gt; ----注意若为本地主机则更改为localhost不是则更改为别的地址 \u0026lt;/property\u0026gt; /*配置NameNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.name.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:/hdfs/namenode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置DataNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.datanode.data.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:/hdfs/datanode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置数据块副本数*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*将dfs.webhdfs.enabled属性设置为true，否则就不能使用webhdfs的LISTSTATUS、LIST FILESTATUS等需要列出文件、文件夹状态的命令，因为这些信息都是由namenode保存的*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.webhdfs.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 使用vi命令打开slaves文件进行配置（要与我们前文设置的主机名相互一致，否则将会引起Hadoop相关进程无法正确启动）：\nvi /usr/cx/hadoop-2.7.1/etc/hadoop/slaves 打开的文件内容如下\nlocalhost ----注意若为本地主机则更改为localhost不是则更改为别的地址 若为localhost则不做更改，因为在本地机器而不是在易优云中需要连接到易优云的主机\n** 4.格式化HDFS **\n通过下列命令格式化HDFS文件系统\nhadoop namenode -format Hadoop运行及测试 ** 1.启动Hadoop**\n通过下列命令启动Hadoop：\nstart-all.sh 通过下列命令，查看相应的JVM进程确定Hadoop是否配置及启动成功：\njps ** Web页面测试**\n用浏览器输入网址 http://localhost:8080和http://localhost50070\n1 、实验目的 通过本节实验的学习，同学们可以掌握Hadoop集群环境部署与配置。本实验完成后，要求学生掌握以下内容：\n掌握集群所有节点之间SSH免密登录配置方式；\n掌握NTP服务配置，实现节点间的时间同步；\n掌握ZooKeeper集群的搭建方式；\n掌握Hadoop集群的搭建配置流程；\n理解Hadoop集群的高可用（HA）原理，并掌握Hadoop集群的高可用（HA）配置方法。\n2、实验原理 需要按照以下流程，在Linux上进行Hadoop集群的安装部署：\n主机名配置：在大型的Hadoop集群中，往往由成百上千个节点组成，如果通过IP地址对不同节点进行管理，那么集群维护的工作量将会十分繁重，因此在工程环境中，常常通过对每个节点设置唯一的主机名，从而实现对节点进行管理。\nSSH（安全外壳协议）免密码登录配置：推荐安装OpenSSH。Hadoop需要通过SSH来启动Slave列表中各台主机的守护进程，因此SSH也是必须安装的。\n安装配置JDK1.7（或更高版本）：Hadoop是用Java编写的程序，Hadoop的编译及MapReduce的运行都需要使用JDK，因此在安装Hadoop前，必须安装JDK1.7或更高版本。\nNTP服务配置：本实验需要在实现Hadoop集群搭建的同时，并进行高可用性（HA）的配置，因此需要通过ZooKeeper来对集群中的节点进行协调，而ZooKeeper需要保证节点间的时钟相互一致，因此需要在集群中配置NTP服务。\nSElinux安全配置：CentOS默认启用了SElinux，在网络服务方面权限要求比较严格，因此需要对SElinux安全配置进行更改。\nZooKeeper集群搭建：高可用性（HA）Hadoop集群的搭建需要依赖于ZooKeeper来对集群中的节点进行协调，因此需要进行ZooKeeper集群搭建。\nHadoop核心配置。Hadoop的稳定运行需要依赖于其核心配置文件，因此当上述准备工作就绪后，我们便需要着重进行配置文件编写来实现Hadoop的可靠运行。\n我们需要在节点1、节点2、节点3中进行高可用Hadoop集群环境的部署。各个节点所部署的服务如下所示：\n节点1 节点2 节点3 NameNode StandBy ResourceManager StandBy DFSZKFailoverController DFSZKFailoverController DataNode DataNode DataNode NodeManager NodeManager NodeManager JournalNode JournalNode JournalNode 1 集群节点基本配置 步骤1. 节点IP地址查询 在节点1、2、3中通过下面的命令查询节点IP地址： ifconfig 命令运行后的返回结果如下所示 (每台虚拟机的IP地址都是不同的，因此需要以实际地址信息为准）：\n[root@CentOS6 ~]# ifconfig eth6 Link encap:Ethernet HWaddr 02:00:1E:79:09:04 inet addr:10.1.1.4 Bcast:10.1.1.255 Mask:255.255.255.0 inet6 addr: fe80::1eff:fe79:904/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:20832 errors:0 dropped:0 overruns:0 frame:0 TX packets:13052 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:31392026 (29.9 MiB) TX bytes:929956 (908.1 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:12 errors:0 dropped:0 overruns:0 frame:0 TX packets:12 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:720 (720.0 b) TX bytes:720 (720.0 b) [root@CentOS6 ~]# 需要记录三个节点的IP地址，在后文中我们需要根据此IP地址进行相关操作\n步骤2. 节点主机名配置 需要在节点1、2、3进行下列操作，将三个主机名分别配置为realtime-1，realtime-2，realtime-3\n通过下列命令使用vi编辑器编辑主机名配置文件： vi /etc/sysconfig/network 打开后的文件内容如下所示：\nNETWORKING=yes HOSTNAME=CentOS6.5 (注：需要将此行内容修改为实际的主机名realtime-1、realtime-2、realtime-3) 在文件中进行内容更改，将HOSTNAME字段内容配置成realtime-： HOSTNAME=realtime-1 编辑完成后保存文件并退出vi编辑器\n更改后的文件内容如下所示：\n更改后的内容会在下次系统重启的时候生效，通过下列命令重新启动系统： reboot 步骤3. 节点1、2、3主机名与IP地址映射文件配置 在节点1、2、3中，通过下列命令使用vi编辑器编辑hosts文件： vi /etc/hosts 打开后的文件内容如下所示：\n127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 (注：在此行增加内容) ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 增加节点1、2、3的IP地址与主机名的映射关系、节点间的IP地址与主机名的映射关系、节点间的IP地址与主机名的映射关系，IP地址与主机名之间用空格分隔（主机名填写为前文配置的节点实际主机名称，IP地址需要根据上文中的查询结果来进行填写，并与实际的主机名相对应）： 10.1.1.4 realtime-1 10.1.1.3 realtime-2 10.1.1.206 realtime-3 更改后的文件内容如下所示\n127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 10.1.1.4 realtime-1 10.1.1.3 realtime-2 10.1.1.206 realtime-3 编辑完成后保存文件并退出vi编辑器\n通过下列命令检测主机名与IP映射是否配置成功： ping realtime-1 -c 2 如果配置成功，则会显示如下结果：\n[root@realtime-1 ~]# ping realtime-1 -c 2 (注：通过此命令向realtime-1节点发送2个报文) PING realtime-1 (10.1.1.4) 56(84) bytes of data. 64 bytes from realtime-1 (10.1.1.4): icmp_seq=1 ttl=64 time=1.98 ms 64 bytes from realtime-1 (10.1.1.4): icmp_seq=2 ttl=64 time=0.341 ms --- realtime-1 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.341/1.163/1.985/0.822 ms [root@realtime-1 ~]# 通过下列命令检测主机名与IP映射是否配置成功： ping realtime-2 -c 2 如果配置成功，则会显示如下结果：\n[root@realtime-1 ~]# ping realtime-2 -c 2 (注：通过此命令向realtime-2节点发送2个报文) PING realtime-2 (10.1.1.3) 56(84) bytes of data. 64 bytes from realtime-2 (10.1.1.3): icmp_seq=1 ttl=64 time=0.047 ms 64 bytes from realtime-2 (10.1.1.3): icmp_seq=2 ttl=64 time=0.026 ms --- realtime-2 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 999ms rtt min/avg/max/mdev = 0.026/0.036/0.047/0.012 ms [root@realtime-1 ~]# 通过下列命令检测主机名与IP映射是否配置成功： ping realtime-3 -c 2 如果配置成功，则会显示如下结果：\n[root@realtime-1 ~]# ping realtime-3 -c 2 (注：通过此命令向realtime-3节点发送2个报文) PING realtime-3 (10.1.1.206) 56(84) bytes of data. 64 bytes from realtime-3 (10.1.1.206): icmp_seq=1 ttl=64 time=1.36 ms 64 bytes from realtime-3 (10.1.1.206): icmp_seq=2 ttl=64 time=0.315 ms --- realtime-3 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.315/0.841/1.367/0.526 ms [root@realtime-1 ~]# 如果无法进行正常的报文发送，请检查主机名是否配置正确，同时请检查主机名与IP地址映射是否配置正确。\n2 配置SSH免密码登录 步骤1. 节点1、2、3秘钥配置及分发 例如节点1 : 需要在节点1进行下列操作，在节点1中生成秘钥文件，然后将公钥文件分发到节点2和节点3中，实现在节点1可以免密码登录到集群中的其他主机中。\n通过下面的命令生成密钥（使用rsa加密方式）： echo -e \u0026#34;\\n\u0026#34;|ssh-keygen -t rsa -N \u0026#34;\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 默认情况下会在~/.ssh/文件夹下生成公钥文件id_rsa.pub和私钥文件id_rsa，通过下面的命令对~/.ssh/内容进行查看：\nll ~/.ssh/ 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ll ~/.ssh/ 总用量 8 -rw-------. 1 root root 1675 11月 29 13:42 id_rsa -rw-r--r--. 1 root root 397 11月 29 13:42 id_rsa.pub [root@realtime-1 ~]# 通过下面的命令将公钥文件发送到本机以及其他两个节点，创建root免密钥通道（需要输入密码：111111）： ssh-copy-id -i /root/.ssh/id_rsa.pub root@realtime-1 # 其他的节点需要随之改动root@realtime-2 and root@realtime-3 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@realtime-1 The authenticity of host \u0026#39;realtime-1 (10.1.1.4)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is 9f:3b:30:10:65:46:c9:c3:2b:fb:e5:28:38:39:9c:84. Are you sure you want to continue connecting (yes/no)? yes (注：此处需要输入yes) Warning: Permanently added \u0026#39;realtime-1,10.1.1.4\u0026#39; (RSA) to the list of known hosts. root@realtime-1\u0026#39;s password: （注：此处需要输入root用户密码，为111111） Now try logging into the machine, with \u0026#34;ssh \u0026#39;root@realtime-1\u0026#39;\u0026#34;, and check in: .ssh/authorized_keys to make sure we haven\u0026#39;t added extra keys that you weren\u0026#39;t expecting. [root@realtime-1 ~]# 步骤2. SSH免密码登录测试 集群中各个节点秘钥分发完毕后，可以通过ssh远程登录命令来测试免密码登录是否配置成功。为了操作统一，我们在节点3中进行下面的操作（在其他节点操作所实现的效果也是一样的）\n在节点3中通过下面的命令可以实现免密码远程登录到节点1： ssh realtime-1 #依次运行realtime-2 and realtime-3 命令运行后的返回结果如下所示：\n[root@realtime-3 ~]# ssh realtime-1 Last login: Thu Nov 29 14:08:34 2018 from realtime-3 [root@realtime-1 ~]# 如果从源主机到目的主机的登录过程中，出现需要输入密码的情况，那么需要检查是否已经成功将源主机的公钥文件发送到目的主机中\n3 安装配置JDK1.8 JDK需要在集群3个节点都进行安装，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n我们可以在Oracle JDK的官网下载相应版本的JDK，官网地址为:http://www.oracle.com/technetwork/java/javase/downloads/index.html\n步骤1. 创建工作路径 首先需要在终端中输入下列命令，在/usr目录下建立cx工作路径： mkdir /usr/cx 通过下面的命令实现在节点2和节点3的/usr目录下建立cx工作路径： ssh realtime-2 \u0026#34;mkdir /usr/cx\u0026#34; ssh realtime-3 \u0026#34;mkdir /usr/cx\u0026#34; 步骤2. 解压安装包 我们可以在/usr/software/目录下找到jdk-8u60-linux-x64.tar.gz安装包，通过下列命令将其解压到/usr/cx/目录下： tar -zxvf /usr/software/jdk-8u60-linux-x64.tar.gz -C /usr/cx 命令执行后的输出内容如下所示：\n(-------------------省略------------------------) jdk1.8.0_60/bin/jmc.ini jdk1.8.0_60/bin/jmap jdk1.8.0_60/bin/serialver jdk1.8.0_60/bin/wsgen jdk1.8.0_60/bin/jrunscript jdk1.8.0_60/bin/javah jdk1.8.0_60/bin/javac jdk1.8.0_60/bin/jvisualvm jdk1.8.0_60/bin/jcontrol jdk1.8.0_60/release [root@realtime-1 ~]# 通过下列命令实现在节点2和节点3中将jdk-8u60-linux-x64.tar.gz安装包解压到/usr/cx/目录下： ssh realtime-2 \u0026#34;tar -zxvf /usr/software/jdk-8u60-linux-x64.tar.gz -C /usr/cx\u0026#34; ssh realtime-3 \u0026#34;tar -zxvf /usr/software/jdk-8u60-linux-x64.tar.gz -C /usr/cx\u0026#34; 步骤3. 配置环境变量 通过下列命令使用vi编辑器打开 ~/.bashrc文件： vi ~/.bashrc 打开的~/.bashrc文件内容如下所示：\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi (----------------注：需要在此处增加内容-------------------) 在文件中写入下列内容： export JAVA_HOME=/usr/cx/jdk1.8.0_60 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar 编辑完成后保存文件并退出vi编辑器。\n通过下面的命令将环境变量配置文件分发到节点2和节点3： scp ~/.bashrc root@realtime-2:~/.bashrc scp ~/.bashrc root@realtime-3:~/.bashrc 命令执行后的输出内容如下所示：\n[root@realtime-1 ~]# scp ~/.bashrc root@realtime-2:~/.bashrc .bashrc 100% 320 0.3KB/s 00:00 [root@realtime-1 ~]# 步骤4. 更新环境变量 执行如下命令，更新环境变量： source ~/.bashrc 执行如下命令，更新节点2和节点3的环境变量： ssh realtime-2 \u0026#34;source ~/.bashrc\u0026#34; ssh realtime-3 \u0026#34;source ~/.bashrc\u0026#34; 步骤5. 验证JDK是否配置成功 通过下面的命令验证JDK是否安装并配置成功： java -version 如果出现如下JDK版本信息，则说明安装配置成功：\n[root@realtime-1 ~]# java -version java version \u0026#34;1.8.0_60\u0026#34; (注：JDK版本号) Java(TM) SE Runtime Environment (build 1.8.0_60-b27) (注：Java运行环境版本号) Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode) [root@realtime-1 ~]# 通过下面的命令验证节点2和节点3的JDK是否安装并配置成功： ssh realtime-2 \u0026#34;java -version\u0026#34; ssh realtime-3 \u0026#34;java -version\u0026#34; 如果没有正确输出相关版本信息，请检查~/.bashrc文件中的JDK环境变量是否配置正确，同时请确定是否使用source ~/.bashrc命令更新环境变量配置\n4 NTP服务配置 需要在集群的3台节点中都进行NTP服务的配置\n步骤1. NTP服务配置 在节点1、节点2、节点3中通过下面的命令打开NTP配置文件： vi /etc/ntp.conf 打开后的文件内容如下所示：\n（---------------省略----------------） # Permit all access over the loopback interface. This could # be tightened as well, but to do so would effect some of # the administrative functions. restrict 127.0.0.1 restrict -6 ::1 # Hosts on local network are less restricted. #restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap # Use public servers from the pool.ntp.org project. # Please consider joining the pool (http://www.pool.ntp.org/join.html). server 0.centos.pool.ntp.org iburst （注：注释此行内容） server 1.centos.pool.ntp.org iburst （注：注释此行内容） server 2.centos.pool.ntp.org iburst （注：注释此行内容） server 3.centos.pool.ntp.org iburst （注：注释此行内容） （注：在此处增加内容） #broadcast 192.168.1.255 autokey # broadcast server （---------------省略----------------） 在文件中进行下列内容更改（通过server字段设置本机为NTP Serevr服务器，通过restrict限制realtime-2和realtime-3主机名对应的主机可以同步时间）：\n#server 0.centos.pool.ntp.org iburst #server 1.centos.pool.ntp.org iburst #server 2.centos.pool.ntp.org iburst #server 3.centos.pool.ntp.org iburst server 127.127.1.0 fudge 127.127.1.0 stratum 10 restrict realtime-2 nomodify notrap restrict realtime-3 nomodify notrap 更改完成后保存文件并退出编辑器\n步骤2. 启动NTP服务 为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行。\n通过下面的命令在节点1中设定NTP服务自启动： chkconfig ntpd on 通过下面的命令在节点1中启动NTP服务： service ntpd start 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# service ntpd start 正在启动 ntpd： [确定] [root@realtime-1 ~]# 通过下面的命令在节点2中设定NTP服务自启动： ssh realtime-2 \u0026#34;chkconfig ntpd on\u0026#34; 通过下面的命令在节点2中启动NTP服务： ssh realtime-2 \u0026#34;service ntpd start\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;service ntpd start\u0026#34; 正在启动 ntpd：[确定] [root@realtime-1 ~]# 通过下面的命令在节点3中设定NTP服务自启动： ssh realtime-3 \u0026#34;chkconfig ntpd on\u0026#34; 通过下面的命令在节点3中启动NTP服务： ssh realtime-3 \u0026#34;service ntpd start\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-3 \u0026#34;service ntpd start\u0026#34; 正在启动 ntpd：[确定] [root@realtime-1 ~]# 如果服务无法正常启动，会出现相关的错误提示信息，只需要根据错误提示进行更改即可。\n步骤3. NTP服务状态查看 为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行。\n通过下面的命令查看节点1中NTP服务的运行状态： ntpstat 命令运行后的返回结果如下所示（由于节点1是作为Server节点，所以其状态会很快变成synchronised，此时说明服务已经正常启动）：\n[root@realtime-1 ~]# ntpstat synchronised to local net at stratum 11 time correct to within 449 ms polling server every 64 s [root@realtime-1 ~]# 通过下面的命令查看节点2和节点三中NTP服务的运行状态： ssh realtime-2 \u0026#34;ntpstat\u0026#34; ssh realtime-3 \u0026#34;ntpstat\u0026#34; 命令运行后的返回结果如下所示（由于节点2需要同步节点1的时间，因此需要大概15分钟其状态才会由unsynchronised会变成synchronised，当状态变为synchronised时说明服务已经正常启动）：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;ntpstat\u0026#34; unsynchronised polling server every 64 s [root@realtime-1 ~]# 服务正常启动后的状态如下所示：\n[root@realtime-1 ~]# ssh realtime-3 \u0026#34;ntpstat\u0026#34; synchronised to NTP server (10.1.1.4) at stratum 12 time correct to within 25 ms polling server every 64 s [root@realtime-1 ~]# 当3个节点的状态都显示为synchronised时，则表示ntp服务已经启动成功；如果一直显示unsynchronised,可能是配置文件有错误，因此需要检查IP地址是否配置正确。\n同学们不必一直等待，可以先进行下文的实验，然后过后再查看NTP服务状态。\n5 SElinux安全配置 需要在集群3个节点都进行SElinux配置，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行。\n通过下面的命令，关闭节点1、节点2、节点3的SElinux安全设置： /bin/sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/\u0026#39; /etc/selinux/config ssh realtime-2 \u0026#34;/bin/sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/\u0026#39; /etc/selinux/config\u0026#34; ssh realtime-3 \u0026#34;/bin/sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/\u0026#39; /etc/selinux/config\u0026#34; 6 安装配置ZooKeeper集群 由于我们需要搭建一套具备高可用性的Hadoop集群，因此需要通过ZooKeeper来进行集群中服务的协调。ZooKeeper需要在集群3个节点进行安装配置，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n在模板中我们已经将ZooKeeper安装文件zookeeper-3.4.6.tar.gz放到了/usr/software目录下，同学们可以直接使用\n步骤1. 解压安装包 通过下列命令将ZooKeeper安装包解压到/usr/cx目录下： tar -zxvf /usr/software/zookeeper-3.4.6.tar.gz -C /usr/cx 命令运行后的返回结果如下所示：\n(---------------------省略--------------------) zookeeper-3.4.6/recipes/queue/test/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java zookeeper-3.4.6/recipes/queue/build.xml zookeeper-3.4.6/zookeeper-3.4.6.jar zookeeper-3.4.6/lib/ zookeeper-3.4.6/lib/cobertura/ zookeeper-3.4.6/lib/cobertura/README.txt zookeeper-3.4.6/lib/jline-0.9.94.jar zookeeper-3.4.6/lib/log4j-1.2.16.LICENSE.txt zookeeper-3.4.6/lib/slf4j-log4j12-1.6.1.jar zookeeper-3.4.6/lib/jdiff/ zookeeper-3.4.6/lib/jdiff/zookeeper_3.1.1.xml zookeeper-3.4.6/lib/jdiff/zookeeper_3.4.6-SNAPSHOT.xml zookeeper-3.4.6/lib/jdiff/zookeeper_3.4.6.xml zookeeper-3.4.6/lib/slf4j-api-1.6.1.jar zookeeper-3.4.6/lib/log4j-1.2.16.jar zookeeper-3.4.6/lib/netty-3.7.0.Final.jar zookeeper-3.4.6/lib/jline-0.9.94.LICENSE.txt [root@realtime-1 ~]# 解压完成后，我们可以查看解压后的文件夹内容： ls /usr/cx/zookeeper-3.4.6/ 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ls /usr/cx/zookeeper-3.4.6/ bin dist-maven LICENSE.txt src build.xml docs NOTICE.txt zookeeper-3.4.6.jar CHANGES.txt ivysettings.xml README_packaging.txt zookeeper-3.4.6.jar.asc conf ivy.xml README.txt zookeeper-3.4.6.jar.md5 contrib lib recipes zookeeper-3.4.6.jar.sha1 [root@realtime-1 ~]# 步骤2. 数据存储目录创建 通过下面的命令创建ZooKeeper数据存储目录： mkdir -p /home/data 通过下面的命令创建ZooKeeper日志存储目录：\nmkdir -p /home/logs 通过下面的命令在节点2、节点3中创建ZooKeeper数据存储目录： ssh realtime-2 \u0026#34;mkdir -p /home/data\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /home/data\u0026#34; 通过下面的命令在节点2、节点3中创建ZooKeeper日志存储目录：\nssh realtime-2 \u0026#34;mkdir -p /home/logs\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /home/logs\u0026#34; 步骤3. 主机myid编号文件创建 通过下面的命令创建myid文件，并设置节点1对应的编号为1（集群启动后会通过此编号来进行主机识别）： echo \u0026#34;1\u0026#34; \u0026gt; /home/data/myid 通过下面的命令在节点2中创建myid文件，并设置节点2对应的编号为2（集群启动后会通过此编号来进行主机识别）： ssh realtime-2 \u0026#34;echo \u0026#34;2\u0026#34; \u0026gt; /home/data/myid\u0026#34; 通过下面的命令在节点3中创建myid文件，并设置节点3对应的编号为3（集群启动后会通过此编号来进行主机识别）： ssh realtime-3 \u0026#34;echo \u0026#34;3\u0026#34; \u0026gt; /home/data/myid\u0026#34; 步骤4. ZooKeeper配置文件编辑 通过下列命令创建并打开zoo.cfg配置文件： vi /usr/cx/zookeeper-3.4.6/conf/zoo.cfg 在文件中写入下列内容：\ntickTime=2000 dataDir=/home/data clientPort=2181 dataLogDir=/home/logs initLimit=5 syncLimit=2 server.1=realtime-1:2888:3888 server.2=realtime-2:2888:3888 server.3=realtime-3:2888:3888 编辑完成后保存文件并退出vi编辑器。\n在上述配置中，我们设置心跳时间为2000毫秒，设置ZooKeeper在本地保存数据的目录为/home/data，ZooKeeper监听客户端连接的端口为2181,设置所有Follower和Leader进行同步的时间为5s，设置一个Follower和Leader进行同步的时间为2s。同时设定集群中有3台主机，其中realtime-1对应的主机编号为1，Follower与Leader之间交换信息的端口为2888，进行Leader选举的端口为3888；realtime-2对应的主机编号为2，Follower与Leader之间交换信息的端口为2888，进行Leader选举的端口为3888；realtime-3对应的主机编号为3，Follower与Leader之间交换信息的端口为2888，进行Leader选举的端口为3888。\n步骤5. 文件分发 通过下面的命令将节点1的ZooKeeper文件包分发到节点2、节点3中： scp -r /usr/cx/zookeeper-3.4.6 root@realtime-2:/usr/cx/ scp -r /usr/cx/zookeeper-3.4.6 root@realtime-3:/usr/cx/ 命令运行后的返回结果如下所示：\n（----------------------省略------------------------） Makefile.am 100% 74 0.1KB/s 00:00 zkServer.cmd 100% 1084 1.1KB/s 00:00 zkEnv.sh 100% 2696 2.6KB/s 00:00 zkCleanup.sh 100% 1937 1.9KB/s 00:00 zkCli.sh 100% 1534 1.5KB/s 00:00 zkEnv.cmd 100% 1333 1.3KB/s 00:00 zkCli.cmd 100% 1049 1.0KB/s 00:00 README.txt 100% 238 0.2KB/s 00:00 zkServer.sh 100% 5742 5.6KB/s 00:00 NOTICE.txt 100% 170 0.2KB/s 00:00 zookeeper-3.4.6.jar.md5 100% 33 0.0KB/s 00:00 README.txt 100% 1585 1.6KB/s 00:00 CHANGES.txt 100% 79KB 78.9KB/s 00:00 zookeeper-3.4.6.jar.sha1 100% 41 0.0KB/s 00:00 [root@realtime-1 ~]# 步骤6. ZooKeeper环境变量配置 通过下列命令使用vi编辑器打开 ~/.bashrc文件： vi ~/.bashrc 打开的~/.bashrc文件内容如下所示：\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi export JAVA_HOME=/usr/cx/jdk1.8.0_60 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar (----------------注：需要在此处增加内容-------------------) 在文件中写入下列内容： export ZK_HOME=/usr/cx/zookeeper-3.4.6 export PATH=$PATH:$ZK_HOME/bin 编辑完成后保存文件并退出vi编辑器。\n通过下面的命令将环境变量配置文件分发到节点2和节点3： scp ~/.bashrc root@realtime-2:~/.bashrc scp ~/.bashrc root@realtime-3:~/.bashrc 步骤7. 更新环境变量 执行如下命令，更新环境变量： source ~/.bashrc ssh realtime-2 \u0026#34;source ~/.bashrc\u0026#34; ssh realtime-3 \u0026#34;source ~/.bashrc\u0026#34; 步骤8. 验证环境变量是否配置成功 通过下面的命令验证环境变量是否配置成功： zkServer.sh ssh realtime-2 \u0026#34;zkServer.sh\u0026#34; ssh realtime-3 \u0026#34;zkServer.sh\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# zkServer.sh JMX enabled by default Using config: /usr/cx/zookeeper-3.4.6/bin/../conf/zoo.cfg Usage: /usr/cx/zookeeper-3.4.6/bin/zkServer.sh {start|start-foreground|stop|restart|status|upgrade|print-cmd} [root@realtime-1 ~]# 由输出内容可以看出，ZooKeeper环境变量已经配置正确，并且可以正常执行。\n7 ZooKeeper启动及状态查看 步骤1. ZooKeeper启动 通过下面的命令启动ZooKeeper服务： zkServer.sh start ssh realtime-2 \u0026#34;zkServer.sh start\u0026#34; ssh realtime-3 \u0026#34;zkServer.sh start\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# zkServer.sh start JMX enabled by default Using config: /usr/cx/zookeeper-3.4.6/bin/../conf/zoo.cfg Starting zookeeper ... STARTED [root@realtime-1 ~]# 步骤2. ZooKeeper运行状态查看 ZooKeeper运行之后会随机进行follower角色以及leader角色选举，当leader角色节点出现异常后，会从其他节点中选举出新的leader角色。至于具体哪个节点处于leader状态，需要根据实际情况确定，并不是千篇一律的\n通过下面的命令可以查看ZooKeeper运行状态：\nzkServer.sh status ssh realtime-2 \u0026#34;zkServer.sh status\u0026#34; ssh realtime-3 \u0026#34;zkServer.sh status\u0026#34; 命令运行后的返回结果如下所示（由返回结果的Mode字段可以看出，当前节点是作为follower角色运行的）：\n[root@realtime-1 ~]# zkServer.sh status JMX enabled by default Using config: /usr/cx/zookeeper-3.4.6/bin/../conf/zoo.cfg Mode: follower [root@realtime-1 ~]# 8 安装配置Hadoop集群 Hadoop需要在集群3个节点进行安装配置，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n在模板中，我们已经将相应的Hadoop安装包hadoop-2.7.1.tar.gz放到/usr/software/目录下，同学们不需要再次下载，可以直接使用。\n步骤1. 数据存储目录创建 mkdir -p /hdfs/namenode mkdir -p /hdfs/datanode mkdir -p /hdfs/journalnode mkdir -p /var/log/hadoop-yarn ssh realtime-2 \u0026#34;mkdir -p /hdfs/namenode\u0026#34; ssh realtime-2 \u0026#34;mkdir -p /hdfs/datanode\u0026#34; ssh realtime-2 \u0026#34;mkdir -p /hdfs/journalnode\u0026#34; ssh realtime-2 \u0026#34;mkdir -p /var/log/hadoop-yarn\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /hdfs/namenode\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /hdfs/datanode\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /hdfs/journalnode\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /var/log/hadoop-yarn\u0026#34; 步骤2. 解压安装文件 通过下列命令解压Hadoop安装文件，将文件解压到/usr/cx目录下：\ntar -zxvf /usr/software/hadoop-2.7.1.tar.gz -C /usr/cx 命令执行后的输出内容如下所示：\n(-------------------省略------------------------) hadoop-2.7.1/libexec/hdfs-config.sh hadoop-2.7.1/README.txt hadoop-2.7.1/NOTICE.txt hadoop-2.7.1/lib/ hadoop-2.7.1/lib/native/ hadoop-2.7.1/lib/native/libhadoop.a hadoop-2.7.1/lib/native/libhadoop.so hadoop-2.7.1/lib/native/libhadooppipes.a hadoop-2.7.1/lib/native/libhdfs.so.0.0.0 hadoop-2.7.1/lib/native/libhadooputils.a hadoop-2.7.1/lib/native/libhdfs.a hadoop-2.7.1/lib/native/libhdfs.so hadoop-2.7.1/lib/native/libhadoop.so.1.0.0 hadoop-2.7.1/LICENSE.txt [root@master ~]# 步骤3. 编辑Hadoop配置文件： 使用vi命令打开hadoop-env.sh配置文件进行编辑： vi /usr/cx/hadoop-2.7.1/etc/hadoop/hadoop-env.sh 打开后的文件内容如下所示：\n(-------------------省略------------------------) # Set Hadoop-specific environment variables here. # The only required environment variable is JAVA_HOME. All others are # optional. When running a distributed configuration it is best to # set JAVA_HOME in this file, so that it is correctly defined on # remote nodes. # The java implementation to use. export JAVA_HOME=${JAVA_HOME} (注：需要对此行内容进行更改，为Hadoop绑定Java运行环境) # The jsvc implementation to use. Jsvc is required to run secure datanodes # that bind to privileged ports to provide authentication of data transfer # protocol. Jsvc is not required if SASL is configured for authentication of # data transfer protocol using non-privileged ports. #export JSVC_HOME=${JSVC_HOME} export HADOOP_CONF_DIR=${HADOOP_CONF_DIR:-\u0026#34;/etc/hadoop\u0026#34;} (-------------------省略------------------------) 在文件中进行下列内容更改，将JAVA_HOME对应的值改成实际的JDK安装路径：\nexport JAVA_HOME=/usr/cx/jdk1.8.0_60\n编辑完成后保存文件并退出vi编辑器。\n使用vi命令打开hdfs-site.xml文件进行配置： vi /usr/cx/hadoop-2.7.1/etc/hadoop/hdfs-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;/configuration\u0026gt; 在文件中\u0026lt;configuration\u0026gt;和\u0026lt;/configuration\u0026gt;之间增加下列内容：\n/*配置DataNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.datanode.data.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/hdfs/datanode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置数据块大小为256M*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.blocksize\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;268435456\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*自定义的HDFS服务名，在高可用集群中，无法配置单一HDFS服务器入口，所以需要指定一个逻辑上的服务名，当访问服务名时，会自动选择NameNode节点进行访问*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.nameservices\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HDFScluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置NameNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.name.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/hdfs/namenode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*定义HDFS服务名所指向的NameNode主机名称*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.namenodes.HDFScluster\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1,realtime-2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的完整监听地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.rpc-address.HDFScluster.realtime-1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:8020\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的完整监听地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.rpc-address.HDFScluster.realtime-2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2:8020\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的HTTP访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.http-address.HDFScluster.realtime-1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:50070\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的HTTP访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.http-address.HDFScluster.realtime-2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2:50070\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置主从NameNode元数据同步地址，官方推荐将nameservice作为最后的journal ID*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.shared.edits.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;qjournal://realtime-1:8485;realtime-2:8485;realtime-3:8485/HDFScluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置HDFS客户端用来连接集群中活动状态NameNode节点的Java类*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.client.failover.proxy.provider.HDFScluster\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置SSH登录的私钥文件地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.fencing.ssh.private-key-files\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/root/.ssh/id_rsa\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*启动fence过程，确保集群高可用性*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.fencing.methods\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;shell(/bin/true)\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置JournalNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.journalnode.edits.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/hdfs/journalnode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置自动切换活跃节点，保证集群高可用性*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.automatic-failover.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置数据块副本数*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*将dfs.webhdfs.enabled属性设置为true，否则就不能使用webhdfs的LISTSTATUS、LIST FILESTATUS等需要列出文件、文件夹状态的命令，因为这些信息都是由namenode保存的*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.webhdfs.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n在集群中，对HDFS集群访问的入口是NameNode所在的服务器。但是在两个NameNode节点的HA集群中，无法配置单一服务器入口，所以需要通过dfs.nameservices指定一个逻辑上的服务名，这个服务名是自定义的。当外界访问HDFS集群时，入口就变为这个服务名称，Hadoop会自动实现将访问请求转发到实际的处于Active状态的NameNode节点上。\n当配置了HDFS HA集群时，会有两个NameNode，为了避免两个NameNode都为Active状态，当发生failover时，Standby的节点要执行一系列方法把原来那个Active节点中不健康的NameNode服务给杀掉（这个过程就称为fence）。而dfs.ha.fencing.methods配置就是配置了执行杀死原来Active NameNode服务的方法，为了保险起见，因此指定无论如何都把StandBy节点的状态提升为Active，所以最后要配置一个shell(/bin/true)，保证不论前面的方法执行的情况如何，最后fence过程返回的结果都为True。fence操作需要通过SSH进行节点间的访问，因此需要配置dfs.ha.fencing.ssh.private-key-files为所需要用到的私钥文件路径信息。\n使用vi命令打开core-site.xml配置文件进行编辑： vi /usr/cx/hadoop-2.7.1/etc/hadoop/core-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;/configuration\u0026gt; 在文件中和之间增加下列内容：\n/*设置默认的HDFS访问路径，需要与hdfs-site.xml中的HDFS服务名相一致*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://HDFScluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*临时文件夹路径设置*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/usr/tmp\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置ZooKeeper服务集群，用于活跃NameNode节点的选举*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;ha.zookeeper.quorum\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:2181,realtime-2:2181,realtime-3:2181\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置数据压缩算法*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;io.compression.codecs\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.io.compress.DefaultCodec,org.apache.hadoop.io.compress.GzipCodec,org.apache.hadoop.io.compress.BZip2Codec,com.hadoop.compression.lzo.LzoCodec,com.hadoop.compression.lzo.LzopCodec,org.apache.hadoop.io.compress.SnappyCodec\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;io.compression.codec.lzo.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;com.hadoop.compression.lzo.LzoCodec\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置使用hduser用户可以代理所有主机用户进行任务提交*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.proxyuser.hduser.host\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;*\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置使用hduser用户可以代理所有组用户进行任务提交*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.proxyuser.hduser.groups\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;*\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n对HDFS集群访问的入口是NameNode所在的服务器，但是在两个NameNode节点的HA集群中，无法配置单一服务器入口，所以需要在hdfs-site.xml中通过dfs.nameservices指定一个逻辑上的服务名，因此此处的fs.defaultFS配置的入口地址需要与hdfs-site.xml中dfs.nameservices所配置的一致。\n使用vi命令打开yarn-site.xml文件进行配置： vi /usr/cx/hadoop-2.7.1/etc/hadoop/yarn-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;!-- Site specific YARN configuration properties --\u0026gt; \u0026lt;/configuration\u0026gt; 在文件中和之间增加下列内容：\n/*设置NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.mapred.ShuffleHandler\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置任务日志存储目录*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.log-dirs\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:///var/log/hadoop-yarn \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置Hadoop依赖包地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.application.classpath\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt; $HADOOP_HOME/share/hadoop/common/*,$HADOOP_HOME/share/hadoop/common/lib/*, $HADOOP_HOME/share/hadoop/hdfs/*,$HADOOP_HOME/share/hadoop/hdfs/lib/*, $HADOOP_HOME/share/hadoop/mapreduce/*,$HADOOP_HOME/share/hadoop/mapreduce/lib/*, $HADOOP_HOME/share/hadoop/yarn/*,$HADOOP_HOME/share/hadoop/yarn/lib/* \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*开启resourcemanager 的高可用性功能*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.ha.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*标识集群中的resourcemanager，如果设置该选项，需要确保所有的resourcemanager节点在配置中都有自己的逻辑id*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.cluster-id\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;YARNcluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置resourcemanager节点的逻辑id*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.ha.rm-ids\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;rm1,rm2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*为每个逻辑id绑定实际的主机名称*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.hostname.rm1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.hostname.rm2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*指定ZooKeeper服务地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.zk-address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:2181,realtime-2:2181,realtime-3:2181\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*指定resourcemanager的WEB访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.webapp.address.rm1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:8089\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.webapp.address.rm2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2:8089\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定虚拟内存与实际内存的比例，比例值越高，则可用虚拟内存就越多*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.vmem-pmem-ratio\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定单个容器可以申领到的最小内存资源*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.scheduler.minimum-allocation-mb\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;32\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置当任务运行结束后，日志文件被转移到的HDFS目录*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.remote-app-log-dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://HDFScluster/var/log/hadoop-yarn/apps\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定资源调度策略，目前可用的有FIFO、Capacity Scheduler和Fair Scheduler*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.scheduler.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定每个任务能够申领到的最大虚拟CPU数目*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.scheduler.maximum-allocation-vcores\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;8\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置任务完成指定时间（秒）之后，删除任务的本地化文件和日志目录*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.delete.debug-delay-sec\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;600\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置志在HDFS上保存多长时间（秒）*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.log.retain-seconds\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;86400\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定物理节点有2G内存加入资源池*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.resource.memory-mb\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;2048\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n在集群中，提交任务的入口是ResourceManager所在的服务器。但是在两个ResourceManager节点的HA集群中，无法配置单一服务器入口，所以需要通过yarn.resourcemanager.cluster-id指定一个逻辑上的服务名，这个服务名是自定义的。当外界向集群提交任务时，入口就变为这个服务名称，YARN会自动实现将访问请求转发到实际的处于Active状态的ResourceManager节点上。由于配置了逻辑服务名，所以需要设置resourcemanager节点的逻辑id，并为每个逻辑id绑定实际的主机名称\n使用下列命令复制mapred-site.xml.template文件并重命名为mapred-site.xml： cp /usr/cx/hadoop-2.7.1/etc/hadoop/mapred-site.xml.template /usr/cx/hadoop-2.7.1/etc/hadoop/mapred-site.xml 使用vi命令打开mapred-site.xml文件进行配置： vi /usr/cx/hadoop-2.7.1/etc/hadoop/mapred-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;/configuration\u0026gt; 在文件中和之间增加下列内容：\n/*Hadoop对MapReduce运行框架一共提供了3种实现，在mapred-site.xml中通过\u0026#34;mapreduce.framework.name\u0026#34;这个属性来设置为\u0026#34;classic\u0026#34;、\u0026#34;yarn\u0026#34;或者\u0026#34;local\u0026#34;*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n使用vi命令打开slaves文件进行配置（要与我们前文设置的主机名相互一致，否则将会引起Hadoop相关进程无法正确启动）： vi /usr/cx/hadoop-2.7.1/etc/hadoop/slaves 打开后的文件内容如下所示：\nlocalhost （注：需要对此内容进行更改，配置为Slave节点的实际主机名） 将文件中的内容更改为下列内容：\nrealtime-1 realtime-2 realtime-3 编辑完成后保存文件并退出vi编辑器\n步骤4. 文件分发 通过下面的命令将节点1的Hadoop文件包分发到节点2中： scp -r /usr/cx/hadoop-2.7.1 root@realtime-2:/usr/cx/ 命令运行后的返回结果如下所示：\n（---------------------省略-----------------------） external.png 100% 230 0.2KB/s 00:00 banner.jpg 100% 872 0.9KB/s 00:00 maven-feather.png 100% 3330 3.3KB/s 00:00 build-by-maven-white.png 100% 2260 2.2KB/s 00:00 build-by-maven-black.png 100% 2294 2.2KB/s 00:00 bg.jpg 100% 486 0.5KB/s 00:00 icon_error_sml.gif 100% 1010 1.0KB/s 00:00 logo_apache.jpg 100% 33KB 32.7KB/s 00:00 collapsed.gif 100% 820 0.8KB/s 00:00 apache-maven-project-2.png 100% 33KB 32.7KB/s 00:00 icon_success_sml.gif 100% 990 1.0KB/s 00:00 icon_info_sml.gif 100% 606 0.6KB/s 00:00 h3.jpg 100% 431 0.4KB/s 00:00 maven-logo-2.gif 100% 26KB 25.8KB/s 00:00 h5.jpg 100% 357 0.4KB/s 00:00 newwindow.png 100% 220 0.2KB/s 00:00 icon_warning_sml.gif 100% 576 0.6KB/s 00:00 expanded.gif 100% 52 0.1KB/s 00:00 dependency-analysis.html 100% 21KB 21.3KB/s 00:00 [root@realtime-1 ~]# 通过下面的命令将节点1的Hadoop文件包分发到节点3中： scp -r /usr/cx/hadoop-2.7.1 root@realtime-3:/usr/cx/ 命令运行后的返回结果如下所示：\n（---------------------省略-----------------------） external.png 100% 230 0.2KB/s 00:00 banner.jpg 100% 872 0.9KB/s 00:00 maven-feather.png 100% 3330 3.3KB/s 00:00 build-by-maven-white.png 100% 2260 2.2KB/s 00:00 build-by-maven-black.png 100% 2294 2.2KB/s 00:00 bg.jpg 100% 486 0.5KB/s 00:00 icon_error_sml.gif 100% 1010 1.0KB/s 00:00 logo_apache.jpg 100% 33KB 32.7KB/s 00:00 collapsed.gif 100% 820 0.8KB/s 00:00 apache-maven-project-2.png 100% 33KB 32.7KB/s 00:00 icon_success_sml.gif 100% 990 1.0KB/s 00:00 icon_info_sml.gif 100% 606 0.6KB/s 00:00 h3.jpg 100% 431 0.4KB/s 00:00 maven-logo-2.gif 100% 26KB 25.8KB/s 00:00 h5.jpg 100% 357 0.4KB/s 00:00 newwindow.png 100% 220 0.2KB/s 00:00 icon_warning_sml.gif 100% 576 0.6KB/s 00:00 expanded.gif 100% 52 0.1KB/s 00:00 dependency-analysis.html 100% 21KB 21.3KB/s 00:00 [root@realtime-1 ~]# 步骤5. 配置Hadoop环境变量 通过下列命令使用vi编辑器编辑~/.bashrc文件： vi ~/.bashrc 打开后的文件内容如下所示：\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi export JAVA_HOME=/usr/cx/jdk1.8.0_60 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar export ZK_HOME=/usr/cx/zookeeper-3.4.6 export PATH=$PATH:$ZK_HOME/bin (----------------在此处增加内容-------------------) 在~/.bashrc文件中增加以下内容： export HADOOP_HOME=/usr/cx/hadoop-2.7.1 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 编辑完成后保存文件并退出vi编辑器\n通过下面的命令将节点1的环境变量文件分发到节点2中： scp -r ~/.bashrc root@realtime-2:~/.bashrc 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# scp -r ~/.bashrc root@realtime-2:~/.bashrc .bashrc 100% 502 0.5KB/s 00:00 [root@realtime-1 ~]# 通过下面的命令将节点1的环境变量文件分发到节点3中： scp -r ~/.bashrc root@realtime-3:~/.bashrc 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# scp -r ~/.bashrc root@realtime-3:~/.bashrc .bashrc 100% 502 0.5KB/s 00:00 [root@realtime-1 ~]# 步骤6. 更新环境变量 执行如下命令，更新环境变量： source ~/.bashrc ssh realtime-2 \u0026#34;source ~/.bashrc\u0026#34; ssh realtime-3 \u0026#34;source ~/.bashrc\u0026#34; 步骤7. 验证Hadoop环境变量是否配置成功 通过下列命令验证Hadoop环境变量是否配置成功： hadoop ssh realtime-2 \u0026#34;hadoop\u0026#34; ssh realtime-3 \u0026#34;hadoop\u0026#34; 如果出现如下提示信息，则说明Hadoop安装配置成功： [root@realtime-1 ~]# hadoop Usage: hadoop [--config confdir] [COMMAND | CLASSNAME] CLASSNAME run the class named CLASSNAME or where COMMAND is one of: fs run a generic filesystem user client version print the version jar \u0026lt;jar\u0026gt; run a jar file note: please use \u0026#34;yarn jar\u0026#34; to launch YARN applications, not this command. checknative [-a|-h] check native hadoop and compression libraries availability distcp \u0026lt;srcurl\u0026gt; \u0026lt;desturl\u0026gt; copy file or directories recursively archive -archiveName NAME -p \u0026lt;parent path\u0026gt; \u0026lt;src\u0026gt;* \u0026lt;dest\u0026gt; create a hadoop archive classpath prints the class path needed to get the credential interact with credential providers Hadoop jar and the required libraries daemonlog get/set the log level for each daemon trace view and modify Hadoop tracing settings Most commands print help when invoked w/o parameters. [root@realtime-1 ~]# 如果没有正确输出相关信息，请检查~/.bashrc文件中的Hadoop环境变量是否配置正确，同时请确定是否使用source ~/.bashrc命令更新环境变量配置\n步骤8. 格式化HDFS 通过下列命令格式化HDFS文件系统（如果格式化失败，会有相关的错误日志输出，根据输出内容进行更改即可）：\nhadoop namenode -format 命令运行后的部分显示内容如下所示：\n(-------------------省略------------------------) 18/11/30 11:07:15 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.windows.minutes = 1,5,25 18/11/30 11:07:15 INFO namenode.FSNamesystem: Retry cache on namenode is enabled 18/11/30 11:07:15 INFO namenode.FSNamesystem: Retry cache will use 0.03 of total heap and retry cache entry expiry time is 600000 millis 18/11/30 11:07:15 INFO util.GSet: Computing capacity for map NameNodeRetryCache 18/11/30 11:07:15 INFO util.GSet: VM type = 64-bit 18/11/30 11:07:15 INFO util.GSet: 0.029999999329447746% max memory 966.7 MB = 297.0 KB 18/11/30 11:07:15 INFO util.GSet: capacity = 2^15 = 32768 entries 18/11/30 11:07:16 INFO namenode.FSImage: Allocated new BlockPoolId: BP-348760827-10.1.1.4-1543547236332 18/11/30 11:07:16 INFO common.Storage: Storage directory /hdfs/namenode has been successfully formatted. 18/11/30 11:07:16 INFO namenode.NNStorageRetentionManager: Going to retain 1 images with txid \u0026gt;= 0 18/11/30 11:07:16 INFO util.ExitUtil: Exiting with status 0 18/11/30 11:07:16 INFO namenode.NameNode: SHUTDOWN_MSG: /************************************************************ SHUTDOWN_MSG: Shutting down NameNode at realtime-1/10.1.1.4 ************************************************************/ [root@realtime-1 ~]# 步骤9. 格式化zkfc元数据 通过下面的命令格式化DFSZKFailoverController(ZKFC)元数据（在一个节点中进行处理即可）：\nhdfs zkfc -formatZK 命令运行后的返回结果如下所示：\n（---------------省略------------------） tString=realtime-1:2181,realtime-2:2181,realtime-3:2181 sessionTimeout=5000 watcher=org.apache.hadoop.ha.ActiveStandbyElector$WatcherWithClientRef@10e31a9a 18/11/30 11:37:46 INFO zookeeper.ClientCnxn: Opening socket connection to server realtime-2/10.1.1.3:2181. Will not attempt to authenticate using SASL (unknown error) 18/11/30 11:37:47 INFO zookeeper.ClientCnxn: Socket connection established to realtime-2/10.1.1.3:2181, initiating session 18/11/30 11:37:47 INFO zookeeper.ClientCnxn: Session establishment complete on server realtime-2/10.1.1.3:2181, sessionid = 0x2675e9a37a90000, negotiated timeout = 5000 18/11/30 11:37:47 INFO ha.ActiveStandbyElector: Successfully created /hadoop-ha/HDFScluster in ZK. 18/11/30 11:37:47 INFO ha.ActiveStandbyElector: Session connected. 18/11/30 11:37:47 INFO zookeeper.ZooKeeper: Session: 0x2675e9a37a90000 closed 18/11/30 11:37:47 INFO zookeeper.ClientCnxn: EventThread shut down [root@realtime-1 ~]# 9 Hadoop集群启动运行 我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n步骤1. 启动HDFS相关服务 通过下面的命令可以启动HDFS相关服务： start-dfs.sh 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# start-dfs.sh 18/11/30 11:55:51 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable Starting namenodes on [realtime-2 realtime-1] realtime-2: starting namenode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-namenode-realtime-2.out realtime-1: starting namenode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-namenode-realtime-1.out realtime-1: starting datanode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-datanode-realtime-1.out realtime-2: starting datanode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-datanode-realtime-2.out realtime-3: starting datanode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-datanode-realtime-3.out Starting journal nodes [realtime-1 realtime-2 realtime-3] realtime-1: starting journalnode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-journalnode-realtime-1.out realtime-2: starting journalnode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-journalnode-realtime-2.out realtime-3: starting journalnode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-journalnode-realtime-3.out 18/11/30 11:56:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable Starting ZK Failover Controllers on NN hosts [realtime-2 realtime-1] realtime-2: starting zkfc, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-zkfc-realtime-2.out realtime-1: starting zkfc, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-zkfc-realtime-1.out [root@realtime-1 ~]# 通过下面的命令查看节点1中对应的相关服务： jps ssh realtime-2 \u0026#34;jps\u0026#34; ssh realtime-3 \u0026#34;jps\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# jps 10033 ResourceManager 9427 DataNode 9315 NameNode 2597 QuorumPeerMain 10457 Jps 9625 JournalNode 9818 DFSZKFailoverController 10140 NodeManager 1743 VmServer.jar [root@realtime-1 ~]# 通过下面的命令在节点2中启动ResourceManager进程：\nssh realtime-2 \u0026#34;yarn-daemon.sh start resourcemanager\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;yarn-daemon.sh start resourcemanager\u0026#34; starting resourcemanager, logging to /usr/cx/hadoop-2.7.1/logs/yarn-root-resourcemanager-realtime-2.out [root@realtime-1 ~]# 通过下面的命令查看节点2中对应的相关服务：\nssh realtime-2 \u0026#34;jps\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;jps\u0026#34; 5792 DataNode 6164 NameNode 1703 VmServer.jar 6779 ResourceManager 6428 NodeManager 5981 DFSZKFailoverController 6846 Jps 2686 QuorumPeerMain 5887 JournalNode [root@realtime-1 ~]# 由返回结果可以看出，此时在节点2中已经成功启动了ResourceManager进程\n10 Hadoop 高可用性测试 笔者在写作过程中是在节点1中进行下面的操作，同学们可以在任意节点中进行下面的操作，所实现的效果是一致的\n步骤1. NodeManager状态查看 由于设置了2个NameNode，因此必然会有一个处于Active状态，一个处于StandBy状态，至于具体哪个节点处于Active状态，需要根据实际情况确定，并不是千篇一律的。\n当Hadoop成功启动后，我们打开浏览器，输入网址http://realtime-1:50070便可以访问HDFS的Web管理页面（此时可以看到realtime-1节点是处于active状态的）： 输入网址http://realtime-2:50070依然可以访问HDFS的Web管理页面（此时可以看到realtime-2节点是处于standby状态的）： 步骤2. ResourceManager状态查看 由于设置了2个ResourceManager，因此必然会有一个处于Active状态，一个处于StandBy状态，至于具体哪个节点处于Active状态，需要根据实际情况确定，并不是千篇一律的。\n在终端模拟器中，通过下面的命令可以查看逻辑ID为rm1（实际映射的节点为realtime-1）的节点对应的ResourceManager状态： yarn rmadmin -getServiceState rm1 命令运行后的返回结果如下所示（可见当前节点是active状态）：\n[root@realtime-1 ~]# yarn rmadmin -getServiceState rm1 18/11/30 16:35:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable active [root@realtime-1 ~]# 在终端模拟器中，通过下面的命令可以查看逻辑ID为rm2（实际映射的节点为realtime-2）的节点对应的ResourceManager状态： yarn rmadmin -getServiceState rm2 命令运行后的返回结果如下所示（可见当前节点是standby状态）：\n[root@realtime-1 ~]# yarn rmadmin -getServiceState rm2 18/11/30 16:35:44 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable standby [root@realtime-1 ~]# 步骤3. HDFS高可用测试 通过下面的命令在HDFS中创建测试文件夹/test： hadoop fs -mkdir /test 通过下面的命令查看HDFS中创建的测试文件夹/test： hadoop fs -ls / 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# hadoop fs -ls / 18/11/30 16:40:12 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable Found 1 items drwxr-xr-x - root supergroup 0 2018-11-30 16:39 /test [root@realtime-1 ~]# 由返回结果可以看出，此时依然可以成功查询HDFS文件信息\n打开浏览器，输入网址http://realtime-2:50070访问HDFS的Web管理页面，此时可以看到realtime-2节点已经成功接替成为NameNode并处于active状态（同学们需要根据实际情况来确定）：\n步骤4. YARN高可用测试 通过下面的命令，使用Hadoop自带的案例测试MapReduce应用程序的运行： hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output 18/11/30 16:47:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 18/11/30 16:47:15 INFO input.FileInputFormat: Total input paths to process : 0 18/11/30 16:47:15 INFO mapreduce.JobSubmitter: number of splits:0 18/11/30 16:47:15 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1543557487449_0001 18/11/30 16:47:16 INFO impl.YarnClientImpl: Submitted application application_1543557487449_0001 18/11/30 16:47:16 INFO mapreduce.Job: The url to track the job: http://realtime-1:8089/proxy/application_1543557487449_0001/ 18/11/30 16:47:16 INFO mapreduce.Job: Running job: job_1543557487449_0001 18/11/30 16:47:26 INFO mapreduce.Job: Job job_1543557487449_0001 running in uber mode : false 18/11/30 16:47:26 INFO mapreduce.Job: map 0% reduce 0% 18/11/30 16:47:37 INFO mapreduce.Job: map 0% reduce 100% 18/11/30 16:47:38 INFO mapreduce.Job: Job job_1543557487449_0001 completed successfully 18/11/30 16:47:39 INFO mapreduce.Job: Counters: 38 File System Counters FILE: Number of bytes read=0 FILE: Number of bytes written=119357 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=0 HDFS: Number of bytes written=0 HDFS: Number of read operations=3 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Launched reduce tasks=1 Total time spent by all maps in occupied slots (ms)=0 Total time spent by all reduces in occupied slots (ms)=227232 Total time spent by all reduce tasks (ms)=7101 Total vcore-seconds taken by all reduce tasks=7101 Total megabyte-seconds taken by all reduce tasks=7271424 Map-Reduce Framework Combine input records=0 Combine output records=0 Reduce input groups=0 Reduce shuffle bytes=0 Reduce input records=0 Reduce output records=0 Spilled Records=0 Shuffled Maps =0 Failed Shuffles=0 Merged Map outputs=0 GC time elapsed (ms)=67 CPU time spent (ms)=290 Physical memory (bytes) snapshot=94629888 Virtual memory (bytes) snapshot=2064699392 Total committed heap usage (bytes)=30474240 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Output Format Counters Bytes Written=0 [root@realtime-1 ~]# 通过下面的命令停止Active状态节点对应的ResourceManager进程（笔者写作过程中对应的为realtime-1节点，同学们需要根据实际情况来确定） ssh realtime-1 \u0026#34;yarn-daemon.sh stop resourcemanager\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-1 \u0026#34;yarn-daemon.sh stop resourcemanager\u0026#34; stopping resourcemanager [root@realtime-1 ~]# 通过下面的命令查看对应节点的进程信息： ssh realtime-1 \u0026#34;jps\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-1 \u0026#34;jps\u0026#34; 9427 DataNode 2597 QuorumPeerMain 9625 JournalNode 9818 DFSZKFailoverController 10140 NodeManager 11885 Jps 1743 VmServer.jar [root@realtime-1 ~]# 由返回结果可以看出，ResourceManager进程已经被停止\n通过下面的命令，再次使用Hadoop自带的案例测试MapReduce应用程序的运行： hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output1 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output1 18/11/30 16:50:29 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 18/11/30 16:50:31 INFO client.ConfiguredRMFailoverProxyProvider: Failing over to rm2 18/11/30 16:50:32 INFO input.FileInputFormat: Total input paths to process : 0 18/11/30 16:50:32 INFO mapreduce.JobSubmitter: number of splits:0 18/11/30 16:50:32 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1543567750404_0001 18/11/30 16:50:33 INFO impl.YarnClientImpl: Submitted application application_1543567750404_0001 18/11/30 16:50:33 INFO mapreduce.Job: The url to track the job: http://realtime-2:8089/proxy/application_1543567750404_0001/ 18/11/30 16:50:33 INFO mapreduce.Job: Running job: job_1543567750404_0001 18/11/30 16:50:45 INFO mapreduce.Job: Job job_1543567750404_0001 running in uber mode : false 18/11/30 16:50:45 INFO mapreduce.Job: map 0% reduce 0% 18/11/30 16:50:53 INFO mapreduce.Job: map 0% reduce 100% 18/11/30 16:50:54 INFO mapreduce.Job: Job job_1543567750404_0001 completed successfully 18/11/30 16:50:54 INFO mapreduce.Job: Counters: 38 File System Counters FILE: Number of bytes read=0 FILE: Number of bytes written=119358 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=0 HDFS: Number of bytes written=0 HDFS: Number of read operations=3 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Launched reduce tasks=1 Total time spent by all maps in occupied slots (ms)=0 Total time spent by all reduces in occupied slots (ms)=147936 Total time spent by all reduce tasks (ms)=4623 Total vcore-seconds taken by all reduce tasks=4623 Total megabyte-seconds taken by all reduce tasks=4733952 Map-Reduce Framework Combine input records=0 Combine output records=0 Reduce input groups=0 Reduce shuffle bytes=0 Reduce input records=0 Reduce output records=0 Spilled Records=0 Shuffled Maps =0 Failed Shuffles=0 Merged Map outputs=0 GC time elapsed (ms)=81 CPU time spent (ms)=280 Physical memory (bytes) snapshot=94146560 Virtual memory (bytes) snapshot=2064695296 Total committed heap usage (bytes)=30474240 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Output Format Counters Bytes Written=0 [root@realtime-1 ~]# 由返回结果可以看出，此时YARN依然可以可靠的实现任务的调度\n在终端模拟器中，通过下面的命令可以查看逻辑ID为rm2（实际映射的节点为realtime-2）的节点对应的ResourceManager状态（同学们需要根据实际情况来确定）： yarn rmadmin -getServiceState rm2 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# yarn rmadmin -getServiceState rm2 18/11/30 16:51:39 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable active [root@realtime-1 ~]# 由返回结果可以看出，当前节点已经自动成功接替变成了active状态\n","permalink":"https://waite.wang/posts/bigdata/hadoop-install-and-config/","summary":"\u003ch3 id=\"安装jdk\"\u003e安装JDK\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e1.创建工作路径\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emkdir /usr/cx\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e2.解压安装包\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etar -zxvf 安装包位置 -C /usr/cx\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e3.配置环境变量\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003evi ~/.bashrc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在打开的~/.bashrc文件中写入一下内容\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-gdscript3\" data-lang=\"gdscript3\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# .bashrc\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# User specific aliases and functions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ealias\u003c/span\u003e \u003cspan class=\"n\"\u003erm\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;rm -i\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ealias\u003c/span\u003e \u003cspan class=\"n\"\u003ecp\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;cp -i\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ealias\u003c/span\u003e \u003cspan class=\"n\"\u003emv\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;mv -i\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# Source global definitions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003eetc\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ebashrc\u003c/span\u003e \u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"n\"\u003ethen\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e.\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003eetc\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ebashrc\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003efi\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e----------------\u003c/span\u003e\u003cspan class=\"err\"\u003e注：需要在此处增加内容\u003c/span\u003e\u003cspan class=\"o\"\u003e-------------------\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"err\"\u003e在这添加\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"n\"\u003eJAVA_HOME\u003c/span\u003e\u003cspan class=\"o\"\u003e=/\u003c/span\u003e\u003cspan class=\"n\"\u003eusr\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ecx\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ejdk名字版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"n\"\u003ePATH\u003c/span\u003e\u003cspan class=\"o\"\u003e=$\u003c/span\u003e\u003cspan class=\"n\"\u003eJAVA_HOME\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ebin\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"o\"\u003e$\u003c/span\u003e\u003cspan class=\"n\"\u003ePATH\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eexport\u003c/span\u003e \u003cspan class=\"n\"\u003eCLASSPATH\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"o\"\u003e$\u003c/span\u003e\u003cspan class=\"n\"\u003eJAVA_HOME\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ejre\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003elib\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ert\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejar\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"o\"\u003e$\u003c/span\u003e\u003cspan class=\"n\"\u003eJAVA_HOME\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003ejre\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003elib\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003etools\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ejar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e4.更新环境变量\u003c/strong\u003e\u003c/p\u003e","title":"hadoop的安装与配置"},{"content":"Hadoop基础 1 、实验目的 通过本节实验的学习，同学们可以掌握Hadoop集群环境部署与配置。本实验完成后，要求学生掌握以下内容：\n掌握集群所有节点之间SSH免密登录配置方式；\n掌握NTP服务配置，实现节点间的时间同步；\n掌握ZooKeeper集群的搭建方式；\n掌握Hadoop集群的搭建配置流程；\n理解Hadoop集群的高可用（HA）原理，并掌握Hadoop集群的高可用（HA）配置方法。\n2、实验原理 需要按照以下流程，在Linux上进行Hadoop集群的安装部署：\n主机名配置：在大型的Hadoop集群中，往往由成百上千个节点组成，如果通过IP地址对不同节点进行管理，那么集群维护的工作量将会十分繁重，因此在工程环境中，常常通过对每个节点设置唯一的主机名，从而实现对节点进行管理。\nSSH（安全外壳协议）免密码登录配置：推荐安装OpenSSH。Hadoop需要通过SSH来启动Slave列表中各台主机的守护进程，因此SSH也是必须安装的。\n安装配置JDK1.7（或更高版本）：Hadoop是用Java编写的程序，Hadoop的编译及MapReduce的运行都需要使用JDK，因此在安装Hadoop前，必须安装JDK1.7或更高版本。\nNTP服务配置：本实验需要在实现Hadoop集群搭建的同时，并进行高可用性（HA）的配置，因此需要通过ZooKeeper来对集群中的节点进行协调，而ZooKeeper需要保证节点间的时钟相互一致，因此需要在集群中配置NTP服务。\nSElinux安全配置：CentOS默认启用了SElinux，在网络服务方面权限要求比较严格，因此需要对SElinux安全配置进行更改。\nZooKeeper集群搭建：高可用性（HA）Hadoop集群的搭建需要依赖于ZooKeeper来对集群中的节点进行协调，因此需要进行ZooKeeper集群搭建。\nHadoop核心配置。Hadoop的稳定运行需要依赖于其核心配置文件，因此当上述准备工作就绪后，我们便需要着重进行配置文件编写来实现Hadoop的可靠运行。\n我们需要在节点1、节点2、节点3中进行高可用Hadoop集群环境的部署。各个节点所部署的服务如下所示：\n节点1 节点2 节点3 NameNode StandBy ResourceManager StandBy DFSZKFailoverController DFSZKFailoverController DataNode DataNode DataNode NodeManager NodeManager NodeManager JournalNode JournalNode JournalNode 1 集群节点基本配置 步骤1. 节点IP地址查询 在节点1、2、3中通过下面的命令查询节点IP地址： ifconfig 命令运行后的返回结果如下所示 (每台虚拟机的IP地址都是不同的，因此需要以实际地址信息为准）：\n[root@CentOS6 ~]# ifconfig eth6 Link encap:Ethernet HWaddr 02:00:1E:79:09:04 inet addr:10.1.1.4 Bcast:10.1.1.255 Mask:255.255.255.0 inet6 addr: fe80::1eff:fe79:904/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:20832 errors:0 dropped:0 overruns:0 frame:0 TX packets:13052 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:31392026 (29.9 MiB) TX bytes:929956 (908.1 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:16436 Metric:1 RX packets:12 errors:0 dropped:0 overruns:0 frame:0 TX packets:12 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:720 (720.0 b) TX bytes:720 (720.0 b) [root@CentOS6 ~]# 需要记录三个节点的IP地址，在后文中我们需要根据此IP地址进行相关操作\n步骤2. 节点主机名配置 需要在节点1、2、3进行下列操作，将三个主机名分别配置为realtime-1，realtime-2，realtime-3\n通过下列命令使用vi编辑器编辑主机名配置文件： vi /etc/sysconfig/network 打开后的文件内容如下所示：\nNETWORKING=yes HOSTNAME=CentOS6.5 (注：需要将此行内容修改为实际的主机名realtime-1、realtime-2、realtime-3) 在文件中进行内容更改，将HOSTNAME字段内容配置成realtime-： HOSTNAME=realtime-1 编辑完成后保存文件并退出vi编辑器\n更改后的文件内容如下所示：\n更改后的内容会在下次系统重启的时候生效，通过下列命令重新启动系统： reboot 步骤3. 节点1、2、3主机名与IP地址映射文件配置 在节点1、2、3中，通过下列命令使用vi编辑器编辑hosts文件： vi /etc/hosts 打开后的文件内容如下所示：\n127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 (注：在此行增加内容) ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 增加节点1、2、3的IP地址与主机名的映射关系、节点间的IP地址与主机名的映射关系、节点间的IP地址与主机名的映射关系，IP地址与主机名之间用空格分隔（主机名填写为前文配置的节点实际主机名称，IP地址需要根据上文中的查询结果来进行填写，并与实际的主机名相对应）： 10.1.1.4 realtime-1 10.1.1.3 realtime-2 10.1.1.206 realtime-3 更改后的文件内容如下所示\n127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 10.1.1.4 realtime-1 10.1.1.3 realtime-2 10.1.1.206 realtime-3 编辑完成后保存文件并退出vi编辑器\n通过下列命令检测主机名与IP映射是否配置成功： ping realtime-1 -c 2 如果配置成功，则会显示如下结果：\n[root@realtime-1 ~]# ping realtime-1 -c 2 (注：通过此命令向realtime-1节点发送2个报文) PING realtime-1 (10.1.1.4) 56(84) bytes of data. 64 bytes from realtime-1 (10.1.1.4): icmp_seq=1 ttl=64 time=1.98 ms 64 bytes from realtime-1 (10.1.1.4): icmp_seq=2 ttl=64 time=0.341 ms --- realtime-1 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.341/1.163/1.985/0.822 ms [root@realtime-1 ~]# 通过下列命令检测主机名与IP映射是否配置成功： ping realtime-2 -c 2 如果配置成功，则会显示如下结果：\n[root@realtime-1 ~]# ping realtime-2 -c 2 (注：通过此命令向realtime-2节点发送2个报文) PING realtime-2 (10.1.1.3) 56(84) bytes of data. 64 bytes from realtime-2 (10.1.1.3): icmp_seq=1 ttl=64 time=0.047 ms 64 bytes from realtime-2 (10.1.1.3): icmp_seq=2 ttl=64 time=0.026 ms --- realtime-2 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 999ms rtt min/avg/max/mdev = 0.026/0.036/0.047/0.012 ms [root@realtime-1 ~]# 通过下列命令检测主机名与IP映射是否配置成功： ping realtime-3 -c 2 如果配置成功，则会显示如下结果：\n[root@realtime-1 ~]# ping realtime-3 -c 2 (注：通过此命令向realtime-3节点发送2个报文) PING realtime-3 (10.1.1.206) 56(84) bytes of data. 64 bytes from realtime-3 (10.1.1.206): icmp_seq=1 ttl=64 time=1.36 ms 64 bytes from realtime-3 (10.1.1.206): icmp_seq=2 ttl=64 time=0.315 ms --- realtime-3 ping statistics --- 2 packets transmitted, 2 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.315/0.841/1.367/0.526 ms [root@realtime-1 ~]# 如果无法进行正常的报文发送，请检查主机名是否配置正确，同时请检查主机名与IP地址映射是否配置正确。\n2 配置SSH免密码登录 步骤1. 节点1、2、3秘钥配置及分发 例如节点1 : 需要在节点1进行下列操作，在节点1中生成秘钥文件，然后将公钥文件分发到节点2和节点3中，实现在节点1可以免密码登录到集群中的其他主机中。\n通过下面的命令生成密钥（使用rsa加密方式）： echo -e \u0026#34;\\n\u0026#34;|ssh-keygen -t rsa -N \u0026#34;\u0026#34; \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 默认情况下会在~/.ssh/文件夹下生成公钥文件id_rsa.pub和私钥文件id_rsa，通过下面的命令对~/.ssh/内容进行查看：\nll ~/.ssh/ 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ll ~/.ssh/ 总用量 8 -rw-------. 1 root root 1675 11月 29 13:42 id_rsa -rw-r--r--. 1 root root 397 11月 29 13:42 id_rsa.pub [root@realtime-1 ~]# 通过下面的命令将公钥文件发送到本机以及其他两个节点，创建root免密钥通道（需要输入密码：111111）： ssh-copy-id -i /root/.ssh/id_rsa.pub root@realtime-1 # 其他的节点需要随之改动root@realtime-2 and root@realtime-3 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh-copy-id -i /root/.ssh/id_rsa.pub root@realtime-1 The authenticity of host \u0026#39;realtime-1 (10.1.1.4)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is 9f:3b:30:10:65:46:c9:c3:2b:fb:e5:28:38:39:9c:84. Are you sure you want to continue connecting (yes/no)? yes (注：此处需要输入yes) Warning: Permanently added \u0026#39;realtime-1,10.1.1.4\u0026#39; (RSA) to the list of known hosts. root@realtime-1\u0026#39;s password: （注：此处需要输入root用户密码，为111111） Now try logging into the machine, with \u0026#34;ssh \u0026#39;root@realtime-1\u0026#39;\u0026#34;, and check in: .ssh/authorized_keys to make sure we haven\u0026#39;t added extra keys that you weren\u0026#39;t expecting. [root@realtime-1 ~]# 步骤2. SSH免密码登录测试 集群中各个节点秘钥分发完毕后，可以通过ssh远程登录命令来测试免密码登录是否配置成功。为了操作统一，我们在节点3中进行下面的操作（在其他节点操作所实现的效果也是一样的）\n在节点3中通过下面的命令可以实现免密码远程登录到节点1： ssh realtime-1 #依次运行realtime-2 and realtime-3 命令运行后的返回结果如下所示：\n[root@realtime-3 ~]# ssh realtime-1 Last login: Thu Nov 29 14:08:34 2018 from realtime-3 [root@realtime-1 ~]# 如果从源主机到目的主机的登录过程中，出现需要输入密码的情况，那么需要检查是否已经成功将源主机的公钥文件发送到目的主机中\n3 安装配置JDK1.8 JDK需要在集群3个节点都进行安装，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n我们可以在Oracle JDK的官网下载相应版本的JDK，官网地址为:http://www.oracle.com/technetwork/java/javase/downloads/index.html\n步骤1. 创建工作路径 首先需要在终端中输入下列命令，在/usr目录下建立cx工作路径： mkdir /usr/cx 通过下面的命令实现在节点2和节点3的/usr目录下建立cx工作路径： ssh realtime-2 \u0026#34;mkdir /usr/cx\u0026#34; ssh realtime-3 \u0026#34;mkdir /usr/cx\u0026#34; 步骤2. 解压安装包 我们可以在/usr/software/目录下找到jdk-8u60-linux-x64.tar.gz安装包，通过下列命令将其解压到/usr/cx/目录下： tar -zxvf /usr/software/jdk-8u60-linux-x64.tar.gz -C /usr/cx 命令执行后的输出内容如下所示：\n(-------------------省略------------------------) jdk1.8.0_60/bin/jmc.ini jdk1.8.0_60/bin/jmap jdk1.8.0_60/bin/serialver jdk1.8.0_60/bin/wsgen jdk1.8.0_60/bin/jrunscript jdk1.8.0_60/bin/javah jdk1.8.0_60/bin/javac jdk1.8.0_60/bin/jvisualvm jdk1.8.0_60/bin/jcontrol jdk1.8.0_60/release [root@realtime-1 ~]# 通过下列命令实现在节点2和节点3中将jdk-8u60-linux-x64.tar.gz安装包解压到/usr/cx/目录下： ssh realtime-2 \u0026#34;tar -zxvf /usr/software/jdk-8u60-linux-x64.tar.gz -C /usr/cx\u0026#34; ssh realtime-3 \u0026#34;tar -zxvf /usr/software/jdk-8u60-linux-x64.tar.gz -C /usr/cx\u0026#34; 步骤3. 配置环境变量 通过下列命令使用vi编辑器打开 ~/.bashrc文件： vi ~/.bashrc 打开的~/.bashrc文件内容如下所示：\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi (----------------注：需要在此处增加内容-------------------) 在文件中写入下列内容： export JAVA_HOME=/usr/cx/jdk1.8.0_60 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar 编辑完成后保存文件并退出vi编辑器。\n通过下面的命令将环境变量配置文件分发到节点2和节点3： scp ~/.bashrc root@realtime-2:~/.bashrc scp ~/.bashrc root@realtime-3:~/.bashrc 命令执行后的输出内容如下所示：\n[root@realtime-1 ~]# scp ~/.bashrc root@realtime-2:~/.bashrc .bashrc 100% 320 0.3KB/s 00:00 [root@realtime-1 ~]# 步骤4. 更新环境变量 执行如下命令，更新环境变量： source ~/.bashrc 执行如下命令，更新节点2和节点3的环境变量： ssh realtime-2 \u0026#34;source ~/.bashrc\u0026#34; ssh realtime-3 \u0026#34;source ~/.bashrc\u0026#34; 步骤5. 验证JDK是否配置成功 通过下面的命令验证JDK是否安装并配置成功： java -version 如果出现如下JDK版本信息，则说明安装配置成功：\n[root@realtime-1 ~]# java -version java version \u0026#34;1.8.0_60\u0026#34; (注：JDK版本号) Java(TM) SE Runtime Environment (build 1.8.0_60-b27) (注：Java运行环境版本号) Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode) [root@realtime-1 ~]# 通过下面的命令验证节点2和节点3的JDK是否安装并配置成功： ssh realtime-2 \u0026#34;java -version\u0026#34; ssh realtime-3 \u0026#34;java -version\u0026#34; 如果没有正确输出相关版本信息，请检查~/.bashrc文件中的JDK环境变量是否配置正确，同时请确定是否使用source ~/.bashrc命令更新环境变量配置\n4 NTP服务配置 需要在集群的3台节点中都进行NTP服务的配置\n步骤1. NTP服务配置 在节点1、节点2、节点3中通过下面的命令打开NTP配置文件： vi /etc/ntp.conf 打开后的文件内容如下所示：\n（---------------省略----------------） # Permit all access over the loopback interface. This could # be tightened as well, but to do so would effect some of # the administrative functions. restrict 127.0.0.1 restrict -6 ::1 # Hosts on local network are less restricted. #restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap # Use public servers from the pool.ntp.org project. # Please consider joining the pool (http://www.pool.ntp.org/join.html). server 0.centos.pool.ntp.org iburst （注：注释此行内容） server 1.centos.pool.ntp.org iburst （注：注释此行内容） server 2.centos.pool.ntp.org iburst （注：注释此行内容） server 3.centos.pool.ntp.org iburst （注：注释此行内容） （注：在此处增加内容） #broadcast 192.168.1.255 autokey # broadcast server （---------------省略----------------） 在文件中进行下列内容更改（通过server字段设置本机为NTP Serevr服务器，通过restrict限制realtime-2和realtime-3主机名对应的主机可以同步时间）：\n#server 0.centos.pool.ntp.org iburst #server 1.centos.pool.ntp.org iburst #server 2.centos.pool.ntp.org iburst #server 3.centos.pool.ntp.org iburst server 127.127.1.0 fudge 127.127.1.0 stratum 10 restrict realtime-2 nomodify notrap restrict realtime-3 nomodify notrap 更改完成后保存文件并退出编辑器\n步骤2. 启动NTP服务 为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行。\n通过下面的命令在节点1中设定NTP服务自启动： chkconfig ntpd on 通过下面的命令在节点1中启动NTP服务： service ntpd start 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# service ntpd start 正在启动 ntpd： [确定] [root@realtime-1 ~]# 通过下面的命令在节点2中设定NTP服务自启动： ssh realtime-2 \u0026#34;chkconfig ntpd on\u0026#34; 通过下面的命令在节点2中启动NTP服务： ssh realtime-2 \u0026#34;service ntpd start\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;service ntpd start\u0026#34; 正在启动 ntpd：[确定] [root@realtime-1 ~]# 通过下面的命令在节点3中设定NTP服务自启动： ssh realtime-3 \u0026#34;chkconfig ntpd on\u0026#34; 通过下面的命令在节点3中启动NTP服务： ssh realtime-3 \u0026#34;service ntpd start\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-3 \u0026#34;service ntpd start\u0026#34; 正在启动 ntpd：[确定] [root@realtime-1 ~]# 如果服务无法正常启动，会出现相关的错误提示信息，只需要根据错误提示进行更改即可。\n步骤3. NTP服务状态查看 为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行。\n通过下面的命令查看节点1中NTP服务的运行状态： ntpstat 命令运行后的返回结果如下所示（由于节点1是作为Server节点，所以其状态会很快变成synchronised，此时说明服务已经正常启动）：\n[root@realtime-1 ~]# ntpstat synchronised to local net at stratum 11 time correct to within 449 ms polling server every 64 s [root@realtime-1 ~]# 通过下面的命令查看节点2和节点三中NTP服务的运行状态： ssh realtime-2 \u0026#34;ntpstat\u0026#34; ssh realtime-3 \u0026#34;ntpstat\u0026#34; 命令运行后的返回结果如下所示（由于节点2需要同步节点1的时间，因此需要大概15分钟其状态才会由unsynchronised会变成synchronised，当状态变为synchronised时说明服务已经正常启动）：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;ntpstat\u0026#34; unsynchronised polling server every 64 s [root@realtime-1 ~]# 服务正常启动后的状态如下所示：\n[root@realtime-1 ~]# ssh realtime-3 \u0026#34;ntpstat\u0026#34; synchronised to NTP server (10.1.1.4) at stratum 12 time correct to within 25 ms polling server every 64 s [root@realtime-1 ~]# 当3个节点的状态都显示为synchronised时，则表示ntp服务已经启动成功；如果一直显示unsynchronised,可能是配置文件有错误，因此需要检查IP地址是否配置正确。\n同学们不必一直等待，可以先进行下文的实验，然后过后再查看NTP服务状态。\n5 SElinux安全配置 需要在集群3个节点都进行SElinux配置，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行。\n通过下面的命令，关闭节点1、节点2、节点3的SElinux安全设置： /bin/sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/\u0026#39; /etc/selinux/config ssh realtime-2 \u0026#34;/bin/sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/\u0026#39; /etc/selinux/config\u0026#34; ssh realtime-3 \u0026#34;/bin/sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/\u0026#39; /etc/selinux/config\u0026#34; 6 安装配置ZooKeeper集群 由于我们需要搭建一套具备高可用性的Hadoop集群，因此需要通过ZooKeeper来进行集群中服务的协调。ZooKeeper需要在集群3个节点进行安装配置，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n在模板中我们已经将ZooKeeper安装文件zookeeper-3.4.6.tar.gz放到了/usr/software目录下，同学们可以直接使用\n步骤1. 解压安装包 通过下列命令将ZooKeeper安装包解压到/usr/cx目录下： tar -zxvf /usr/software/zookeeper-3.4.6.tar.gz -C /usr/cx 命令运行后的返回结果如下所示：\n(---------------------省略--------------------) zookeeper-3.4.6/recipes/queue/test/org/apache/zookeeper/recipes/queue/DistributedQueueTest.java zookeeper-3.4.6/recipes/queue/build.xml zookeeper-3.4.6/zookeeper-3.4.6.jar zookeeper-3.4.6/lib/ zookeeper-3.4.6/lib/cobertura/ zookeeper-3.4.6/lib/cobertura/README.txt zookeeper-3.4.6/lib/jline-0.9.94.jar zookeeper-3.4.6/lib/log4j-1.2.16.LICENSE.txt zookeeper-3.4.6/lib/slf4j-log4j12-1.6.1.jar zookeeper-3.4.6/lib/jdiff/ zookeeper-3.4.6/lib/jdiff/zookeeper_3.1.1.xml zookeeper-3.4.6/lib/jdiff/zookeeper_3.4.6-SNAPSHOT.xml zookeeper-3.4.6/lib/jdiff/zookeeper_3.4.6.xml zookeeper-3.4.6/lib/slf4j-api-1.6.1.jar zookeeper-3.4.6/lib/log4j-1.2.16.jar zookeeper-3.4.6/lib/netty-3.7.0.Final.jar zookeeper-3.4.6/lib/jline-0.9.94.LICENSE.txt [root@realtime-1 ~]# 解压完成后，我们可以查看解压后的文件夹内容： ls /usr/cx/zookeeper-3.4.6/ 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ls /usr/cx/zookeeper-3.4.6/ bin dist-maven LICENSE.txt src build.xml docs NOTICE.txt zookeeper-3.4.6.jar CHANGES.txt ivysettings.xml README_packaging.txt zookeeper-3.4.6.jar.asc conf ivy.xml README.txt zookeeper-3.4.6.jar.md5 contrib lib recipes zookeeper-3.4.6.jar.sha1 [root@realtime-1 ~]# 步骤2. 数据存储目录创建 通过下面的命令创建ZooKeeper数据存储目录： mkdir -p /home/data 通过下面的命令创建ZooKeeper日志存储目录：\nmkdir -p /home/logs 通过下面的命令在节点2、节点3中创建ZooKeeper数据存储目录： ssh realtime-2 \u0026#34;mkdir -p /home/data\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /home/data\u0026#34; 通过下面的命令在节点2、节点3中创建ZooKeeper日志存储目录：\nssh realtime-2 \u0026#34;mkdir -p /home/logs\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /home/logs\u0026#34; 步骤3. 主机myid编号文件创建 通过下面的命令创建myid文件，并设置节点1对应的编号为1（集群启动后会通过此编号来进行主机识别）： echo \u0026#34;1\u0026#34; \u0026gt; /home/data/myid 通过下面的命令在节点2中创建myid文件，并设置节点2对应的编号为2（集群启动后会通过此编号来进行主机识别）： ssh realtime-2 \u0026#34;echo \u0026#34;2\u0026#34; \u0026gt; /home/data/myid\u0026#34; 通过下面的命令在节点3中创建myid文件，并设置节点3对应的编号为3（集群启动后会通过此编号来进行主机识别）： ssh realtime-3 \u0026#34;echo \u0026#34;3\u0026#34; \u0026gt; /home/data/myid\u0026#34; 步骤4. ZooKeeper配置文件编辑 通过下列命令创建并打开zoo.cfg配置文件： vi /usr/cx/zookeeper-3.4.6/conf/zoo.cfg 在文件中写入下列内容：\ntickTime=2000 dataDir=/home/data clientPort=2181 dataLogDir=/home/logs initLimit=5 syncLimit=2 server.1=realtime-1:2888:3888 server.2=realtime-2:2888:3888 server.3=realtime-3:2888:3888 编辑完成后保存文件并退出vi编辑器。\n在上述配置中，我们设置心跳时间为2000毫秒，设置ZooKeeper在本地保存数据的目录为/home/data，ZooKeeper监听客户端连接的端口为2181,设置所有Follower和Leader进行同步的时间为5s，设置一个Follower和Leader进行同步的时间为2s。同时设定集群中有3台主机，其中realtime-1对应的主机编号为1，Follower与Leader之间交换信息的端口为2888，进行Leader选举的端口为3888；realtime-2对应的主机编号为2，Follower与Leader之间交换信息的端口为2888，进行Leader选举的端口为3888；realtime-3对应的主机编号为3，Follower与Leader之间交换信息的端口为2888，进行Leader选举的端口为3888。\n步骤5. 文件分发 通过下面的命令将节点1的ZooKeeper文件包分发到节点2、节点3中： scp -r /usr/cx/zookeeper-3.4.6 root@realtime-2:/usr/cx/ scp -r /usr/cx/zookeeper-3.4.6 root@realtime-3:/usr/cx/ 命令运行后的返回结果如下所示：\n（----------------------省略------------------------） Makefile.am 100% 74 0.1KB/s 00:00 zkServer.cmd 100% 1084 1.1KB/s 00:00 zkEnv.sh 100% 2696 2.6KB/s 00:00 zkCleanup.sh 100% 1937 1.9KB/s 00:00 zkCli.sh 100% 1534 1.5KB/s 00:00 zkEnv.cmd 100% 1333 1.3KB/s 00:00 zkCli.cmd 100% 1049 1.0KB/s 00:00 README.txt 100% 238 0.2KB/s 00:00 zkServer.sh 100% 5742 5.6KB/s 00:00 NOTICE.txt 100% 170 0.2KB/s 00:00 zookeeper-3.4.6.jar.md5 100% 33 0.0KB/s 00:00 README.txt 100% 1585 1.6KB/s 00:00 CHANGES.txt 100% 79KB 78.9KB/s 00:00 zookeeper-3.4.6.jar.sha1 100% 41 0.0KB/s 00:00 [root@realtime-1 ~]# 步骤6. ZooKeeper环境变量配置 通过下列命令使用vi编辑器打开 ~/.bashrc文件： vi ~/.bashrc 打开的~/.bashrc文件内容如下所示：\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi export JAVA_HOME=/usr/cx/jdk1.8.0_60 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar (----------------注：需要在此处增加内容-------------------) 在文件中写入下列内容： export ZK_HOME=/usr/cx/zookeeper-3.4.6 export PATH=$PATH:$ZK_HOME/bin 编辑完成后保存文件并退出vi编辑器。\n通过下面的命令将环境变量配置文件分发到节点2和节点3： scp ~/.bashrc root@realtime-2:~/.bashrc scp ~/.bashrc root@realtime-3:~/.bashrc 步骤7. 更新环境变量 执行如下命令，更新环境变量： source ~/.bashrc ssh realtime-2 \u0026#34;source ~/.bashrc\u0026#34; ssh realtime-3 \u0026#34;source ~/.bashrc\u0026#34; 步骤8. 验证环境变量是否配置成功 通过下面的命令验证环境变量是否配置成功： zkServer.sh ssh realtime-2 \u0026#34;zkServer.sh\u0026#34; ssh realtime-3 \u0026#34;zkServer.sh\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# zkServer.sh JMX enabled by default Using config: /usr/cx/zookeeper-3.4.6/bin/../conf/zoo.cfg Usage: /usr/cx/zookeeper-3.4.6/bin/zkServer.sh {start|start-foreground|stop|restart|status|upgrade|print-cmd} [root@realtime-1 ~]# 由输出内容可以看出，ZooKeeper环境变量已经配置正确，并且可以正常执行。\n7 ZooKeeper启动及状态查看 步骤1. ZooKeeper启动 通过下面的命令启动ZooKeeper服务： zkServer.sh start ssh realtime-2 \u0026#34;zkServer.sh start\u0026#34; ssh realtime-3 \u0026#34;zkServer.sh start\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# zkServer.sh start JMX enabled by default Using config: /usr/cx/zookeeper-3.4.6/bin/../conf/zoo.cfg Starting zookeeper ... STARTED [root@realtime-1 ~]# 步骤2. ZooKeeper运行状态查看 ZooKeeper运行之后会随机进行follower角色以及leader角色选举，当leader角色节点出现异常后，会从其他节点中选举出新的leader角色。至于具体哪个节点处于leader状态，需要根据实际情况确定，并不是千篇一律的\n通过下面的命令可以查看ZooKeeper运行状态：\nzkServer.sh status ssh realtime-2 \u0026#34;zkServer.sh status\u0026#34; ssh realtime-3 \u0026#34;zkServer.sh status\u0026#34; 命令运行后的返回结果如下所示（由返回结果的Mode字段可以看出，当前节点是作为follower角色运行的）：\n[root@realtime-1 ~]# zkServer.sh status JMX enabled by default Using config: /usr/cx/zookeeper-3.4.6/bin/../conf/zoo.cfg Mode: follower [root@realtime-1 ~]# 8 安装配置Hadoop集群 Hadoop需要在集群3个节点进行安装配置，为了操作方便，我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n在模板中，我们已经将相应的Hadoop安装包hadoop-2.7.1.tar.gz放到/usr/software/目录下，同学们不需要再次下载，可以直接使用。\n步骤1. 数据存储目录创建 mkdir -p /hdfs/namenode mkdir -p /hdfs/datanode mkdir -p /hdfs/journalnode mkdir -p /var/log/hadoop-yarn ssh realtime-2 \u0026#34;mkdir -p /hdfs/namenode\u0026#34; ssh realtime-2 \u0026#34;mkdir -p /hdfs/datanode\u0026#34; ssh realtime-2 \u0026#34;mkdir -p /hdfs/journalnode\u0026#34; ssh realtime-2 \u0026#34;mkdir -p /var/log/hadoop-yarn\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /hdfs/namenode\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /hdfs/datanode\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /hdfs/journalnode\u0026#34; ssh realtime-3 \u0026#34;mkdir -p /var/log/hadoop-yarn\u0026#34; 步骤2. 解压安装文件 通过下列命令解压Hadoop安装文件，将文件解压到/usr/cx目录下：\ntar -zxvf /usr/software/hadoop-2.7.1.tar.gz -C /usr/cx 命令执行后的输出内容如下所示：\n(-------------------省略------------------------) hadoop-2.7.1/libexec/hdfs-config.sh hadoop-2.7.1/README.txt hadoop-2.7.1/NOTICE.txt hadoop-2.7.1/lib/ hadoop-2.7.1/lib/native/ hadoop-2.7.1/lib/native/libhadoop.a hadoop-2.7.1/lib/native/libhadoop.so hadoop-2.7.1/lib/native/libhadooppipes.a hadoop-2.7.1/lib/native/libhdfs.so.0.0.0 hadoop-2.7.1/lib/native/libhadooputils.a hadoop-2.7.1/lib/native/libhdfs.a hadoop-2.7.1/lib/native/libhdfs.so hadoop-2.7.1/lib/native/libhadoop.so.1.0.0 hadoop-2.7.1/LICENSE.txt [root@master ~]# 步骤3. 编辑Hadoop配置文件： 使用vi命令打开hadoop-env.sh配置文件进行编辑： vi /usr/cx/hadoop-2.7.1/etc/hadoop/hadoop-env.sh 打开后的文件内容如下所示：\n(-------------------省略------------------------) # Set Hadoop-specific environment variables here. # The only required environment variable is JAVA_HOME. All others are # optional. When running a distributed configuration it is best to # set JAVA_HOME in this file, so that it is correctly defined on # remote nodes. # The java implementation to use. export JAVA_HOME=${JAVA_HOME} (注：需要对此行内容进行更改，为Hadoop绑定Java运行环境) # The jsvc implementation to use. Jsvc is required to run secure datanodes # that bind to privileged ports to provide authentication of data transfer # protocol. Jsvc is not required if SASL is configured for authentication of # data transfer protocol using non-privileged ports. #export JSVC_HOME=${JSVC_HOME} export HADOOP_CONF_DIR=${HADOOP_CONF_DIR:-\u0026#34;/etc/hadoop\u0026#34;} (-------------------省略------------------------) 在文件中进行下列内容更改，将JAVA_HOME对应的值改成实际的JDK安装路径：\nexport JAVA_HOME=/usr/cx/jdk1.8.0_60\n编辑完成后保存文件并退出vi编辑器。\n使用vi命令打开hdfs-site.xml文件进行配置： vi /usr/cx/hadoop-2.7.1/etc/hadoop/hdfs-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;/configuration\u0026gt; 在文件中\u0026lt;configuration\u0026gt;和\u0026lt;/configuration\u0026gt;之间增加下列内容：\n/*配置DataNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.datanode.data.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/hdfs/datanode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置数据块大小为256M*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.blocksize\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;268435456\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*自定义的HDFS服务名，在高可用集群中，无法配置单一HDFS服务器入口，所以需要指定一个逻辑上的服务名，当访问服务名时，会自动选择NameNode节点进行访问*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.nameservices\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HDFScluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置NameNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.name.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/hdfs/namenode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*定义HDFS服务名所指向的NameNode主机名称*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.namenodes.HDFScluster\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1,realtime-2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的完整监听地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.rpc-address.HDFScluster.realtime-1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:8020\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的完整监听地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.rpc-address.HDFScluster.realtime-2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2:8020\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的HTTP访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.http-address.HDFScluster.realtime-1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:50070\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置NameNode的HTTP访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.http-address.HDFScluster.realtime-2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2:50070\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置主从NameNode元数据同步地址，官方推荐将nameservice作为最后的journal ID*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.shared.edits.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;qjournal://realtime-1:8485;realtime-2:8485;realtime-3:8485/HDFScluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置HDFS客户端用来连接集群中活动状态NameNode节点的Java类*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.client.failover.proxy.provider.HDFScluster\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置SSH登录的私钥文件地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.fencing.ssh.private-key-files\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/root/.ssh/id_rsa\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*启动fence过程，确保集群高可用性*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.fencing.methods\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;shell(/bin/true)\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置JournalNode的数据存储目录，需要与上文创建的目录相对应*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.journalnode.edits.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/hdfs/journalnode\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置自动切换活跃节点，保证集群高可用性*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.ha.automatic-failover.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置数据块副本数*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*将dfs.webhdfs.enabled属性设置为true，否则就不能使用webhdfs的LISTSTATUS、LIST FILESTATUS等需要列出文件、文件夹状态的命令，因为这些信息都是由namenode保存的*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.webhdfs.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n在集群中，对HDFS集群访问的入口是NameNode所在的服务器。但是在两个NameNode节点的HA集群中，无法配置单一服务器入口，所以需要通过dfs.nameservices指定一个逻辑上的服务名，这个服务名是自定义的。当外界访问HDFS集群时，入口就变为这个服务名称，Hadoop会自动实现将访问请求转发到实际的处于Active状态的NameNode节点上。\n当配置了HDFS HA集群时，会有两个NameNode，为了避免两个NameNode都为Active状态，当发生failover时，Standby的节点要执行一系列方法把原来那个Active节点中不健康的NameNode服务给杀掉（这个过程就称为fence）。而dfs.ha.fencing.methods配置就是配置了执行杀死原来Active NameNode服务的方法，为了保险起见，因此指定无论如何都把StandBy节点的状态提升为Active，所以最后要配置一个shell(/bin/true)，保证不论前面的方法执行的情况如何，最后fence过程返回的结果都为True。fence操作需要通过SSH进行节点间的访问，因此需要配置dfs.ha.fencing.ssh.private-key-files为所需要用到的私钥文件路径信息。\n使用vi命令打开core-site.xml配置文件进行编辑： vi /usr/cx/hadoop-2.7.1/etc/hadoop/core-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;/configuration\u0026gt; 在文件中和之间增加下列内容：\n/*设置默认的HDFS访问路径，需要与hdfs-site.xml中的HDFS服务名相一致*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://HDFScluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*临时文件夹路径设置*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/usr/tmp\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*配置ZooKeeper服务集群，用于活跃NameNode节点的选举*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;ha.zookeeper.quorum\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:2181,realtime-2:2181,realtime-3:2181\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置数据压缩算法*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;io.compression.codecs\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.io.compress.DefaultCodec,org.apache.hadoop.io.compress.GzipCodec,org.apache.hadoop.io.compress.BZip2Codec,com.hadoop.compression.lzo.LzoCodec,com.hadoop.compression.lzo.LzopCodec,org.apache.hadoop.io.compress.SnappyCodec\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;io.compression.codec.lzo.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;com.hadoop.compression.lzo.LzoCodec\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置使用hduser用户可以代理所有主机用户进行任务提交*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.proxyuser.hduser.host\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;*\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置使用hduser用户可以代理所有组用户进行任务提交*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.proxyuser.hduser.groups\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;*\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n对HDFS集群访问的入口是NameNode所在的服务器，但是在两个NameNode节点的HA集群中，无法配置单一服务器入口，所以需要在hdfs-site.xml中通过dfs.nameservices指定一个逻辑上的服务名，因此此处的fs.defaultFS配置的入口地址需要与hdfs-site.xml中dfs.nameservices所配置的一致。\n使用vi命令打开yarn-site.xml文件进行配置： vi /usr/cx/hadoop-2.7.1/etc/hadoop/yarn-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;!-- Site specific YARN configuration properties --\u0026gt; \u0026lt;/configuration\u0026gt; 在文件中和之间增加下列内容：\n/*设置NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services.mapreduce_shuffle.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.mapred.ShuffleHandler\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置任务日志存储目录*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.log-dirs\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;file:///var/log/hadoop-yarn \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置Hadoop依赖包地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.application.classpath\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt; $HADOOP_HOME/share/hadoop/common/*,$HADOOP_HOME/share/hadoop/common/lib/*, $HADOOP_HOME/share/hadoop/hdfs/*,$HADOOP_HOME/share/hadoop/hdfs/lib/*, $HADOOP_HOME/share/hadoop/mapreduce/*,$HADOOP_HOME/share/hadoop/mapreduce/lib/*, $HADOOP_HOME/share/hadoop/yarn/*,$HADOOP_HOME/share/hadoop/yarn/lib/* \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*开启resourcemanager 的高可用性功能*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.ha.enabled\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*标识集群中的resourcemanager，如果设置该选项，需要确保所有的resourcemanager节点在配置中都有自己的逻辑id*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.cluster-id\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;YARNcluster\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置resourcemanager节点的逻辑id*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.ha.rm-ids\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;rm1,rm2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*为每个逻辑id绑定实际的主机名称*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.hostname.rm1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.hostname.rm2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*指定ZooKeeper服务地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.zk-address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:2181,realtime-2:2181,realtime-3:2181\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*指定resourcemanager的WEB访问地址*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.webapp.address.rm1\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-1:8089\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.webapp.address.rm2\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;realtime-2:8089\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定虚拟内存与实际内存的比例，比例值越高，则可用虚拟内存就越多*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.vmem-pmem-ratio\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定单个容器可以申领到的最小内存资源*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.scheduler.minimum-allocation-mb\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;32\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置当任务运行结束后，日志文件被转移到的HDFS目录*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.remote-app-log-dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://HDFScluster/var/log/hadoop-yarn/apps\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定资源调度策略，目前可用的有FIFO、Capacity Scheduler和Fair Scheduler*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.scheduler.class\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity.CapacityScheduler\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定每个任务能够申领到的最大虚拟CPU数目*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.scheduler.maximum-allocation-vcores\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;8\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置任务完成指定时间（秒）之后，删除任务的本地化文件和日志目录*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.delete.debug-delay-sec\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;600\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设置志在HDFS上保存多长时间（秒）*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.log.retain-seconds\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;86400\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; /*设定物理节点有2G内存加入资源池*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.resource.memory-mb\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;2048\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n在集群中，提交任务的入口是ResourceManager所在的服务器。但是在两个ResourceManager节点的HA集群中，无法配置单一服务器入口，所以需要通过yarn.resourcemanager.cluster-id指定一个逻辑上的服务名，这个服务名是自定义的。当外界向集群提交任务时，入口就变为这个服务名称，YARN会自动实现将访问请求转发到实际的处于Active状态的ResourceManager节点上。由于配置了逻辑服务名，所以需要设置resourcemanager节点的逻辑id，并为每个逻辑id绑定实际的主机名称\n使用下列命令复制mapred-site.xml.template文件并重命名为mapred-site.xml： cp /usr/cx/hadoop-2.7.1/etc/hadoop/mapred-site.xml.template /usr/cx/hadoop-2.7.1/etc/hadoop/mapred-site.xml 使用vi命令打开mapred-site.xml文件进行配置： vi /usr/cx/hadoop-2.7.1/etc/hadoop/mapred-site.xml 打开后的文件内容如下所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;configuration.xsl\u0026#34;?\u0026gt; \u0026lt;!-- Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. See accompanying LICENSE file. --\u0026gt; \u0026lt;!-- Put site-specific property overrides in this file. --\u0026gt; \u0026lt;configuration\u0026gt; (注：需要在此处进行相关内容配置) \u0026lt;/configuration\u0026gt; 在文件中和之间增加下列内容：\n/*Hadoop对MapReduce运行框架一共提供了3种实现，在mapred-site.xml中通过\u0026#34;mapreduce.framework.name\u0026#34;这个属性来设置为\u0026#34;classic\u0026#34;、\u0026#34;yarn\u0026#34;或者\u0026#34;local\u0026#34;*/ \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; 编辑完成后保存文件并退出vi编辑器\n使用vi命令打开slaves文件进行配置（要与我们前文设置的主机名相互一致，否则将会引起Hadoop相关进程无法正确启动）： vi /usr/cx/hadoop-2.7.1/etc/hadoop/slaves 打开后的文件内容如下所示：\nlocalhost （注：需要对此内容进行更改，配置为Slave节点的实际主机名） 将文件中的内容更改为下列内容：\nrealtime-1 realtime-2 realtime-3 编辑完成后保存文件并退出vi编辑器\n步骤4. 文件分发 通过下面的命令将节点1的Hadoop文件包分发到节点2中： scp -r /usr/cx/hadoop-2.7.1 root@realtime-2:/usr/cx/ 命令运行后的返回结果如下所示：\n（---------------------省略-----------------------） external.png 100% 230 0.2KB/s 00:00 banner.jpg 100% 872 0.9KB/s 00:00 maven-feather.png 100% 3330 3.3KB/s 00:00 build-by-maven-white.png 100% 2260 2.2KB/s 00:00 build-by-maven-black.png 100% 2294 2.2KB/s 00:00 bg.jpg 100% 486 0.5KB/s 00:00 icon_error_sml.gif 100% 1010 1.0KB/s 00:00 logo_apache.jpg 100% 33KB 32.7KB/s 00:00 collapsed.gif 100% 820 0.8KB/s 00:00 apache-maven-project-2.png 100% 33KB 32.7KB/s 00:00 icon_success_sml.gif 100% 990 1.0KB/s 00:00 icon_info_sml.gif 100% 606 0.6KB/s 00:00 h3.jpg 100% 431 0.4KB/s 00:00 maven-logo-2.gif 100% 26KB 25.8KB/s 00:00 h5.jpg 100% 357 0.4KB/s 00:00 newwindow.png 100% 220 0.2KB/s 00:00 icon_warning_sml.gif 100% 576 0.6KB/s 00:00 expanded.gif 100% 52 0.1KB/s 00:00 dependency-analysis.html 100% 21KB 21.3KB/s 00:00 [root@realtime-1 ~]# 通过下面的命令将节点1的Hadoop文件包分发到节点3中： scp -r /usr/cx/hadoop-2.7.1 root@realtime-3:/usr/cx/ 命令运行后的返回结果如下所示：\n（---------------------省略-----------------------） external.png 100% 230 0.2KB/s 00:00 banner.jpg 100% 872 0.9KB/s 00:00 maven-feather.png 100% 3330 3.3KB/s 00:00 build-by-maven-white.png 100% 2260 2.2KB/s 00:00 build-by-maven-black.png 100% 2294 2.2KB/s 00:00 bg.jpg 100% 486 0.5KB/s 00:00 icon_error_sml.gif 100% 1010 1.0KB/s 00:00 logo_apache.jpg 100% 33KB 32.7KB/s 00:00 collapsed.gif 100% 820 0.8KB/s 00:00 apache-maven-project-2.png 100% 33KB 32.7KB/s 00:00 icon_success_sml.gif 100% 990 1.0KB/s 00:00 icon_info_sml.gif 100% 606 0.6KB/s 00:00 h3.jpg 100% 431 0.4KB/s 00:00 maven-logo-2.gif 100% 26KB 25.8KB/s 00:00 h5.jpg 100% 357 0.4KB/s 00:00 newwindow.png 100% 220 0.2KB/s 00:00 icon_warning_sml.gif 100% 576 0.6KB/s 00:00 expanded.gif 100% 52 0.1KB/s 00:00 dependency-analysis.html 100% 21KB 21.3KB/s 00:00 [root@realtime-1 ~]# 步骤5. 配置Hadoop环境变量 通过下列命令使用vi编辑器编辑~/.bashrc文件： vi ~/.bashrc 打开后的文件内容如下所示：\n# .bashrc # User specific aliases and functions alias rm=\u0026#39;rm -i\u0026#39; alias cp=\u0026#39;cp -i\u0026#39; alias mv=\u0026#39;mv -i\u0026#39; # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi export JAVA_HOME=/usr/cx/jdk1.8.0_60 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/tools.jar export ZK_HOME=/usr/cx/zookeeper-3.4.6 export PATH=$PATH:$ZK_HOME/bin (----------------在此处增加内容-------------------) 在~/.bashrc文件中增加以下内容： export HADOOP_HOME=/usr/cx/hadoop-2.7.1 export PATH=$PATH:$HADOOP_HOME/bin export PATH=$PATH:$HADOOP_HOME/sbin 编辑完成后保存文件并退出vi编辑器\n通过下面的命令将节点1的环境变量文件分发到节点2中： scp -r ~/.bashrc root@realtime-2:~/.bashrc 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# scp -r ~/.bashrc root@realtime-2:~/.bashrc .bashrc 100% 502 0.5KB/s 00:00 [root@realtime-1 ~]# 通过下面的命令将节点1的环境变量文件分发到节点3中： scp -r ~/.bashrc root@realtime-3:~/.bashrc 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# scp -r ~/.bashrc root@realtime-3:~/.bashrc .bashrc 100% 502 0.5KB/s 00:00 [root@realtime-1 ~]# 步骤6. 更新环境变量 执行如下命令，更新环境变量： source ~/.bashrc ssh realtime-2 \u0026#34;source ~/.bashrc\u0026#34; ssh realtime-3 \u0026#34;source ~/.bashrc\u0026#34; 步骤7. 验证Hadoop环境变量是否配置成功 通过下列命令验证Hadoop环境变量是否配置成功： hadoop ssh realtime-2 \u0026#34;hadoop\u0026#34; ssh realtime-3 \u0026#34;hadoop\u0026#34; 如果出现如下提示信息，则说明Hadoop安装配置成功： [root@realtime-1 ~]# hadoop Usage: hadoop [--config confdir] [COMMAND | CLASSNAME] CLASSNAME run the class named CLASSNAME or where COMMAND is one of: fs run a generic filesystem user client version print the version jar \u0026lt;jar\u0026gt; run a jar file note: please use \u0026#34;yarn jar\u0026#34; to launch YARN applications, not this command. checknative [-a|-h] check native hadoop and compression libraries availability distcp \u0026lt;srcurl\u0026gt; \u0026lt;desturl\u0026gt; copy file or directories recursively archive -archiveName NAME -p \u0026lt;parent path\u0026gt; \u0026lt;src\u0026gt;* \u0026lt;dest\u0026gt; create a hadoop archive classpath prints the class path needed to get the credential interact with credential providers Hadoop jar and the required libraries daemonlog get/set the log level for each daemon trace view and modify Hadoop tracing settings Most commands print help when invoked w/o parameters. [root@realtime-1 ~]# 如果没有正确输出相关信息，请检查~/.bashrc文件中的Hadoop环境变量是否配置正确，同时请确定是否使用source ~/.bashrc命令更新环境变量配置\n步骤8. 格式化HDFS 通过下列命令格式化HDFS文件系统（如果格式化失败，会有相关的错误日志输出，根据输出内容进行更改即可）：\nhadoop namenode -format 命令运行后的部分显示内容如下所示：\n(-------------------省略------------------------) 18/11/30 11:07:15 INFO metrics.TopMetrics: NNTop conf: dfs.namenode.top.windows.minutes = 1,5,25 18/11/30 11:07:15 INFO namenode.FSNamesystem: Retry cache on namenode is enabled 18/11/30 11:07:15 INFO namenode.FSNamesystem: Retry cache will use 0.03 of total heap and retry cache entry expiry time is 600000 millis 18/11/30 11:07:15 INFO util.GSet: Computing capacity for map NameNodeRetryCache 18/11/30 11:07:15 INFO util.GSet: VM type = 64-bit 18/11/30 11:07:15 INFO util.GSet: 0.029999999329447746% max memory 966.7 MB = 297.0 KB 18/11/30 11:07:15 INFO util.GSet: capacity = 2^15 = 32768 entries 18/11/30 11:07:16 INFO namenode.FSImage: Allocated new BlockPoolId: BP-348760827-10.1.1.4-1543547236332 18/11/30 11:07:16 INFO common.Storage: Storage directory /hdfs/namenode has been successfully formatted. 18/11/30 11:07:16 INFO namenode.NNStorageRetentionManager: Going to retain 1 images with txid \u0026gt;= 0 18/11/30 11:07:16 INFO util.ExitUtil: Exiting with status 0 18/11/30 11:07:16 INFO namenode.NameNode: SHUTDOWN_MSG: /************************************************************ SHUTDOWN_MSG: Shutting down NameNode at realtime-1/10.1.1.4 ************************************************************/ [root@realtime-1 ~]# 步骤9. 格式化zkfc元数据 通过下面的命令格式化DFSZKFailoverController(ZKFC)元数据（在一个节点中进行处理即可）：\nhdfs zkfc -formatZK 命令运行后的返回结果如下所示：\n（---------------省略------------------） tString=realtime-1:2181,realtime-2:2181,realtime-3:2181 sessionTimeout=5000 watcher=org.apache.hadoop.ha.ActiveStandbyElector$WatcherWithClientRef@10e31a9a 18/11/30 11:37:46 INFO zookeeper.ClientCnxn: Opening socket connection to server realtime-2/10.1.1.3:2181. Will not attempt to authenticate using SASL (unknown error) 18/11/30 11:37:47 INFO zookeeper.ClientCnxn: Socket connection established to realtime-2/10.1.1.3:2181, initiating session 18/11/30 11:37:47 INFO zookeeper.ClientCnxn: Session establishment complete on server realtime-2/10.1.1.3:2181, sessionid = 0x2675e9a37a90000, negotiated timeout = 5000 18/11/30 11:37:47 INFO ha.ActiveStandbyElector: Successfully created /hadoop-ha/HDFScluster in ZK. 18/11/30 11:37:47 INFO ha.ActiveStandbyElector: Session connected. 18/11/30 11:37:47 INFO zookeeper.ZooKeeper: Session: 0x2675e9a37a90000 closed 18/11/30 11:37:47 INFO zookeeper.ClientCnxn: EventThread shut down [root@realtime-1 ~]# 9 Hadoop集群启动运行 我们在节点1进行下列操作，在节点1中通过ssh远程登录到节点2和节点3中，实现命令的分发与运行\n步骤1. 启动HDFS相关服务 通过下面的命令可以启动HDFS相关服务： start-dfs.sh 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# start-dfs.sh 18/11/30 11:55:51 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable Starting namenodes on [realtime-2 realtime-1] realtime-2: starting namenode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-namenode-realtime-2.out realtime-1: starting namenode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-namenode-realtime-1.out realtime-1: starting datanode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-datanode-realtime-1.out realtime-2: starting datanode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-datanode-realtime-2.out realtime-3: starting datanode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-datanode-realtime-3.out Starting journal nodes [realtime-1 realtime-2 realtime-3] realtime-1: starting journalnode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-journalnode-realtime-1.out realtime-2: starting journalnode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-journalnode-realtime-2.out realtime-3: starting journalnode, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-journalnode-realtime-3.out 18/11/30 11:56:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable Starting ZK Failover Controllers on NN hosts [realtime-2 realtime-1] realtime-2: starting zkfc, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-zkfc-realtime-2.out realtime-1: starting zkfc, logging to /usr/cx/hadoop-2.7.1/logs/hadoop-root-zkfc-realtime-1.out [root@realtime-1 ~]# 通过下面的命令查看节点1中对应的相关服务： jps ssh realtime-2 \u0026#34;jps\u0026#34; ssh realtime-3 \u0026#34;jps\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# jps 10033 ResourceManager 9427 DataNode 9315 NameNode 2597 QuorumPeerMain 10457 Jps 9625 JournalNode 9818 DFSZKFailoverController 10140 NodeManager 1743 VmServer.jar [root@realtime-1 ~]# 通过下面的命令在节点2中启动ResourceManager进程：\nssh realtime-2 \u0026#34;yarn-daemon.sh start resourcemanager\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;yarn-daemon.sh start resourcemanager\u0026#34; starting resourcemanager, logging to /usr/cx/hadoop-2.7.1/logs/yarn-root-resourcemanager-realtime-2.out [root@realtime-1 ~]# 通过下面的命令查看节点2中对应的相关服务：\nssh realtime-2 \u0026#34;jps\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-2 \u0026#34;jps\u0026#34; 5792 DataNode 6164 NameNode 1703 VmServer.jar 6779 ResourceManager 6428 NodeManager 5981 DFSZKFailoverController 6846 Jps 2686 QuorumPeerMain 5887 JournalNode [root@realtime-1 ~]# 由返回结果可以看出，此时在节点2中已经成功启动了ResourceManager进程\n10 Hadoop 高可用性测试 笔者在写作过程中是在节点1中进行下面的操作，同学们可以在任意节点中进行下面的操作，所实现的效果是一致的\n步骤1. NodeManager状态查看 由于设置了2个NameNode，因此必然会有一个处于Active状态，一个处于StandBy状态，至于具体哪个节点处于Active状态，需要根据实际情况确定，并不是千篇一律的。\n当Hadoop成功启动后，我们打开浏览器，输入网址http://realtime-1:50070便可以访问HDFS的Web管理页面（此时可以看到realtime-1节点是处于active状态的）： 输入网址http://realtime-2:50070依然可以访问HDFS的Web管理页面（此时可以看到realtime-2节点是处于standby状态的）： 步骤2. ResourceManager状态查看 由于设置了2个ResourceManager，因此必然会有一个处于Active状态，一个处于StandBy状态，至于具体哪个节点处于Active状态，需要根据实际情况确定，并不是千篇一律的。\n在终端模拟器中，通过下面的命令可以查看逻辑ID为rm1（实际映射的节点为realtime-1）的节点对应的ResourceManager状态： yarn rmadmin -getServiceState rm1 命令运行后的返回结果如下所示（可见当前节点是active状态）：\n[root@realtime-1 ~]# yarn rmadmin -getServiceState rm1 18/11/30 16:35:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable active [root@realtime-1 ~]# 在终端模拟器中，通过下面的命令可以查看逻辑ID为rm2（实际映射的节点为realtime-2）的节点对应的ResourceManager状态： yarn rmadmin -getServiceState rm2 命令运行后的返回结果如下所示（可见当前节点是standby状态）：\n[root@realtime-1 ~]# yarn rmadmin -getServiceState rm2 18/11/30 16:35:44 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable standby [root@realtime-1 ~]# 步骤3. HDFS高可用测试 通过下面的命令在HDFS中创建测试文件夹/test： hadoop fs -mkdir /test 通过下面的命令查看HDFS中创建的测试文件夹/test： hadoop fs -ls / 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# hadoop fs -ls / 18/11/30 16:40:12 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable Found 1 items drwxr-xr-x - root supergroup 0 2018-11-30 16:39 /test [root@realtime-1 ~]# 由返回结果可以看出，此时依然可以成功查询HDFS文件信息\n打开浏览器，输入网址http://realtime-2:50070访问HDFS的Web管理页面，此时可以看到realtime-2节点已经成功接替成为NameNode并处于active状态（同学们需要根据实际情况来确定）：\n步骤4. YARN高可用测试 通过下面的命令，使用Hadoop自带的案例测试MapReduce应用程序的运行： hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output 18/11/30 16:47:11 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 18/11/30 16:47:15 INFO input.FileInputFormat: Total input paths to process : 0 18/11/30 16:47:15 INFO mapreduce.JobSubmitter: number of splits:0 18/11/30 16:47:15 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1543557487449_0001 18/11/30 16:47:16 INFO impl.YarnClientImpl: Submitted application application_1543557487449_0001 18/11/30 16:47:16 INFO mapreduce.Job: The url to track the job: http://realtime-1:8089/proxy/application_1543557487449_0001/ 18/11/30 16:47:16 INFO mapreduce.Job: Running job: job_1543557487449_0001 18/11/30 16:47:26 INFO mapreduce.Job: Job job_1543557487449_0001 running in uber mode : false 18/11/30 16:47:26 INFO mapreduce.Job: map 0% reduce 0% 18/11/30 16:47:37 INFO mapreduce.Job: map 0% reduce 100% 18/11/30 16:47:38 INFO mapreduce.Job: Job job_1543557487449_0001 completed successfully 18/11/30 16:47:39 INFO mapreduce.Job: Counters: 38 File System Counters FILE: Number of bytes read=0 FILE: Number of bytes written=119357 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=0 HDFS: Number of bytes written=0 HDFS: Number of read operations=3 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Launched reduce tasks=1 Total time spent by all maps in occupied slots (ms)=0 Total time spent by all reduces in occupied slots (ms)=227232 Total time spent by all reduce tasks (ms)=7101 Total vcore-seconds taken by all reduce tasks=7101 Total megabyte-seconds taken by all reduce tasks=7271424 Map-Reduce Framework Combine input records=0 Combine output records=0 Reduce input groups=0 Reduce shuffle bytes=0 Reduce input records=0 Reduce output records=0 Spilled Records=0 Shuffled Maps =0 Failed Shuffles=0 Merged Map outputs=0 GC time elapsed (ms)=67 CPU time spent (ms)=290 Physical memory (bytes) snapshot=94629888 Virtual memory (bytes) snapshot=2064699392 Total committed heap usage (bytes)=30474240 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Output Format Counters Bytes Written=0 [root@realtime-1 ~]# 通过下面的命令停止Active状态节点对应的ResourceManager进程（笔者写作过程中对应的为realtime-1节点，同学们需要根据实际情况来确定） ssh realtime-1 \u0026#34;yarn-daemon.sh stop resourcemanager\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-1 \u0026#34;yarn-daemon.sh stop resourcemanager\u0026#34; stopping resourcemanager [root@realtime-1 ~]# 通过下面的命令查看对应节点的进程信息： ssh realtime-1 \u0026#34;jps\u0026#34; 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# ssh realtime-1 \u0026#34;jps\u0026#34; 9427 DataNode 2597 QuorumPeerMain 9625 JournalNode 9818 DFSZKFailoverController 10140 NodeManager 11885 Jps 1743 VmServer.jar [root@realtime-1 ~]# 由返回结果可以看出，ResourceManager进程已经被停止\n通过下面的命令，再次使用Hadoop自带的案例测试MapReduce应用程序的运行： hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output1 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# hadoop jar /usr/cx/hadoop-2.7.1/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.1.jar wordcount /test /output1 18/11/30 16:50:29 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 18/11/30 16:50:31 INFO client.ConfiguredRMFailoverProxyProvider: Failing over to rm2 18/11/30 16:50:32 INFO input.FileInputFormat: Total input paths to process : 0 18/11/30 16:50:32 INFO mapreduce.JobSubmitter: number of splits:0 18/11/30 16:50:32 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1543567750404_0001 18/11/30 16:50:33 INFO impl.YarnClientImpl: Submitted application application_1543567750404_0001 18/11/30 16:50:33 INFO mapreduce.Job: The url to track the job: http://realtime-2:8089/proxy/application_1543567750404_0001/ 18/11/30 16:50:33 INFO mapreduce.Job: Running job: job_1543567750404_0001 18/11/30 16:50:45 INFO mapreduce.Job: Job job_1543567750404_0001 running in uber mode : false 18/11/30 16:50:45 INFO mapreduce.Job: map 0% reduce 0% 18/11/30 16:50:53 INFO mapreduce.Job: map 0% reduce 100% 18/11/30 16:50:54 INFO mapreduce.Job: Job job_1543567750404_0001 completed successfully 18/11/30 16:50:54 INFO mapreduce.Job: Counters: 38 File System Counters FILE: Number of bytes read=0 FILE: Number of bytes written=119358 FILE: Number of read operations=0 FILE: Number of large read operations=0 FILE: Number of write operations=0 HDFS: Number of bytes read=0 HDFS: Number of bytes written=0 HDFS: Number of read operations=3 HDFS: Number of large read operations=0 HDFS: Number of write operations=2 Job Counters Launched reduce tasks=1 Total time spent by all maps in occupied slots (ms)=0 Total time spent by all reduces in occupied slots (ms)=147936 Total time spent by all reduce tasks (ms)=4623 Total vcore-seconds taken by all reduce tasks=4623 Total megabyte-seconds taken by all reduce tasks=4733952 Map-Reduce Framework Combine input records=0 Combine output records=0 Reduce input groups=0 Reduce shuffle bytes=0 Reduce input records=0 Reduce output records=0 Spilled Records=0 Shuffled Maps =0 Failed Shuffles=0 Merged Map outputs=0 GC time elapsed (ms)=81 CPU time spent (ms)=280 Physical memory (bytes) snapshot=94146560 Virtual memory (bytes) snapshot=2064695296 Total committed heap usage (bytes)=30474240 Shuffle Errors BAD_ID=0 CONNECTION=0 IO_ERROR=0 WRONG_LENGTH=0 WRONG_MAP=0 WRONG_REDUCE=0 File Output Format Counters Bytes Written=0 [root@realtime-1 ~]# 由返回结果可以看出，此时YARN依然可以可靠的实现任务的调度\n在终端模拟器中，通过下面的命令可以查看逻辑ID为rm2（实际映射的节点为realtime-2）的节点对应的ResourceManager状态（同学们需要根据实际情况来确定）： yarn rmadmin -getServiceState rm2 命令运行后的返回结果如下所示：\n[root@realtime-1 ~]# yarn rmadmin -getServiceState rm2 18/11/30 16:51:39 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable active [root@realtime-1 ~]# 由返回结果可以看出，当前节点已经自动成功接替变成了active状态\n","permalink":"https://waite.wang/posts/bigdata/hadoop-group-install-and-config/","summary":"\u003ch1 id=\"hadoop基础\"\u003eHadoop基础\u003c/h1\u003e\n\u003ch3 id=\"1-实验目的\"\u003e1 、实验目的\u003c/h3\u003e\n\u003cp\u003e通过本节实验的学习，同学们可以掌握Hadoop集群环境部署与配置。本实验完成后，要求学生掌握以下内容：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e掌握集群所有节点之间SSH免密登录配置方式；\u003c/p\u003e","title":"hadoop集群的安装与配置"},{"content":" https://v2.cn.vuejs.org/\n简单使用 https://v2.cn.vuejs.org/v2/guide/installation.html\n直接用 script 引入\n直接下载并用 标签引入，Vue 会被注册为一个全局变量。(在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!)\nCDN 对于制作原型或学习，你可以这样使用最新版本：\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 如果你使用原生 ES Modules，这里也有一个兼容 ES Module 的构建文件：\n\u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import Vue from \u0026#39;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.esm.browser.js\u0026#39; \u0026lt;/script\u0026gt; 你可以在 cdn.jsdelivr.net/npm/vue 浏览 NPM 包的源代码。 Vue 也可以在 unpkg 和 cdnjs 上获取 (cdnjs 的版本更新可能略滞后)。\n请确认了解不同构建版本并在你发布的站点中使用生产环境版本，把 vue.js 换成 vue.min.js。这是一个更小的构建，可以带来比开发环境下更快的速度体验。\n在用 Vue 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。 # 最新稳定版 $ npm install vue@^2 响应式与插值 响应式数据与插值表达式 let value = \u0026#39;hello world\u0026#39;; document.getElementById(\u0026#39;box\u0026#39;).innerHTML = value; // 更改数据, 还要在进行一次 DOM 操作 value = \u0026#39;hello vue\u0026#39;; document.getElementById(\u0026#39;box\u0026#39;).innerHTML = value; 在内部对数据做操作, 会自动更新到页面视图上, 省去了手动操作 DOM 的步骤\n\u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;!-- 1.2 插值表达式 --\u0026gt; \u0026lt;p\u0026gt;{{ title }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ content }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ title + content }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ title ? content : \u0026#39;hello\u0026#39; }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const vm = new Vue({ // 1. 响应式数据与插值表达式 // 在内部对数据做操作, 会自动更新到页面视图上, 省去了手动操作 DOM 的步骤 el: \u0026#39;#box\u0026#39;, // el 选项用于指定一个页面中已存在的 DOM 元素来挂载 Vue 实例 data() { return { title: \u0026#39;hello world\u0026#39;, content: \u0026#39;hello vue\u0026#39; } } }) // 1.3 通过 vm 实例来访问数据 vm.title = \u0026#39;hello vue\u0026#39; \u0026lt;/script\u0026gt; 方法以及计算属性 Methods 属性 \u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ output() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ output() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ output() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ outputContent }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ outputContent }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ outputContent }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const vm = new Vue({ el: \u0026#39;#box\u0026#39;, // methods 选项用于定义方法, 该方法可以在插值表达式中使用 methods: { output() { console.log(\u0026#39;output\u0026#39;); } }, // 1.3 计算属性, 具有缓存性 computed: { outputContent() { console.log(\u0026#39;outputContent\u0026#39;); } } }) \u0026lt;/script\u0026gt; 以上代码 console 结果\noutput output output outputContent 计算属性 计算属性, Methods 具有缓存性质, 当我们进行第一次计算的时候, 它会将计算结果在内部做一个缓存, 当我们再次调用的时候, 它会直接返回缓存的结果, 不会再次执行函数(插值不能加括号)\n\u0026lt;div id=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ outputContent }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ output() }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ outputContent }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ outputContent }}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const vm = new Vue({ el: \u0026#39;#box\u0026#39;, // methods 选项用于定义方法, 该方法可以在插值表达式中使用 data() { return { message: \u0026#39;Hello World\u0026#39; } }, methods: { output() { this.message = \u0026#39;Hello Vue\u0026#39;; } }, computed: { outputContent() { console.log(`computed: ${this.message}`); } } }) \u0026lt;/script\u0026gt; // console 结果 Hello World Hello Vue 侦听器 监听响应式数据的变化, 自动 Vue 内部实现, 可以参与内部函数变化\nwatch: { message: function (newVal, oldVal) { console.log(newVal, oldVal) } } 指令 内容指令 \u0026lt;!-- 内容指令 --\u0026gt; \u0026lt;p v-text=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p v-html=\u0026#34;htmlContent\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; data() { return { message: \u0026#39;Hello World\u0026#39;, htmlContent: \u0026#39;\u0026lt;span style=\u0026#34;color: red\u0026#34;\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;, } } \u0026lt;/script\u0026gt; // Hello World // Hello World(红色) 渲染指令 区别：v-if 会在判定条件为假时，将元素从 DOM 中移除，v-show 会将元素的 display 属性设置为 none, 一般使用 v-show\n\u0026lt;!-- 渲染指令 --\u0026gt; \u0026lt;!-- v-if 判定条件为真时，渲染元素 --\u0026gt; \u0026lt;p v-if=\u0026#34;bool\u0026#34;\u0026gt;message 存在\u0026lt;/p\u0026gt; \u0026lt;p v-show=\u0026#34;bool\u0026#34;\u0026gt;message 存在\u0026lt;/p\u0026gt; \u0026lt;p v-for=\u0026#34;(item, key, index) in obj\u0026#34;\u0026gt;{{ item }} {{ key }} {{ index }}\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; data() { return { message: \u0026#39;Hello World\u0026#39;, htmlContent: \u0026#39;\u0026lt;span style=\u0026#34;color: red\u0026#34;\u0026gt;Hello World\u0026lt;/span\u0026gt;\u0026#39;, obj: { name: \u0026#39;张三\u0026#39;, age: 18 }, bool: true } } \u0026lt;/script\u0026gt; // message 存在 // message 存在 // 张三 name 0 // 18 age 1 属性指令 具体可以看 https://v2.cn.vuejs.org/v2/guide/class-and-style.html, 可以修改标签属性\n\u0026lt;!-- 属性指令 --\u0026gt; \u0026lt;p v-bind:title=\u0026#34;title\u0026#34;\u0026gt;message\u0026lt;/p\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;p :title=\u0026#34;title\u0026#34;\u0026gt;message\u0026lt;/p\u0026gt; \u0026lt;!-- https://v2.cn.vuejs.org/v2/guide/class-and-style.html --\u0026gt; 事件指令 \u0026lt;!-- 事件指令 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;alterMsg\u0026#34;\u0026gt;修改 message\u0026lt;/button\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;button @click=\u0026#34;alterMsg\u0026#34;\u0026gt;修改 message\u0026lt;/button\u0026gt; 表单指令 v-model 可以实现双向数据绑定, 即数据的变化会影响视图，视图的变化也会影响数据\n\u0026lt;!-- v-model 可以实现双向数据绑定 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; 修饰符 在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n具体可以看 https://v2.cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6\n以下为示例\n\u0026lt;!-- 修饰符 --\u0026gt; \u0026lt;!-- 实现原始内容的替换 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;p v-text=\u0026#34;message\u0026#34; style=\u0026#34;white-space: pre; \u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;!-- 在视图中，HTML中的连续空格会被默认合并为一个空格，并不会完全保留。 所以在代码中的 \u0026lt;p\u0026gt; {{message}}\u0026lt;/p\u0026gt; 中，连续的空格会被合并为一个空格，并且在渲染时不会显示多个空格。 可以使用CSS中的 white-space 属性来控制文本的处理方式 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model.trim=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;script\u0026gt; data() { return { message: \u0026#39;Hello World\u0026#39; } } \u0026lt;/script\u0026gt; 一些基本修饰符\n.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件之后进行同步：\n\u0026lt;!-- 在“change”时而非“input”时更新 --\u0026gt; \u0026lt;input v-model.lazy=\u0026#34;msg\u0026#34;\u0026gt; .number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：\n\u0026lt;input v-model.number=\u0026#34;age\u0026#34; type=\u0026#34;number\u0026#34;\u0026gt; 这通常很有用，因为即使在 type=\u0026ldquo;number\u0026rdquo; 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。\n.trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：\n\u0026lt;input v-model.trim=\u0026#34;msg\u0026#34;\u0026gt; ","permalink":"https://waite.wang/posts/vue/vue2-core-learn/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://v2.cn.vuejs.org/\"\u003ehttps://v2.cn.vuejs.org/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"简单使用\"\u003e简单使用\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://v2.cn.vuejs.org/v2/guide/installation.html\"\u003ehttps://v2.cn.vuejs.org/v2/guide/installation.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://v2.cn.vuejs.org/v2/guide/installation.html#%E7%9B%B4%E6%8E%A5%E7%94%A8-lt-script-gt-%E5%BC%95%E5%85%A5\"\u003e\u003cstrong\u003e直接用 script 引入\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e直接下载并用 \u003c!-- raw HTML omitted --\u003e 标签引入，\u003ccode\u003eVue\u003c/code\u003e 会被注册为一个全局变量。(在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!)\u003c/p\u003e","title":"Vue2 核心语法"}]