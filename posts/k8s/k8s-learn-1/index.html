<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>K8S 学习笔记（一）—— 集群的启动以及部署 | 隶笔难书</title><meta name=keywords content="K8S"><meta name=description content="集群的启动以及部署
kubectl


https://kubernetes.io/docs/tasks/tools/#kubectl

Kubernetes 命令行工具
kubectl允许您对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。有关更多信息（包括 kubectl 操作的完整列表），请参阅 
kubectl参考文档。"><meta name=author content="Waite Wang"><link rel=canonical href=https://waite.wang/posts/k8s/k8s-learn-1/><link crossorigin=anonymous href=/assets/css/stylesheet.976e55d3e381740932aad0ab9720ce93c63141ff1c613d6206b33975083c3bf6.css integrity="sha256-l25V0+OBdAkyqtCrlyDOk8YxQf8cYT1iBrM5dQg8O/Y=" rel="preload stylesheet" as=style><link rel=icon href=https://waite.wang/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://waite.wang/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://waite.wang/favicon-32x32.png><link rel=apple-touch-icon href=https://waite.wang/apple-touch-icon.png><link rel=mask-icon href=https://waite.wang/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://waite.wang/posts/k8s/k8s-learn-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://waite.wang/posts/k8s/k8s-learn-1/"><meta property="og:site_name" content="隶笔难书"><meta property="og:title" content="K8S 学习笔记（一）—— 集群的启动以及部署"><meta property="og:description" content="集群的启动以及部署 kubectl https://kubernetes.io/docs/tasks/tools/#kubectl
Kubernetes 命令行工具 kubectl允许您对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。有关更多信息（包括 kubectl 操作的完整列表），请参阅 kubectl参考文档。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-01T09:05:54+08:00"><meta property="article:modified_time" content="2025-12-01T09:05:54+08:00"><meta property="article:tag" content="K8S"><meta name=twitter:card content="summary"><meta name=twitter:title content="K8S 学习笔记（一）—— 集群的启动以及部署"><meta name=twitter:description content="集群的启动以及部署
kubectl


https://kubernetes.io/docs/tasks/tools/#kubectl

Kubernetes 命令行工具
kubectl允许您对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。有关更多信息（包括 kubectl 操作的完整列表），请参阅 
kubectl参考文档。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://waite.wang/posts/"},{"@type":"ListItem","position":2,"name":"K8S 学习笔记（一）—— 集群的启动以及部署","item":"https://waite.wang/posts/k8s/k8s-learn-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"K8S 学习笔记（一）—— 集群的启动以及部署","name":"K8S 学习笔记（一）—— 集群的启动以及部署","description":"集群的启动以及部署 kubectl https://kubernetes.io/docs/tasks/tools/#kubectl\nKubernetes 命令行工具 kubectl允许您对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。有关更多信息（包括 kubectl 操作的完整列表），请参阅 kubectl参考文档。\n","keywords":["K8S"],"articleBody":"集群的启动以及部署 kubectl https://kubernetes.io/docs/tasks/tools/#kubectl\nKubernetes 命令行工具 kubectl允许您对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。有关更多信息（包括 kubectl 操作的完整列表），请参阅 kubectl参考文档。\nkubectl 可安装在多种 Linux 平台、macOS 和 Windows 系统上。请在下方查找您偏好的操作系统。\n在 Linux 上安装 kubectl 在 macOS 上安装 kubectl 在 Windows 上安装 kubectl minikube https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download#Service\n先下载对应的安装包进行安装\nminikube 是本地 Kubernetes，专注于让 Kubernetes 的学习和开发变得容易。\n您只需要一个 Docker（或类似兼容的）容器或虚拟机环境，即可通过一条命令部署 Kubernetes：minikube start\n在具有管理员权限（但未以 root 用户身份登录）的终端中运行：\nminikube start 如果 minikube 启动失败，请参阅 驱动程序页面，以获取有关设置兼容容器或虚拟机管理器的帮助。\n# 如果遇到镜像拉取失败的，让 minikube 里的 Docker daemon 也能走代理，把镜像拉下来。 # 以 Clash 为例，默认 127.0.0.1:7890 # 设置 minikube 使用主机 SOCKS5 minikube delete # 清掉之前失败的缓存 minikube start --driver=hyperv --docker-env HTTP_PROXY=socks5://host.minikube.internal:7890 ` --docker-env HTTPS_PROXY=socks5://host.minikube.internal:7890 拉取镜像 暴露端口\n# 拉镜像并启动容器 kubectl create deployment hello-minikube --image=kicbase/echo-server:1.0 # 使用 NodePort 暴露端口， --port=8080 对应服务内部的端口 kubectl expose deployment hello-minikube --type=NodePort --port=8080 可能需要一些时间，但运行以下命令后，您的部署很快就会显示出来： kubectl get services hello-minikube 这代表服务映射到了该容器内部的的 32338 端口\n访问此服务的最简单方法是让 minikube 为您启动一个 Web 浏览器： minikube service hello-minikube 或者，可以使用 kubectl 进行端口转发： kubectl port-forward service/hello-minikube 7080:8080 # 把你 本地电脑（Windows）的 7080 端口 转发到 Kubernetes 集群里的 Service hello-minikube 的 8080 端口。 您的应用程序现在可以在 http://localhost:7080/ 上访问。\n管理你的集群 暂停 Kubernetes 而不影响已部署的应用程序：\nminikube pause 恢复已暂停的实例：\nminikube unpause 停止集群：\nminikube stop 更改默认内存限制（需要重启）：\nminikube config set memory 9001 浏览易于安装的 Kubernetes 服务目录：\nminikube addons list 创建第二个集群，运行旧版本的 Kubernetes：\nminikube start -p aged --kubernetes-version=v1.34.0 删除所有minikube集群：\nminikube delete --all eyJhbGciOiJSUzI1NiIsImtpZCI6Ik5kcmRfcWo0RGRLSUI0Y3I1bXFLNm9aeUJoNjRvbHQzdFMwcG9KRmYtbk0ifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIj oxNzk1Njg3Nzg4LCJpYXQiOjE3NjQxNTE3ODgsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwianRpIjoiMDgxN2QyYTUtMjIxZC00NzUxLWE4ZDctZDUyMTZlMzAwZWFmIiwia3V iZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiZGI4MGZhM2ItZTcxOC00ODIxLTg1YWUtNTE2M2Q5MWNhZWU0 In19LCJuYmYiOjE3NjQxNTE3ODgsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.wgv1-JvoLJBlsHMLaYyyTz0X9_luIwpNRdzcVVxu0cmK1L47X3mvL5T3YXKsX 2B-Ny8LatAnx_-Z0-HiTCh-KXigSZ6twqqsnNvb9MRnIfBoiGZcD2yL0tjFJoIVVSJLfJphfZSMtQC_cAvDt_tURwb4Wn9SGy5ZrgCwXdHnthmAapfNFtEWg167quMCoOYoycrk-MAlAiL4dNPaKaLQFb747sHCFFhTSsFd-snf1b yP23MORxGF1gCT3iysrJ91pSknOTm9FCSjb6SiTCGR90k43yEpZ6787C--GZUyfpeFoa7HjWSlSzU77P-RE4SlGjYFKPynghK3vBPKMhI3TQ 配置 Pods 以及 容器 为容器和 Pod 分配内存资源 该页面上的一些步骤要求你在集群中运行 metrics-server 服务。 如果你已经有在运行中的 metrics-server，则可以跳过这些步骤。\n如果你运行的是 Minikube，可以运行下面的命令启用 metrics-server：\nminikube addons enable metrics-server 要查看 metrics-server 或资源指标 API (metrics.k8s.io) 是否已经运行，请运行以下命令：\nkubectl get apiservices 创建命名空间 创建一个命名空间，以便将本练习中创建的资源与集群的其余部分隔离。\nkubectl create namespace mem-example # 你也可以改成自己想要的命名空间名字 这里 mem-example 我改成了 waite 指定内存请求以及限制 要为容器指定内存请求，请在容器资源清单中包含 resources: requests 字段。 同理，要指定内存限制，请包含 resources: limits。\n在本练习中，你将创建一个拥有一个容器的 Pod。 容器将会请求 100 MiB 内存，并且内存会被限制在 200 MiB 以内。 这是 Pod 的配置文件：\napiVersion: v1 kind: Pod metadata: name: memory-demo namespace: waite spec: containers: - name: memory-demo-ctr image: polinux/stress resources: requests: memory: \"100Mi\" limits: memory: \"200Mi\" command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] 配置文件的 args 部分提供了容器启动时的参数。 \"--vm-bytes\", \"150M\" 参数告知容器尝试分配 150 MiB 内存。\n开始创建 Pod (注意运行在同级目录) kubectl apply -f memory-request-limit.yaml --namespace=waite 验证 Pod 中的容器是否已运行 kubectl get pod memory-demo --namespace=waite kubectl get pod -n waite 查看 Pod 相关的详细信息： kubectl get pod memory-demo --output=yaml --namespace=waite 输出结果显示：该 Pod 中容器的内存请求为 100 MiB，内存限制为 200 MiB。\n运行 kubectl top 命令，获取该 Pod 的指标数据, 输出结果显示：Pod 正在使用的内存大约为 150 MiB。 这大于 Pod 请求的 100 MiB，但在 Pod 限制的 200 MiB之内。 kubectl top pod memory-demo --namespace=waite NAME CPU(cores) MEMORY(bytes) memory-demo 76m 150Mi 删除 pod kubectl delete pod memory-demo --namespace=waite 当节点拥有足够的可用内存时，容器可以使用其请求的内存。 但是，容器不允许使用超过其限制的内存。 如果容器分配的内存超过其限制，该容器会成为被终止的候选容器。 如果容器继续消耗超出其限制的内存，则终止容器。 如果终止的容器可以被重启，则 kubelet 会重新启动它，就像其他任何类型的运行时失败一样。\n在本练习中，你将创建一个 Pod，尝试分配超出其限制的内存。 这是一个 Pod 的配置文件，其拥有一个容器，该容器的内存请求为 50 MiB，内存限制为 100 MiB：\napiVersion: v1 kind: Pod metadata: name: memory-demo-2 namespace: waite spec: containers: - name: memory-demo-2-ctr image: polinux/stress resources: requests: memory: \"50Mi\" limits: memory: \"100Mi\" command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"250M\", \"--vm-hang\", \"1\"] 在配置文件的 args 部分中，你可以看到容器会尝试分配 250 MiB 内存，这远高于 100 MiB 的限制。\nkubectl apply -f memory-request-limit.yaml --namespace=waite D:\\k8s\u003ekubectl get pod memory-demo-1 --namespace=waite NAME READY STATUS RESTARTS AGE memory-demo-1 0/1 OOMKilled 5 (107s ago) 3m32s D:\\k8s\u003ekubectl get pod memory-demo-1 --namespace=waite NAME READY STATUS RESTARTS AGE memory-demo-1 0/1 CrashLoopBackOff 5 (17s ago) 3m35s # 容器反复重启又崩溃 D:\\k8s\u003ekubectl get pod memory-demo-1 --output=yaml --namespace=waite ...... lastState: terminated: containerID: docker://718a86ad475ac286f097a31b6dd678aa2656d05df63fdb27aae32658b7ca19a6 exitCode: 1 finishedAt: \"2025-11-27T01:52:34Z\" reason: OOMKilled startedAt: \"2025-11-27T01:52:34Z\" # 输出结果显示：由于内存溢出（OOM），容器已被杀掉 内存请求和限制是与容器关联的，但将 Pod 视为具有内存请求和限制，也是很有用的。 Pod 的内存请求是 Pod 中所有容器的内存请求之和。 同理，Pod 的内存限制是 Pod 中所有容器的内存限制之和。\nPod 的调度基于请求。只有当节点拥有足够满足 Pod 内存请求的内存时，才会将 Pod 调度至节点上运行。\n在本练习中，你将创建一个 Pod，其内存请求超过了你集群中的任意一个节点所拥有的内存。 这是该 Pod 的配置文件，其拥有一个请求 1000 GiB 内存的容器，这应该超过了你集群中任何节点的容量。\napiVersion: v1 kind: Pod metadata: name: memory-demo-2 namespace: waite spec: containers: - name: memory-demo-3-ctr image: polinux/stress resources: requests: memory: \"1000Gi\" limits: memory: \"1000Gi\" command: [\"stress\"] args: [\"--vm\", \"1\", \"--vm-bytes\", \"150M\", \"--vm-hang\", \"1\"] D:\\k8s\u003ekubectl apply -f memory-request-limit.yaml --namespace=waite pod/memory-demo-2 created D:\\k8s\u003ekubectl get pod -n waite NAME READY STATUS RESTARTS AGE memory-demo-2 0/1 Pending 0 3s # 输出结果显示：Pod 处于 PENDING 状态。 这意味着，该 Pod 没有被调度至任何节点上运行，并且它会无限期的保持该状态： D:\\k8s\u003ekubectl describe pod memory-demo-2 --namespace=waite Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling 49s default-scheduler 0/1 nodes are available: 1 Insufficient memory. no new claims to deallocate, preemption: 0/1 nodes are available: 1 Preemption is not helpful for scheduling. # 输出结果显示：由于节点内存不足，该容器无法被调度： 如果你没有为一个容器指定内存限制，则自动遵循以下情况之一：\n容器可无限制地使用内存。容器可以使用其所在节点所有的可用内存， 进而可能导致该节点调用 OOM Killer。 此外，如果发生 OOM Kill，没有资源限制的容器将被杀掉的可行性更大。 运行的容器所在命名空间有默认的内存限制，那么该容器会被自动分配默认限制。 集群管理员可用使用 LimitRange 来指定默认的内存限制 删除命名空间。下面的命令会删除你根据这个任务创建的所有 Pod：\nkubectl delete namespace mem-example 为容器以及 Pods 分配 CPU 和内存资源 apiVersion: v1 kind: Pod metadata: name: cpu-demo namespace: waite spec: containers: - name: cpu-demo-ctr image: polinux/stress resources: limits: cpu: \"1\" requests: cpu: \"0.5\" args: - -cpus - \"2\" D:\\k8s\u003ekubectl get pod cpu-demo --namespace=waite NAME READY STATUS RESTARTS AGE cpu-demo 1/1 Running 0 2m46s D:\\k8s\u003ekubectl get pod cpu-demo --output=yaml --namespace=waite spec: containers: - args: - -cpus - \"2\" image: vish/stress imagePullPolicy: Always name: cpu-demo-ctr resources: limits: cpu: \"1\" requests: cpu: 500m # 输出显示 Pod 中的一个容器的 CPU 请求为 500 milliCPU，并且 CPU 限制为 1 个 CPU。 D:\\k8s\u003ekubectl top pod cpu-demo --namespace=waite NAME CPU(cores) MEMORY(bytes) cpu-demo 1000m 0Mi # 此示例输出显示 Pod 使用的是 1000 M，小于等于限制的 1 GPU, 如果你的容器在只有 1 个 CPU 的节点上运行，则容器无论为容器指定的 CPU 限制如何， 都不能使用超过 1 个 CPU。 如果不指定 CPU 限制\n容器在可以使用的 CPU 资源上没有上限。因而可以使用所在节点上所有的可用 CPU 资源。\n容器在具有默认 CPU 限制的名字空间中运行，系统会自动为容器设置默认限制。 集群管理员可以使用 LimitRange 指定 CPU 限制的默认值。如果你设置了 CPU 限制但未设置 CPU 请求\n如果你为容器指定了 CPU 限制值但未为其设置 CPU 请求，Kubernetes 会自动为其 设置与 CPU 限制相同的 CPU 请求值。类似的，如果容器设置了内存限制值但未设置 内存请求值，Kubernetes 也会为其设置与内存限制值相同的内存请求\n配置 Pod 以使用卷进行存储 在本练习中，你将创建一个运行 Pod，该 Pod 仅运行一个容器并拥有一个类型为 emptyDir 的卷， 在整个 Pod 生命周期中一直存在，即使 Pod 中的容器被终止和重启。以下是 Pod 的配置：\napiVersion: v1 kind: Pod metadata: name: redis spec: containers: - name: redis image: redis volumeMounts: - name: redis-storage mountPath: /data/redis volumes: - name: redis-storage emptyDir: {} emptyDir 卷 这种卷的生命周期是 与 Pod 绑定 的：\nPod 存在 → 卷存在 Pod 被删除或重建 → 卷被清空，数据永久丢失 配置 Pod 以使用 PersistentVolume 作为存储 打开集群中的某个节点的 Shell。 如何打开 Shell 取决于集群的设置。 例如，如果你正在使用 Minikube，那么可以通过输入 minikube ssh 来打开节点的 Shell。\n在该节点的 Shell 中，创建一个 /mnt/data 目录：\n# 这里假定你的节点使用 \"sudo\" 来以超级用户角色执行命令 sudo mkdir /mnt/data 在 /mnt/data 目录中创建一个 index.html 文件：\n# 这里再次假定你的节点使用 \"sudo\" 来以超级用户角色执行命令 sudo sh -c \"echo 'Hello from Kubernetes storage' \u003e /mnt/data/index.html\" 说明：\n如果你的节点使用某工具而不是 sudo 来完成超级用户访问，你可以将上述命令中的 sudo 替换为该工具的名称。\n测试 index.html 文件确实存在：\ncat /mnt/data/index.html 输出应该是：\nHello from Kubernetes storage 现在你可以关闭节点的 Shell 了, 后续我们会将 pods 绑定到该卷上。\n在本练习中，你将创建一个 hostPath 类型的 PersistentVolume。 Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。 hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。\n在生产集群中，你不会使用 hostPath。 集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。 集群管理员还可以使用 StorageClass 来设置 动态制备存储。\n下面是 hostPath PersistentVolume 的配置文件：\napiVersion: v1 kind: PersistentVolume metadata: name: task-pv-volume labels: type: local spec: storageClassName: manual capacity: storage: 10Gi accessModes: - ReadWriteOnce hostPath: path: \"/mnt/data\" 此配置文件指定卷位于集群节点上的 /mnt/data 路径。 其配置还指定了卷的容量大小为 10 GB，访问模式为 ReadWriteOnce， 这意味着该卷可以被单个节点以读写方式安装。 此配置文件还在 PersistentVolume 中定义了 StorageClass 的名称为 manual。 它将用于将 PersistentVolumeClaim 的请求绑定到此 PersistentVolume。\n为了简化，本示例采用了 ReadWriteOnce 访问模式。然而对于生产环境， Kubernetes 项目建议改用 ReadWriteOncePod 访问模式。\n创建 PersistentVolume：\nkubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml 查看 PersistentVolume 的信息：\nkubectl get pv task-pv-volume 输出结果显示该 PersistentVolume 的状态（STATUS）为 Available。 这意味着它还没有被绑定给 PersistentVolumeClaim。\nNAME CAPACITY ACCESSMODES RECLAIMPOLICY STATUS CLAIM STORAGECLASS REASON AGE task-pv-volume 10Gi RWO Retain Available manual 下一步是创建一个 PersistentVolumeClaim。 Pod 使用 PersistentVolumeClaim 来请求物理存储。 在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷， 该卷一次最多可以为一个节点提供读写访问。\n下面是 PersistentVolumeClaim 的配置文件：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: task-pv-claim spec: storageClassName: manual accessModes: - ReadWriteOnce resources: requests: storage: 3Gi Kubernetes 文档 任务 配置 Pods 和容器 配置 Pod 以使用 PersistentVolume 作为存储\n配置 Pod 以使用 PersistentVolume 作为存储 本文将向你介绍如何配置 Pod 使用 PersistentVolumeClaim 作为存储。 以下是该过程的总结：\n你作为集群管理员创建由物理存储支持的 PersistentVolume。你不会将该卷与任何 Pod 关联。 你现在以开发人员或者集群用户的角色创建一个 PersistentVolumeClaim， 它将自动绑定到合适的 PersistentVolume。 你创建一个使用以上 PersistentVolumeClaim 作为存储的 Pod。 你需要一个包含单个节点的 Kubernetes 集群，并且必须配置 kubectl 命令行工具以便与集群交互。 如果还没有单节点集群，可以使用 Minikube 创建一个。 熟悉 持久卷文档。 在你的节点上创建一个 index.html 文件\n打开集群中的某个节点的 Shell。 如何打开 Shell 取决于集群的设置。 例如，如果你正在使用 Minikube，那么可以通过输入 minikube ssh 来打开节点的 Shell。\n在该节点的 Shell 中，创建一个 /mnt/data 目录：\n# 这里假定你的节点使用 \"sudo\" 来以超级用户角色执行命令 sudo mkdir /mnt/data 在 /mnt/data 目录中创建一个 index.html 文件：\n# 这里再次假定你的节点使用 \"sudo\" 来以超级用户角色执行命令 sudo sh -c \"echo 'Hello from Kubernetes storage' \u003e /mnt/data/index.html\" 说明：\n如果你的节点使用某工具而不是 sudo 来完成超级用户访问，你可以将上述命令中的 sudo 替换为该工具的名称。\n测试 index.html 文件确实存在：\ncat /mnt/data/index.html 输出应该是：\nHello from Kubernetes storage 现在你可以关闭节点的 Shell 了。\n创建 PersistentVolume\n在本练习中，你将创建一个 hostPath 类型的 PersistentVolume。 Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。 hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。\n在生产集群中，你不会使用 hostPath。 集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。 集群管理员还可以使用 StorageClass 来设置 动态制备存储。\n下面是 hostPath PersistentVolume 的配置文件：\napiVersion: v1 kind: PersistentVolume metadata: name: task-pv-volume labels: type: local spec: storageClassName: manual capacity: storage: 10Gi accessModes: - ReadWriteOnce hostPath: path: \"/mnt/data\" 此配置文件指定卷位于集群节点上的 /mnt/data 路径。 其配置还指定了卷的容量大小为 10 GB，访问模式为 ReadWriteOnce， 这意味着该卷可以被单个节点以读写方式安装。 此配置文件还在 PersistentVolume 中定义了 StorageClass 的名称为 manual。 它将用于将 PersistentVolumeClaim 的请求绑定到此 PersistentVolume。\n为了简化，本示例采用了 ReadWriteOnce 访问模式。然而对于生产环境， Kubernetes 项目建议改用 ReadWriteOncePod 访问模式。\n创建 PersistentVolume：\nkubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml 查看 PersistentVolume 的信息：\nkubectl get pv task-pv-volume 输出结果显示该 PersistentVolume 的状态（STATUS）为 Available。 这意味着它还没有被绑定给 PersistentVolumeClaim。\nNAME CAPACITY ACCESSMODES RECLAIMPOLICY STATUS CLAIM STORAGECLASS REASON AGE task-pv-volume 10Gi RWO Retain Available manual 4s 创建 PersistentVolumeClaim 下一步是创建一个 PersistentVolumeClaim。 Pod 使用 PersistentVolumeClaim 来请求物理存储。 在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷， 该卷一次最多可以为一个节点提供读写访问。\n下面是 PersistentVolumeClaim 的配置文件：\napiVersion: v1 kind: PersistentVolumeClaim metadata: name: task-pv-claim spec: storageClassName: manual accessModes: - ReadWriteOnce resources: requests: storage: 3Gi 创建 PersistentVolumeClaim：\nkubectl apply -f https://k8s.io/examples/pods/storage/pv-claim.yaml 创建 PersistentVolumeClaim 之后，Kubernetes 控制平面将查找满足申领要求的 PersistentVolume。 如果控制平面找到具有相同 StorageClass 的适当的 PersistentVolume， 则将 PersistentVolumeClaim 绑定到该 PersistentVolume 上。\n再次查看 PersistentVolume 信息：\nkubectl get pv task-pv-volume 现在输出的 STATUS 为 Bound。\nNAME CAPACITY ACCESSMODES RECLAIMPOLICY STATUS CLAIM STORAGECLASS REASON AGE task-pv-volume 10Gi RWO Retain Bound default/task-pv-claim manual 2m 查看 PersistentVolumeClaim：\nkubectl get pvc task-pv-claim 输出结果表明该 PersistentVolumeClaim 绑定了你的 PersistentVolume task-pv-volume。\nNAME STATUS VOLUME CAPACITY ACCESSMODES STORAGECLASS AGE task-pv-claim Bound task-pv-volume 10Gi RWO manual 30s 各自角色\n① Provision → ② Binding → ③ Using → ④ Releasing → ⑤ Reclaiming ① 供给（Provision） - 静态：管理员先建好一批 PV 放着。 - 动态：没有合适 PV 时，PVC 会触发 CSI 驱动即刻创建一个 PV（storageClassName 不为空）。\n② 绑定（Binding） - Scheduler 持续 watch，一旦找到「最闲且字段匹配」的 PV，立即把 pv.spec.claimRef 写上 PVC 名字，一对一互锁，别的 PVC 再也抢不到。\n③ 使用（Using） - Pod 通过 persistentVolumeClaim 字段挂载，容器里看到的就是 PV 背后的真实存储路径。\n此时就算 Pod 重建、调度到别的节点，只要 PVC 在，数据就跟着走。 ④ 释放（Releasing） - 用户 kubectl delete pvc task-pvc；PV 状态变成 Released，但数据还在（取决于回收策略）。\n⑤ 回收（Reclaiming） - Retain：人工清理，pv.status.phase=Released，需要管理员手动 kubectl delete pv 并到存储后端删数据。 - Delete：CSI 自动把后端卷一起删掉（云盘常用）。 - Recycle（已废弃）：曾用 rm -rf 清目录。\n对象 谁创建 作用 类比 PersistentVolume (PV) 集群管理员（或 CSI 自动供给） 提供一段真实的存储资源 楼盘 PersistentVolumeClaim (PVC) 应用开发者（用户） 申请一段存储，声明容量、访问模式、Storage 购房合同创建 Pod 下一步是创建一个使用你的 PersistentVolumeClaim 作为存储卷的 Pod。\n下面是此 Pod 的配置文件：\napiVersion: v1 kind: Pod metadata: name: task-pv-pod spec: volumes: - name: task-pv-storage persistentVolumeClaim: claimName: task-pv-claim containers: - name: task-pv-container image: nginx ports: - containerPort: 80 name: \"http-server\" volumeMounts: - mountPath: \"/usr/share/nginx/html\" name: task-pv-storage 注意 Pod 的配置文件指定了 PersistentVolumeClaim，但没有指定 PersistentVolume。 对 Pod 而言，PersistentVolumeClaim 就是一个存储卷。\n创建 Pod：\nkubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml 检查 Pod 中的容器是否运行正常：\nkubectl get pod task-pv-pod 打开一个 Shell 访问 Pod 中的容器：\nkubectl exec -it task-pv-pod -- /bin/bash 在 Shell 中，验证 Nginx 是否正在从 hostPath 卷提供 index.html 文件：\n# 一定要在上一步 \"kubectl exec\" 所返回的 Shell 中执行下面三个命令 apt update apt install curl curl http://localhost/ 输出结果是你之前写到 hostPath 卷中的 index.html 文件中的内容：\nHello from Kubernetes storage 如果你看到此消息，则证明你已经成功地配置了 Pod 使用 PersistentVolumeClaim 的存储。\n配置 Pod 使用投射卷作存储 本练习中，你将使用本地文件来创建用户名和密码 Secret， 然后创建运行一个容器的 Pod， 该 Pod 使用 projected 卷将 Secret 挂载到相同的路径下。\n下面是 Pod 的配置文件：\napiVersion: v1 kind: Pod metadata: name: test-projected-volume spec: containers: - name: test-projected-volume image: busybox:1.28 args: - sleep - \"86400\" volumeMounts: - name: all-in-one mountPath: \"/projected-volume\" readOnly: true volumes: - name: all-in-one projected: sources: - secret: name: user - secret: name: pass 创建 Secret：\n# 创建包含用户名和密码的文件： echo -n \"admin\" \u003e ./username.txt echo -n \"1f2d1e2e67df\" \u003e ./password.txt # 在 Secret 中引用上述文件 kubectl create secret generic user --from-file=./username.txt kubectl create secret generic pass --from-file=./password.txt 创建 Pod：\nkubectl apply -f https://k8s.io/examples/pods/storage/projected.yaml 确认 Pod 中的容器运行正常，然后监视 Pod 的变化：\nkubectl get --watch pod test-projected-volume 输出结果和下面类似：\nNAME READY STATUS RESTARTS AGE test-projected-volume 1/1 Running 0 14s 在另外一个终端中，打开容器的 shell：\nkubectl exec -it test-projected-volume -- /bin/sh 在 shell 中，确认 projected-volume 目录包含你的投射源：\n/ # ls /projected-volume/ password.txt username.txt / # cat /projected-volume/username.txt -n \"admin\" 从私有仓库拉取镜像 在个人电脑上，要想拉取私有镜像必须在镜像仓库上进行身份验证。\n使用 docker 命令工具来登录到 Docker Hub。 更多详细信息，请查阅 Docker ID accounts 中的 log in 部分。\ndocker login 当出现提示时，输入你的 Docker ID 和登录凭据（访问令牌或 Docker ID 的密码）。\n登录过程会创建或更新保存有授权令牌的 config.json 文件。 查看 Kubernetes 如何解析这个文件。\n查看 config.json 文件：\ncat ~/.docker/config.json 输出结果包含类似于以下内容的部分：\n{ \"auths\": { \"https://index.docker.io/v1/\": { \"auth\": \"c3R...zE2\" } } } 如果使用 Docker 凭据仓库，则不会看到 auth 条目，看到的将是以仓库名称作为值的 credsStore 条目。 在这种情况下，你可以直接创建一个 Secret。 请参阅 在命令行上提供凭据来创建 Secret。\nKubernetes 集群使用 kubernetes.io/dockerconfigjson 类型的 Secret 来通过镜像仓库的身份验证，进而提取私有镜像。\n如果你已经运行了 docker login 命令，你可以复制该镜像仓库的凭据到 Kubernetes:\nkubectl create secret generic regcred \\ --from-file=.dockerconfigjson= \\ --type=kubernetes.io/dockerconfigjson 如果你需要更多的设置（例如，为新 Secret 设置名字空间或标签）， 则可以在存储 Secret 之前对它进行自定义。 请务必：\n将 data 项中的名称设置为 .dockerconfigjson 使用 base64 编码方法对 Docker 配置文件进行编码，然后粘贴该字符串的内容，作为字段 data[\".dockerconfigjson\"] 的值 将 type 设置为 kubernetes.io/dockerconfigjson 示例：\napiVersion: v1 kind: Secret metadata: name: myregistrykey namespace: awesomeapps data: .dockerconfigjson: UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg== type: kubernetes.io/dockerconfigjson 如果你收到错误消息：error: no objects passed to create， 这可能意味着 base64 编码的字符串是无效的。如果你收到类似 Secret \"myregistrykey\" is invalid: data[.dockerconfigjson]: invalid value ... 的错误消息，则表示数据中的 base64 编码字符串已成功解码， 但无法解析为 .docker/config.json 文件。\n创建 Secret，命名为 regcred：\nkubectl create secret docker-registry regcred \\ --docker-server=\u003c你的镜像仓库服务器\u003e \\ --docker-username=\u003c你的用户名\u003e \\ --docker-password=\u003c你的密码\u003e \\ --docker-email=\u003c你的邮箱地址\u003e 在这里：\n是你的私有 Docker 仓库全限定域名（FQDN）。 DockerHub 使用 https://index.docker.io/v1/。 是你的 Docker 用户名。 是你的 Docker 密码。 是你的 Docker 邮箱。 这样你就成功地将集群中的 Docker 凭据设置为名为 regcred 的 Secret。\n在命令行上键入 Secret 可能会将它们存储在你的 Shell 历史记录中而不受保护， 并且这些 Secret 信息也可能在 kubectl 运行期间对你 PC 上的其他用户可见。\n了解你创建的 regcred Secret 的内容，可以用 YAML 格式进行查看：\nkubectl get secret regcred --output=yaml 输出和下面类似：\napiVersion: v1 kind: Secret metadata: ... name: regcred ... data: .dockerconfigjson: eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0= type: kubernetes.io/dockerconfigjson .dockerconfigjson 字段的值是 Docker 凭据的 base64 表示。\n要了解 dockerconfigjson 字段中的内容，请将 Secret 数据转换为可读格式：\nkubectl get secret regcred --output=\"jsonpath={.data.\\.dockerconfigjson}\" | base64 --decode 输出和下面类似：\n{\"auths\":{\"your.private.registry.example.com\":{\"username\":\"janedoe\",\"password\":\"xxxxxxxxxxx\",\"email\":\"jdoe@example.com\",\"auth\":\"c3R...zE2\"}}} 要了解 auth 字段中的内容，请将 base64 编码过的数据转换为可读格式：\necho \"c3R...zE2\" | base64 --decode 输出结果中，用户名和密码用 : 链接，类似下面这样：\njanedoe:xxxxxxxxxxx 注意，Secret 数据包含与本地 ~/.docker/config.json 文件类似的授权令牌。\n这样你就已经成功地将 Docker 凭据设置为集群中的名为 regcred 的 Secret。\n下面是一个 Pod 配置清单示例，该示例中 Pod 需要访问你的 Docker 凭据 regcred：\napiVersion: v1 kind: Pod metadata: name: private-reg spec: containers: - name: private-reg-container image: imagePullSecrets: - name: regcred 将上述文件下载到你的计算机中：\ncurl -L -o my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml 在 my-private-reg-pod.yaml 文件中，使用私有仓库的镜像路径替换 ，例如：\nyour.private.registry.example.com/janedoe/jdoe-private:v1 要从私有仓库拉取镜像，Kubernetes 需要凭据。 配置文件中的 imagePullSecrets 字段表明 Kubernetes 应该通过名为 regcred 的 Secret 获取凭据。\n创建使用了你的 Secret 的 Pod，并检查它是否正常运行：\nkubectl apply -f my-private-reg-pod.yaml kubectl get pod private-reg 要为 Pod（或 Deployment，或其他有 Pod 模板的对象）使用镜像拉取 Secret， 你需要确保合适的 Secret 确实存在于正确的名字空间中。 要使用的是你定义 Pod 时所用的名字空间。\n此外，如果 Pod 启动失败，状态为 ImagePullBackOff，查看 Pod 事件：\nkubectl describe pod private-reg 如果你看到一个原因设为 FailedToRetrieveImagePullSecret 的事件， 那么 Kubernetes 找不到指定名称（此例中为 regcred）的 Secret。\n确保你指定的 Secret 存在，并且其名称拼写正确。\nEvents: ... Reason ... Message ------ ------- ... FailedToRetrieveImagePullSecret ... Unable to retrieve some image pull secrets (","wordCount":"13550","inLanguage":"zh-cn","datePublished":"2025-12-01T09:05:54+08:00","dateModified":"2025-12-01T09:05:54+08:00","author":{"@type":"Person","name":"Waite Wang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://waite.wang/posts/k8s/k8s-learn-1/"},"publisher":{"@type":"Organization","name":"隶笔难书","logo":{"@type":"ImageObject","url":"https://waite.wang/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://waite.wang/ accesskey=h title="隶笔难书 (Alt + H)">隶笔难书</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://waite.wang/ title=首页><span>首页</span></a></li><li><a href=https://waite.wang/search title=搜索><span>搜索</span></a></li><li><a href=https://waite.wang/categories title=分类><span>分类</span></a></li><li><a href=https://waite.wang/tags title=标签><span>标签</span></a></li><li><a href=https://waite.wang/archives title=归档><span>归档</span></a></li><li><a href=https://waite.wang/links title=友链><span>友链</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://waite.wang/>Home</a>&nbsp;»&nbsp;<a href=https://waite.wang/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">K8S 学习笔记（一）—— 集群的启动以及部署</h1><div class=post-meta><span title='2025-12-01 09:05:54 +0800 +0800'>2025-12-01</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;13550 words&nbsp;·&nbsp;Waite Wang&nbsp;|&nbsp;<a href=https://github.com/Waite0603/HugoBlog/edit/main/content/posts/k8s/k8s-learn-1.md rel="noopener noreferrer" target=_blank>在 GitHub 编辑</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%9b%86%e7%be%a4%e7%9a%84%e5%90%af%e5%8a%a8%e4%bb%a5%e5%8f%8a%e9%83%a8%e7%bd%b2 aria-label=集群的启动以及部署>集群的启动以及部署</a><ul><li><a href=#kubectl aria-label=kubectl>kubectl</a></li><li><a href=#%e7%ae%a1%e7%90%86%e4%bd%a0%e7%9a%84%e9%9b%86%e7%be%a4 aria-label=管理你的集群>管理你的集群</a></li></ul></li><li><a href=#%e9%85%8d%e7%bd%ae-pods-%e4%bb%a5%e5%8f%8a-%e5%ae%b9%e5%99%a8 aria-label="配置 Pods 以及 容器">配置 Pods 以及 容器</a><ul><li><a href=#%e4%b8%ba%e5%ae%b9%e5%99%a8%e5%92%8c-pod-%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e8%b5%84%e6%ba%90 aria-label="为容器和 Pod 分配内存资源">为容器和 Pod 分配内存资源</a></li><li><a href=#%e4%b8%ba%e5%ae%b9%e5%99%a8%e4%bb%a5%e5%8f%8a-pods-%e5%88%86%e9%85%8d-cpu-%e5%92%8c%e5%86%85%e5%ad%98%e8%b5%84%e6%ba%90 aria-label="为容器以及 Pods 分配 CPU 和内存资源">为容器以及 Pods 分配 CPU 和内存资源</a></li><li><a href=#%e9%85%8d%e7%bd%ae-pod-%e4%bb%a5%e4%bd%bf%e7%94%a8%e5%8d%b7%e8%bf%9b%e8%a1%8c%e5%ad%98%e5%82%a8 aria-label="配置 Pod 以使用卷进行存储">配置 Pod 以使用卷进行存储</a></li><li><a href=#%e9%85%8d%e7%bd%ae-pod-%e4%bb%a5%e4%bd%bf%e7%94%a8-persistentvolume-%e4%bd%9c%e4%b8%ba%e5%ad%98%e5%82%a8 aria-label="配置 Pod 以使用 PersistentVolume 作为存储">配置 Pod 以使用 PersistentVolume 作为存储</a></li><li><a href=#%e9%85%8d%e7%bd%ae-pod-%e4%bb%a5%e4%bd%bf%e7%94%a8-persistentvolume-%e4%bd%9c%e4%b8%ba%e5%ad%98%e5%82%a8-1 aria-label="配置 Pod 以使用 PersistentVolume 作为存储">配置 Pod 以使用 PersistentVolume 作为存储</a></li><li><a href=#%e5%88%9b%e5%bb%ba-persistentvolumeclaim aria-label="创建 PersistentVolumeClaim">创建 PersistentVolumeClaim</a></li><li><a href=#%e9%85%8d%e7%bd%ae-pod-%e4%bd%bf%e7%94%a8%e6%8a%95%e5%b0%84%e5%8d%b7%e4%bd%9c%e5%ad%98%e5%82%a8 aria-label="配置 Pod 使用投射卷作存储">配置 Pod 使用投射卷作存储</a></li><li><a href=#%e4%bb%8e%e7%a7%81%e6%9c%89%e4%bb%93%e5%ba%93%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8f aria-label=从私有仓库拉取镜像>从私有仓库拉取镜像</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e5%ad%98%e6%b4%bb%e5%b0%b1%e7%bb%aa%e5%92%8c%e5%90%af%e5%8a%a8%e6%8e%a2%e9%92%88 aria-label=配置存活、就绪和启动探针>配置存活、就绪和启动探针</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e5%91%bd%e5%90%8d%e7%ab%af%e5%8f%a3 aria-label=使用命名端口>使用命名端口</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e5%90%af%e5%8a%a8%e6%8e%a2%e9%92%88%e4%bf%9d%e6%8a%a4%e6%85%a2%e5%90%af%e5%8a%a8%e5%ae%b9%e5%99%a8 aria-label=使用启动探针保护慢启动容器>使用启动探针保护慢启动容器</a></li><li><a href=#%e5%ae%9a%e4%b9%89%e5%b0%b1%e7%bb%aa%e6%8e%a2%e9%92%88 aria-label=定义就绪探针>定义就绪探针</a></li><li><a href=#%e9%85%8d%e7%bd%ae%e6%8e%a2%e9%92%88 aria-label=配置探针>配置探针</a></li><li><a href=#http-%e6%8e%a2%e6%b5%8b aria-label="HTTP 探测">HTTP 探测</a></li><li><a href=#tcp-%e6%8e%a2%e6%b5%8b aria-label="TCP 探测">TCP 探测</a></li><li><a href=#%e6%8e%a2%e9%92%88%e5%b1%82%e9%9d%a2%e7%9a%84-terminationgraceperiodseconds aria-label="探针层面的 terminationGracePeriodSeconds">探针层面的 <code>terminationGracePeriodSeconds</code></a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=集群的启动以及部署>集群的启动以及部署<a hidden class=anchor aria-hidden=true href=#集群的启动以及部署>#</a></h2><h3 id=kubectl>kubectl<a hidden class=anchor aria-hidden=true href=#kubectl>#</a></h3><blockquote><p><a href=https://kubernetes.io/docs/tasks/tools/#kubectl target=_blank>https://kubernetes.io/docs/tasks/tools/#kubectl</a></p></blockquote><p>Kubernetes 命令行工具
<a href=https://kubernetes.io/docs/reference/kubectl/kubectl/ target=_blank>kubectl</a>允许您对 Kubernetes 集群运行命令。您可以使用 kubectl 部署应用程序、检查和管理集群资源以及查看日志。有关更多信息（包括 kubectl 操作的完整列表），请参阅
<a href=https://kubernetes.io/docs/reference/kubectl/ target=_blank><code>kubectl</code>参考文档</a>。</p><p>kubectl 可安装在多种 Linux 平台、macOS 和 Windows 系统上。请在下方查找您偏好的操作系统。</p><ul><li><a href=https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/ target=_blank>在 Linux 上安装 kubectl</a></li><li><a href=https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/ target=_blank>在 macOS 上安装 kubectl</a></li><li><a href=https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/ target=_blank>在 Windows 上安装 kubectl</a></li></ul><h3 id=minikube>minikube
<a href=https://kubernetes.io/zh-cn/docs/tasks/tools/#minikube target=_blank></a></h3><p><a href="https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download#Service" target=_blank>https://minikube.sigs.k8s.io/docs/start/?arch=%2Fwindows%2Fx86-64%2Fstable%2F.exe+download#Service</a></p><p>先下载对应的安装包进行安装</p><p>minikube 是本地 Kubernetes，专注于让 Kubernetes 的学习和开发变得容易。</p><p>您只需要一个 Docker（或类似兼容的）容器或虚拟机环境，即可通过一条命令部署 Kubernetes：<code>minikube start</code></p><ol><li><p>在具有管理员权限（但未以 root 用户身份登录）的终端中运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube start
</span></span></code></pre></div><p>如果 minikube 启动失败，请参阅
<a href=https://minikube.sigs.k8s.io/docs/drivers/ target=_blank>驱动程序页面</a>，以获取有关设置兼容容器或虚拟机管理器的帮助。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 如果遇到镜像拉取失败的，让 minikube 里的 Docker daemon 也能走代理，把镜像拉下来。</span>
</span></span><span class=line><span class=cl><span class=c1># 以 Clash 为例，默认 127.0.0.1:7890</span>
</span></span><span class=line><span class=cl><span class=c1># 设置 minikube 使用主机 SOCKS5</span>
</span></span><span class=line><span class=cl>minikube delete                                        <span class=c1># 清掉之前失败的缓存</span>
</span></span><span class=line><span class=cl>minikube start --driver<span class=o>=</span>hyperv --docker-env <span class=nv>HTTP_PROXY</span><span class=o>=</span>socks5://host.minikube.internal:7890 <span class=sb>`</span>
</span></span><span class=line><span class=cl>                                      --docker-env <span class=nv>HTTPS_PROXY</span><span class=o>=</span>socks5://host.minikube.internal:7890
</span></span></code></pre></div><p><img alt=image-20251126170940955 loading=lazy src=http://qiniu.waite.wang/202511261709433.png></p></li><li><p>拉取镜像 暴露端口</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 拉镜像并启动容器</span>
</span></span><span class=line><span class=cl>kubectl create deployment hello-minikube --image<span class=o>=</span>kicbase/echo-server:1.0
</span></span><span class=line><span class=cl><span class=c1># 使用 NodePort 暴露端口， --port=8080 对应服务内部的端口</span>
</span></span><span class=line><span class=cl>kubectl expose deployment hello-minikube --type<span class=o>=</span>NodePort --port<span class=o>=</span><span class=m>8080</span>
</span></span></code></pre></div><ol start=3><li>可能需要一些时间，但运行以下命令后，您的部署很快就会显示出来：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get services hello-minikube
</span></span></code></pre></div><p><img alt=image-20251126172906940 loading=lazy src=http://qiniu.waite.wang/202511261729083.png></p><p>这代表服务映射到了该容器内部的的 32338 端口</p><ol start=4><li>访问此服务的最简单方法是让 minikube 为您启动一个 Web 浏览器：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube service hello-minikube
</span></span></code></pre></div><ol start=5><li>或者，可以使用 kubectl 进行端口转发：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl port-forward service/hello-minikube 7080:8080
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 把你 本地电脑（Windows）的 7080 端口 转发到 Kubernetes 集群里的 Service hello-minikube 的 8080 端口。</span>
</span></span></code></pre></div><p>您的应用程序现在可以在
<a href=http://localhost:7080/ target=_blank>http://localhost:7080/ 上</a>访问。</p><h3 id=管理你的集群>管理你的集群<a hidden class=anchor aria-hidden=true href=#管理你的集群>#</a></h3><p>暂停 Kubernetes 而不影响已部署的应用程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube pause
</span></span></code></pre></div><p>恢复已暂停的实例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube unpause
</span></span></code></pre></div><p>停止集群：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube stop
</span></span></code></pre></div><p>更改默认内存限制（需要重启）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube config <span class=nb>set</span> memory <span class=m>9001</span>
</span></span></code></pre></div><p>浏览易于安装的 Kubernetes 服务目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube addons list
</span></span></code></pre></div><p>创建第二个集群，运行旧版本的 Kubernetes：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube start -p aged --kubernetes-version<span class=o>=</span>v1.34.0
</span></span></code></pre></div><p>删除所有minikube集群：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube delete --all
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>eyJhbGciOiJSUzI1NiIsImtpZCI6Ik5kcmRfcWo0RGRLSUI0Y3I1bXFLNm9aeUJoNjRvbHQzdFMwcG9KRmYtbk0ifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIj
</span></span><span class=line><span class=cl>oxNzk1Njg3Nzg4LCJpYXQiOjE3NjQxNTE3ODgsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwianRpIjoiMDgxN2QyYTUtMjIxZC00NzUxLWE4ZDctZDUyMTZlMzAwZWFmIiwia3V
</span></span><span class=line><span class=cl>iZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiZGI4MGZhM2ItZTcxOC00ODIxLTg1YWUtNTE2M2Q5MWNhZWU0
</span></span><span class=line><span class=cl>In19LCJuYmYiOjE3NjQxNTE3ODgsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.wgv1-JvoLJBlsHMLaYyyTz0X9_luIwpNRdzcVVxu0cmK1L47X3mvL5T3YXKsX
</span></span><span class=line><span class=cl>2B-Ny8LatAnx_-Z0-HiTCh-KXigSZ6twqqsnNvb9MRnIfBoiGZcD2yL0tjFJoIVVSJLfJphfZSMtQC_cAvDt_tURwb4Wn9SGy5ZrgCwXdHnthmAapfNFtEWg167quMCoOYoycrk-MAlAiL4dNPaKaLQFb747sHCFFhTSsFd-snf1b
</span></span><span class=line><span class=cl>yP23MORxGF1gCT3iysrJ91pSknOTm9FCSjb6SiTCGR90k43yEpZ6787C--GZUyfpeFoa7HjWSlSzU77P-RE4SlGjYFKPynghK3vBPKMhI3TQ
</span></span></code></pre></div><h2 id=配置-pods-以及-容器>配置 Pods 以及 容器<a hidden class=anchor aria-hidden=true href=#配置-pods-以及-容器>#</a></h2><h3 id=为容器和-pod-分配内存资源>为容器和 Pod 分配内存资源<a hidden class=anchor aria-hidden=true href=#为容器和-pod-分配内存资源>#</a></h3><p>该页面上的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server target=_blank>metrics-server</a> 服务。 如果你已经有在运行中的 metrics-server，则可以跳过这些步骤。</p><p>如果你运行的是 Minikube，可以运行下面的命令启用 metrics-server：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>minikube addons <span class=nb>enable</span> metrics-server
</span></span></code></pre></div><p>要查看 metrics-server 或资源指标 API (<code>metrics.k8s.io</code>) 是否已经运行，请运行以下命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get apiservices
</span></span></code></pre></div><ol><li>创建命名空间</li></ol><p>创建一个命名空间，以便将本练习中创建的资源与集群的其余部分隔离。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl create namespace mem-example
</span></span><span class=line><span class=cl><span class=c1># 你也可以改成自己想要的命名空间名字 这里 mem-example 我改成了 waite</span>
</span></span></code></pre></div><ol start=2><li>指定内存请求以及限制</li></ol><p>要为容器指定内存请求，请在容器资源清单中包含 <code>resources: requests</code> 字段。 同理，要指定内存限制，请包含 <code>resources: limits</code>。</p><p>在本练习中，你将创建一个拥有一个容器的 Pod。 容器将会请求 100 MiB 内存，并且内存会被限制在 200 MiB 以内。 这是 Pod 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory-demo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>waite</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory-demo-ctr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>polinux/stress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;100Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;200Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;stress&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;--vm&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--vm-bytes&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;150M&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--vm-hang&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>]</span><span class=w>
</span></span></span></code></pre></div><p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。 <code>"--vm-bytes", "150M"</code> 参数告知容器尝试分配 150 MiB 内存。</p><ol start=3><li>开始创建 Pod (注意运行在同级目录)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f memory-request-limit.yaml --namespace<span class=o>=</span>waite
</span></span></code></pre></div><ol start=4><li>验证 Pod 中的容器是否已运行</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pod memory-demo --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>kubectl get pod -n waite
</span></span></code></pre></div><ol start=5><li>查看 Pod 相关的详细信息：</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pod memory-demo --output<span class=o>=</span>yaml --namespace<span class=o>=</span>waite
</span></span></code></pre></div><blockquote><p>输出结果显示：该 Pod 中容器的内存请求为 100 MiB，内存限制为 200 MiB。</p><p><img alt=image-20251127094704722 loading=lazy src=http://qiniu.waite.wang/202511270947026.png></p></blockquote><ol start=6><li>运行 <code>kubectl top</code> 命令，获取该 Pod 的指标数据, 输出结果显示：Pod 正在使用的内存大约为 150 MiB。 这大于 Pod 请求的 100 MiB，但在 Pod 限制的 200 MiB之内。</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl top pod memory-demo --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>NAME          CPU<span class=o>(</span>cores<span class=o>)</span>   MEMORY<span class=o>(</span>bytes<span class=o>)</span>   
</span></span><span class=line><span class=cl>memory-demo   76m          150Mi
</span></span></code></pre></div><ol start=7><li>删除 pod</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl delete pod memory-demo --namespace<span class=o>=</span>waite
</span></span></code></pre></div><blockquote><p>当节点拥有足够的可用内存时，容器可以使用其请求的内存。 但是，容器不允许使用超过其限制的内存。 如果容器分配的内存超过其限制，该容器会成为被终止的候选容器。 如果容器继续消耗超出其限制的内存，则终止容器。 如果终止的容器可以被重启，则 kubelet 会重新启动它，就像其他任何类型的运行时失败一样。</p><p>在本练习中，你将创建一个 Pod，尝试分配超出其限制的内存。 这是一个 Pod 的配置文件，其拥有一个容器，该容器的内存请求为 50 MiB，内存限制为 100 MiB：</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory-demo-2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>waite</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory-demo-2-ctr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>polinux/stress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;50Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;100Mi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;stress&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;--vm&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--vm-bytes&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;250M&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--vm-hang&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>]</span><span class=w>
</span></span></span></code></pre></div><p>在配置文件的 <code>args</code> 部分中，你可以看到容器会尝试分配 250 MiB 内存，这远高于 100 MiB 的限制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f memory-request-limit.yaml --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl get pod memory-demo-1 --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>NAME            READY   STATUS      RESTARTS       AGE
</span></span><span class=line><span class=cl>memory-demo-1   0/1     OOMKilled   <span class=m>5</span> <span class=o>(</span>107s ago<span class=o>)</span>   3m32s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl get pod memory-demo-1 --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>NAME            READY   STATUS             RESTARTS      AGE
</span></span><span class=line><span class=cl>memory-demo-1   0/1     CrashLoopBackOff   <span class=m>5</span> <span class=o>(</span>17s ago<span class=o>)</span>   3m35s
</span></span><span class=line><span class=cl><span class=c1># 容器反复重启又崩溃</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl get pod memory-demo-1 --output<span class=o>=</span>yaml --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>	......
</span></span><span class=line><span class=cl>   lastState:
</span></span><span class=line><span class=cl>      terminated:
</span></span><span class=line><span class=cl>        containerID: docker://718a86ad475ac286f097a31b6dd678aa2656d05df63fdb27aae32658b7ca19a6
</span></span><span class=line><span class=cl>        exitCode: <span class=m>1</span>
</span></span><span class=line><span class=cl>        finishedAt: <span class=s2>&#34;2025-11-27T01:52:34Z&#34;</span>
</span></span><span class=line><span class=cl>        reason: OOMKilled
</span></span><span class=line><span class=cl>        startedAt: <span class=s2>&#34;2025-11-27T01:52:34Z&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># 输出结果显示：由于内存溢出（OOM），容器已被杀掉</span>
</span></span></code></pre></div><blockquote><p>内存请求和限制是与容器关联的，但将 Pod 视为具有内存请求和限制，也是很有用的。 Pod 的内存请求是 Pod 中所有容器的内存请求之和。 同理，Pod 的内存限制是 Pod 中所有容器的内存限制之和。</p><p>Pod 的调度基于请求。只有当节点拥有足够满足 Pod 内存请求的内存时，才会将 Pod 调度至节点上运行。</p><p>在本练习中，你将创建一个 Pod，其内存请求超过了你集群中的任意一个节点所拥有的内存。 这是该 Pod 的配置文件，其拥有一个请求 1000 GiB 内存的容器，这应该超过了你集群中任何节点的容量。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory-demo-2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>waite</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>memory-demo-3-ctr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>polinux/stress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1000Gi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1000Gi&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;stress&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;--vm&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--vm-bytes&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;150M&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--vm-hang&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=p>]</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl apply -f memory-request-limit.yaml --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>pod/memory-demo-2 created
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl get pod -n waite
</span></span><span class=line><span class=cl>NAME            READY   STATUS    RESTARTS   AGE
</span></span><span class=line><span class=cl>memory-demo-2   0/1     Pending   <span class=m>0</span>          3s
</span></span><span class=line><span class=cl><span class=c1># 输出结果显示：Pod 处于 PENDING 状态。 这意味着，该 Pod 没有被调度至任何节点上运行，并且它会无限期的保持该状态：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl describe pod memory-demo-2 --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>Events:
</span></span><span class=line><span class=cl>  Type     Reason            Age   From               Message
</span></span><span class=line><span class=cl>  ----     ------            ----  ----               -------
</span></span><span class=line><span class=cl>  Warning  FailedScheduling  49s   default-scheduler  0/1 nodes are available: <span class=m>1</span> Insufficient memory. no new claims to deallocate, preemption: 0/1 nodes are available: <span class=m>1</span> Preemption is not helpful <span class=k>for</span> scheduling.
</span></span><span class=line><span class=cl><span class=c1># 输出结果显示：由于节点内存不足，该容器无法被调度：</span>
</span></span></code></pre></div><p>如果你没有为一个容器指定内存限制，则自动遵循以下情况之一：</p><ul><li>容器可无限制地使用内存。容器可以使用其所在节点所有的可用内存， 进而可能导致该节点调用 OOM Killer。 此外，如果发生 OOM Kill，没有资源限制的容器将被杀掉的可行性更大。</li><li>运行的容器所在命名空间有默认的内存限制，那么该容器会被自动分配默认限制。 集群管理员可用使用
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/#limitrange-v1-core target=_blank>LimitRange</a> 来指定默认的内存限制</li></ul><blockquote><p>删除命名空间。下面的命令会删除你根据这个任务创建的所有 Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl delete namespace mem-example
</span></span></code></pre></div></blockquote><h3 id=为容器以及-pods-分配-cpu-和内存资源>为容器以及 Pods 分配 CPU 和内存资源<a hidden class=anchor aria-hidden=true href=#为容器以及-pods-分配-cpu-和内存资源>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cpu-demo</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>waite</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cpu-demo-ctr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>polinux/stress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;1&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;0.5&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- -<span class=l>cpus</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=s2>&#34;2&#34;</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl get pod cpu-demo --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>NAME       READY   STATUS    RESTARTS   AGE
</span></span><span class=line><span class=cl>cpu-demo   1/1     Running   <span class=m>0</span>          2m46s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl get pod cpu-demo --output<span class=o>=</span>yaml --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>spec:
</span></span><span class=line><span class=cl>  containers:
</span></span><span class=line><span class=cl>  - args:
</span></span><span class=line><span class=cl>    - -cpus
</span></span><span class=line><span class=cl>    - <span class=s2>&#34;2&#34;</span>
</span></span><span class=line><span class=cl>    image: vish/stress
</span></span><span class=line><span class=cl>    imagePullPolicy: Always
</span></span><span class=line><span class=cl>    name: cpu-demo-ctr
</span></span><span class=line><span class=cl>    resources:
</span></span><span class=line><span class=cl>      limits:
</span></span><span class=line><span class=cl>        cpu: <span class=s2>&#34;1&#34;</span>
</span></span><span class=line><span class=cl>      requests:
</span></span><span class=line><span class=cl>        cpu: 500m
</span></span><span class=line><span class=cl><span class=c1># 输出显示 Pod 中的一个容器的 CPU 请求为 500 milliCPU，并且 CPU 限制为 1 个 CPU。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>D:<span class=se>\k</span>8s&gt;kubectl top pod cpu-demo --namespace<span class=o>=</span>waite
</span></span><span class=line><span class=cl>NAME       CPU<span class=o>(</span>cores<span class=o>)</span>   MEMORY<span class=o>(</span>bytes<span class=o>)</span>   
</span></span><span class=line><span class=cl>cpu-demo   1000m        0Mi
</span></span><span class=line><span class=cl><span class=c1># 此示例输出显示 Pod 使用的是 1000 M，小于等于限制的 1 GPU,  如果你的容器在只有 1 个 CPU 的节点上运行，则容器无论为容器指定的 CPU 限制如何， 都不能使用超过 1 个 CPU。</span>
</span></span></code></pre></div><blockquote><ol><li><p>如果不指定 CPU 限制</p><ul><li><p>容器在可以使用的 CPU 资源上没有上限。因而可以使用所在节点上所有的可用 CPU 资源。</p></li><li><p>容器在具有默认 CPU 限制的名字空间中运行，系统会自动为容器设置默认限制。 集群管理员可以使用
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/#limitrange-v1-core/ target=_blank>LimitRange</a> 指定 CPU 限制的默认值。如果你设置了 CPU 限制但未设置 CPU 请求</p></li></ul></li><li><p>如果你为容器指定了 CPU 限制值但未为其设置 CPU 请求，Kubernetes 会自动为其 设置与 CPU 限制相同的 CPU 请求值。类似的，如果容器设置了内存限制值但未设置 内存请求值，Kubernetes 也会为其设置与内存限制值相同的内存请求</p></li></ol></blockquote><h3 id=配置-pod-以使用卷进行存储>配置 Pod 以使用卷进行存储<a hidden class=anchor aria-hidden=true href=#配置-pod-以使用卷进行存储>#</a></h3><p>在本练习中，你将创建一个运行 Pod，该 Pod 仅运行一个容器并拥有一个类型为
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir target=_blank>emptyDir</a> 的卷， 在整个 Pod 生命周期中一直存在，即使 Pod 中的容器被终止和重启。以下是 Pod 的配置：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-storage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/data/redis</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>redis-storage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>emptyDir</span><span class=p>:</span><span class=w> </span>{}<span class=w>
</span></span></span></code></pre></div><blockquote><p><code>emptyDir</code> 卷 这种卷的生命周期是 <strong>与 Pod 绑定</strong> 的：</p><ul><li><strong>Pod 存在 → 卷存在</strong></li><li><strong>Pod 被删除或重建 → 卷被清空，数据永久丢失</strong></li></ul></blockquote><h3 id=配置-pod-以使用-persistentvolume-作为存储>配置 Pod 以使用 PersistentVolume 作为存储<a hidden class=anchor aria-hidden=true href=#配置-pod-以使用-persistentvolume-作为存储>#</a></h3><p>打开集群中的某个节点的 Shell。 如何打开 Shell 取决于集群的设置。 例如，如果你正在使用 Minikube，那么可以通过输入 <code>minikube ssh</code> 来打开节点的 Shell。</p><p>在该节点的 Shell 中，创建一个 <code>/mnt/data</code> 目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 这里假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
</span></span><span class=line><span class=cl>sudo mkdir /mnt/data
</span></span></code></pre></div><p>在 <code>/mnt/data</code> 目录中创建一个 index.html 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 这里再次假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
</span></span><span class=line><span class=cl>sudo sh -c <span class=s2>&#34;echo &#39;Hello from Kubernetes storage&#39; &gt; /mnt/data/index.html&#34;</span>
</span></span></code></pre></div><p>说明：</p><p>如果你的节点使用某工具而不是 <code>sudo</code> 来完成超级用户访问，你可以将上述命令中的 <code>sudo</code> 替换为该工具的名称。</p><p>测试 <code>index.html</code> 文件确实存在：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /mnt/data/index.html
</span></span></code></pre></div><p>输出应该是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Hello from Kubernetes storage
</span></span></code></pre></div><p>现在你可以关闭节点的 Shell 了, 后续我们会将 pods 绑定到该卷上。</p><p>在本练习中，你将创建一个 <strong>hostPath</strong> 类型的 PersistentVolume。 Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。 hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。</p><p>在生产集群中，你不会使用 hostPath。 集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。 集群管理员还可以使用
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/#storageclass-v1-storage-k8s-io target=_blank>StorageClass</a> 来设置
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/ target=_blank>动态制备存储</a>。</p><p>下面是 hostPath PersistentVolume 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>local</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>manual</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>capacity</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>10Gi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>ReadWriteOnce</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>hostPath</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/mnt/data&#34;</span><span class=w>
</span></span></span></code></pre></div><p>此配置文件指定卷位于集群节点上的 <code>/mnt/data</code> 路径。 其配置还指定了卷的容量大小为 10 GB，访问模式为 <code>ReadWriteOnce</code>， 这意味着该卷可以被单个节点以读写方式安装。 此配置文件还在 PersistentVolume 中定义了
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#class target=_blank>StorageClass 的名称</a>为 <code>manual</code>。 它将用于将 PersistentVolumeClaim 的请求绑定到此 PersistentVolume。</p><p>为了简化，本示例采用了 <code>ReadWriteOnce</code> 访问模式。然而对于生产环境， Kubernetes 项目建议改用 <code>ReadWriteOncePod</code> 访问模式。</p><p>创建 PersistentVolume：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</span></span></code></pre></div><p>查看 PersistentVolume 的信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>输出结果显示该 PersistentVolume 的<code>状态（STATUS）</code>为 <code>Available</code>。 这意味着它还没有被绑定给 PersistentVolumeClaim。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
</span></span><span class=line><span class=cl>task-pv-volume   10Gi       RWO           Retain          Available             manual                 
</span></span></code></pre></div><p>下一步是创建一个 PersistentVolumeClaim。 Pod 使用 PersistentVolumeClaim 来请求物理存储。 在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷， 该卷一次最多可以为一个节点提供读写访问。</p><p>下面是 PersistentVolumeClaim 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolumeClaim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-claim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>manual</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>ReadWriteOnce</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>3Gi</span><span class=w>
</span></span></span></code></pre></div><p><a href=https://kubernetes.io/zh-cn/docs/ target=_blank>Kubernetes 文档</a>
<a href=https://kubernetes.io/zh-cn/docs/tasks/ target=_blank>任务</a>
<a href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/ target=_blank>配置 Pods 和容器</a>
<a href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/ target=_blank>配置 Pod 以使用 PersistentVolume 作为存储</a></p><h3 id=配置-pod-以使用-persistentvolume-作为存储-1>配置 Pod 以使用 PersistentVolume 作为存储<a hidden class=anchor aria-hidden=true href=#配置-pod-以使用-persistentvolume-作为存储-1>#</a></h3><p>本文将向你介绍如何配置 Pod 使用
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank>PersistentVolumeClaim</a> 作为存储。 以下是该过程的总结：</p><ol><li>你作为集群管理员创建由物理存储支持的 PersistentVolume。你不会将该卷与任何 Pod 关联。</li><li>你现在以开发人员或者集群用户的角色创建一个 PersistentVolumeClaim， 它将自动绑定到合适的 PersistentVolume。</li><li>你创建一个使用以上 PersistentVolumeClaim 作为存储的 Pod。</li></ol><ul><li>你需要一个包含单个节点的 Kubernetes 集群，并且必须配置
<a href=https://kubernetes.io/zh-cn/docs/reference/kubectl/ target=_blank>kubectl</a> 命令行工具以便与集群交互。 如果还没有单节点集群，可以使用
<a href=https://minikube.sigs.k8s.io/docs/ target=_blank>Minikube</a> 创建一个。</li><li>熟悉
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/ target=_blank>持久卷</a>文档。</li></ul><p>在你的节点上创建一个 index.html 文件</p><p>打开集群中的某个节点的 Shell。 如何打开 Shell 取决于集群的设置。 例如，如果你正在使用 Minikube，那么可以通过输入 <code>minikube ssh</code> 来打开节点的 Shell。</p><p>在该节点的 Shell 中，创建一个 <code>/mnt/data</code> 目录：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 这里假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
</span></span><span class=line><span class=cl>sudo mkdir /mnt/data
</span></span></code></pre></div><p>在 <code>/mnt/data</code> 目录中创建一个 index.html 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 这里再次假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
</span></span><span class=line><span class=cl>sudo sh -c <span class=s2>&#34;echo &#39;Hello from Kubernetes storage&#39; &gt; /mnt/data/index.html&#34;</span>
</span></span></code></pre></div><p>说明：</p><p>如果你的节点使用某工具而不是 <code>sudo</code> 来完成超级用户访问，你可以将上述命令中的 <code>sudo</code> 替换为该工具的名称。</p><p>测试 <code>index.html</code> 文件确实存在：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /mnt/data/index.html
</span></span></code></pre></div><p>输出应该是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Hello from Kubernetes storage
</span></span></code></pre></div><p>现在你可以关闭节点的 Shell 了。</p><p>创建 PersistentVolume</p><p>在本练习中，你将创建一个 <strong>hostPath</strong> 类型的 PersistentVolume。 Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。 hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。</p><p>在生产集群中，你不会使用 hostPath。 集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。 集群管理员还可以使用
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/#storageclass-v1-storage-k8s-io target=_blank>StorageClass</a> 来设置
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/ target=_blank>动态制备存储</a>。</p><p>下面是 hostPath PersistentVolume 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>local</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>manual</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>capacity</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>10Gi</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>ReadWriteOnce</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>hostPath</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/mnt/data&#34;</span><span class=w>
</span></span></span></code></pre></div><p>此配置文件指定卷位于集群节点上的 <code>/mnt/data</code> 路径。 其配置还指定了卷的容量大小为 10 GB，访问模式为 <code>ReadWriteOnce</code>， 这意味着该卷可以被单个节点以读写方式安装。 此配置文件还在 PersistentVolume 中定义了
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#class target=_blank>StorageClass 的名称</a>为 <code>manual</code>。 它将用于将 PersistentVolumeClaim 的请求绑定到此 PersistentVolume。</p><p>为了简化，本示例采用了 <code>ReadWriteOnce</code> 访问模式。然而对于生产环境， Kubernetes 项目建议改用 <code>ReadWriteOncePod</code> 访问模式。</p><p>创建 PersistentVolume：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</span></span></code></pre></div><p>查看 PersistentVolume 的信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>输出结果显示该 PersistentVolume 的<code>状态（STATUS）</code>为 <code>Available</code>。 这意味着它还没有被绑定给 PersistentVolumeClaim。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
</span></span><span class=line><span class=cl>task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</span></span></code></pre></div><h3 id=创建-persistentvolumeclaim>创建 PersistentVolumeClaim<a hidden class=anchor aria-hidden=true href=#创建-persistentvolumeclaim>#</a></h3><p>下一步是创建一个 PersistentVolumeClaim。 Pod 使用 PersistentVolumeClaim 来请求物理存储。 在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷， 该卷一次最多可以为一个节点提供读写访问。</p><p>下面是 PersistentVolumeClaim 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>PersistentVolumeClaim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-claim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>storageClassName</span><span class=p>:</span><span class=w> </span><span class=l>manual</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>accessModes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>ReadWriteOnce</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>storage</span><span class=p>:</span><span class=w> </span><span class=l>3Gi</span><span class=w>
</span></span></span></code></pre></div><p>创建 PersistentVolumeClaim：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/storage/pv-claim.yaml
</span></span></code></pre></div><p>创建 PersistentVolumeClaim 之后，Kubernetes 控制平面将查找满足申领要求的 PersistentVolume。 如果控制平面找到具有相同 StorageClass 的适当的 PersistentVolume， 则将 PersistentVolumeClaim 绑定到该 PersistentVolume 上。</p><p>再次查看 PersistentVolume 信息：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>现在输出的 <code>STATUS</code> 为 <code>Bound</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                   STORAGECLASS   REASON    AGE
</span></span><span class=line><span class=cl>task-pv-volume   10Gi       RWO           Retain          Bound     default/task-pv-claim   manual                   2m
</span></span></code></pre></div><p>查看 PersistentVolumeClaim：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pvc task-pv-claim
</span></span></code></pre></div><p>输出结果表明该 PersistentVolumeClaim 绑定了你的 PersistentVolume <code>task-pv-volume</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NAME            STATUS    VOLUME           CAPACITY   ACCESSMODES   STORAGECLASS   AGE
</span></span><span class=line><span class=cl>task-pv-claim   Bound     task-pv-volume   10Gi       RWO           manual         30s
</span></span></code></pre></div><blockquote><p>各自角色</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>①  Provision  →  ② Binding  →  ③ Using  →  ④ Releasing  →  ⑤ Reclaiming
</span></span></code></pre></div><p>① <strong>供给（Provision）</strong>
 - <strong>静态</strong>：管理员先建好一批 PV 放着。
 - <strong>动态</strong>：没有合适 PV 时，PVC 会触发 CSI 驱动即刻创建一个 PV（<code>storageClassName</code> 不为空）。</p><p>② <strong>绑定（Binding）</strong>
 - Scheduler 持续 watch，一旦找到「最闲且字段匹配」的 PV，立即把 <code>pv.spec.claimRef</code> 写上 PVC 名字，<strong>一对一互锁</strong>，别的 PVC 再也抢不到。</p><p>③ <strong>使用（Using）</strong>
 - Pod 通过 <code>persistentVolumeClaim</code> 字段挂载，<strong>容器里看到的就是 PV 背后的真实存储路径</strong>。</p><ul><li>此时就算 Pod 重建、调度到别的节点，只要 PVC 在，数据就跟着走。</li></ul><p>④ <strong>释放（Releasing）</strong>
 - 用户 <code>kubectl delete pvc task-pvc</code>；PV 状态变成 <code>Released</code>，但数据还在（取决于回收策略）。</p><p>⑤ <strong>回收（Reclaiming）</strong>
 - <strong>Retain</strong>：人工清理，<code>pv.status.phase=Released</code>，需要管理员手动 <code>kubectl delete pv</code> 并到存储后端删数据。
 - <strong>Delete</strong>：CSI 自动把后端卷一起删掉（云盘常用）。
 - <strong>Recycle</strong>（已废弃）：曾用 <code>rm -rf</code> 清目录。</p></blockquote><table><thead><tr><th style=text-align:left>对象</th><th style=text-align:left>谁创建</th><th style=text-align:left>作用</th><th style=text-align:left>类比</th></tr></thead><tbody><tr><td style=text-align:left><strong>PersistentVolume (PV)</strong></td><td style=text-align:left>集群管理员（或 CSI 自动供给）</td><td style=text-align:left>提供一段真实的存储资源</td><td style=text-align:left>楼盘</td></tr><tr><td style=text-align:left><strong>PersistentVolumeClaim (PVC)</strong></td><td style=text-align:left>应用开发者（用户）</td><td style=text-align:left>申请一段存储，声明容量、访问模式、Storage</td><td style=text-align:left>购房合同创建 Pod</td></tr></tbody></table><p>下一步是创建一个使用你的 PersistentVolumeClaim 作为存储卷的 Pod。</p><p>下面是此 Pod 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-storage</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>persistentVolumeClaim</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>claimName</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-claim</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-container</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;http-server&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/usr/share/nginx/html&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>task-pv-storage</span><span class=w>
</span></span></span></code></pre></div><p>注意 Pod 的配置文件指定了 PersistentVolumeClaim，但没有指定 PersistentVolume。 对 Pod 而言，PersistentVolumeClaim 就是一个存储卷。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml
</span></span></code></pre></div><p>检查 Pod 中的容器是否运行正常：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pod task-pv-pod
</span></span></code></pre></div><p>打开一个 Shell 访问 Pod 中的容器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl <span class=nb>exec</span> -it task-pv-pod -- /bin/bash
</span></span></code></pre></div><p>在 Shell 中，验证 Nginx 是否正在从 hostPath 卷提供 <code>index.html</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 一定要在上一步 &#34;kubectl exec&#34; 所返回的 Shell 中执行下面三个命令</span>
</span></span><span class=line><span class=cl>apt update
</span></span><span class=line><span class=cl>apt install curl
</span></span><span class=line><span class=cl>curl http://localhost/
</span></span></code></pre></div><p>输出结果是你之前写到 hostPath 卷中的 <code>index.html</code> 文件中的内容：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Hello from Kubernetes storage
</span></span></code></pre></div><p>如果你看到此消息，则证明你已经成功地配置了 Pod 使用 PersistentVolumeClaim 的存储。</p><h3 id=配置-pod-使用投射卷作存储>配置 Pod 使用投射卷作存储<a hidden class=anchor aria-hidden=true href=#配置-pod-使用投射卷作存储>#</a></h3><p>本练习中，你将使用本地文件来创建用户名和密码
<a href=https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/ target=_blank>Secret</a>， 然后创建运行一个容器的 Pod， 该 Pod 使用
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#projected target=_blank><code>projected</code></a> 卷将 Secret 挂载到相同的路径下。</p><p>下面是 Pod 的配置文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-projected-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test-projected-volume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>busybox:1.28</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>sleep</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=s2>&#34;86400&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>all-in-one</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/projected-volume&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>readOnly</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>all-in-one</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>projected</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>sources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>secret</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>user</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>secret</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>pass</span><span class=w>
</span></span></span></code></pre></div><ol><li><p>创建 Secret：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 创建包含用户名和密码的文件：</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> -n <span class=s2>&#34;admin&#34;</span> &gt; ./username.txt
</span></span><span class=line><span class=cl><span class=nb>echo</span> -n <span class=s2>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 在 Secret 中引用上述文件</span>
</span></span><span class=line><span class=cl>kubectl create secret generic user --from-file<span class=o>=</span>./username.txt
</span></span><span class=line><span class=cl>kubectl create secret generic pass --from-file<span class=o>=</span>./password.txt
</span></span></code></pre></div></li><li><p>创建 Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/storage/projected.yaml
</span></span></code></pre></div></li><li><p>确认 Pod 中的容器运行正常，然后监视 Pod 的变化：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get --watch pod test-projected-volume
</span></span></code></pre></div><p>输出结果和下面类似：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NAME                    READY     STATUS    RESTARTS   AGE
</span></span><span class=line><span class=cl>test-projected-volume   1/1       Running   0          14s
</span></span></code></pre></div></li><li><p>在另外一个终端中，打开容器的 shell：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl <span class=nb>exec</span> -it test-projected-volume -- /bin/sh
</span></span></code></pre></div></li><li><p>在 shell 中，确认 <code>projected-volume</code> 目录包含你的投射源：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ <span class=c1># ls /projected-volume/</span>
</span></span><span class=line><span class=cl>password.txt  username.txt
</span></span><span class=line><span class=cl>/ <span class=c1># cat /projected-volume/username.txt</span>
</span></span><span class=line><span class=cl>-n <span class=s2>&#34;admin&#34;</span>
</span></span></code></pre></div></li></ol><h3 id=从私有仓库拉取镜像>从私有仓库拉取镜像<a hidden class=anchor aria-hidden=true href=#从私有仓库拉取镜像>#</a></h3><p>在个人电脑上，要想拉取私有镜像必须在镜像仓库上进行身份验证。</p><p>使用 <code>docker</code> 命令工具来登录到 Docker Hub。 更多详细信息，请查阅
<a href=https://docs.docker.com/docker-id/#log-in target=_blank>Docker ID accounts</a> 中的 <strong>log in</strong> 部分。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker login
</span></span></code></pre></div><p>当出现提示时，输入你的 Docker ID 和登录凭据（访问令牌或 Docker ID 的密码）。</p><p>登录过程会创建或更新保存有授权令牌的 <code>config.json</code> 文件。 查看
<a href=https://kubernetes.io/zh-cn/docs/concepts/containers/images#config-json target=_blank>Kubernetes 如何解析这个文件</a>。</p><p>查看 <code>config.json</code> 文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat ~/.docker/config.json
</span></span></code></pre></div><p>输出结果包含类似于以下内容的部分：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;auths&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nt>&#34;https://index.docker.io/v1/&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;auth&#34;</span><span class=p>:</span> <span class=s2>&#34;c3R...zE2&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果使用 Docker 凭据仓库，则不会看到 <code>auth</code> 条目，看到的将是以仓库名称作为值的 <code>credsStore</code> 条目。 在这种情况下，你可以直接创建一个 Secret。 请参阅
<a href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line target=_blank>在命令行上提供凭据来创建 Secret</a>。</p><p>Kubernetes 集群使用 <code>kubernetes.io/dockerconfigjson</code> 类型的 Secret 来通过镜像仓库的身份验证，进而提取私有镜像。</p><p>如果你已经运行了 <code>docker login</code> 命令，你可以复制该镜像仓库的凭据到 Kubernetes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl create secret generic regcred <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --from-file<span class=o>=</span>.dockerconfigjson<span class=o>=</span>&lt;path/to/.docker/config.json&gt; <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --type<span class=o>=</span>kubernetes.io/dockerconfigjson
</span></span></code></pre></div><p>如果你需要更多的设置（例如，为新 Secret 设置名字空间或标签）， 则可以在存储 Secret 之前对它进行自定义。 请务必：</p><ul><li>将 data 项中的名称设置为 <code>.dockerconfigjson</code></li><li>使用 base64 编码方法对 Docker 配置文件进行编码，然后粘贴该字符串的内容，作为字段 <code>data[".dockerconfigjson"]</code> 的值</li><li>将 <code>type</code> 设置为 <code>kubernetes.io/dockerconfigjson</code></li></ul><p>示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Secret</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>myregistrykey</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>awesomeapps</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>data</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>.dockerconfigjson</span><span class=p>:</span><span class=w> </span><span class=l>UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>kubernetes.io/dockerconfigjson</span><span class=w>
</span></span></span></code></pre></div><p>如果你收到错误消息：<code>error: no objects passed to create</code>， 这可能意味着 base64 编码的字符串是无效的。如果你收到类似 <code>Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code> 的错误消息，则表示数据中的 base64 编码字符串已成功解码， 但无法解析为 <code>.docker/config.json</code> 文件。</p><p>创建 Secret，命名为 <code>regcred</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl create secret docker-registry regcred <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-server<span class=o>=</span>&lt;你的镜像仓库服务器&gt; <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-username<span class=o>=</span>&lt;你的用户名&gt; <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-password<span class=o>=</span>&lt;你的密码&gt; <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  --docker-email<span class=o>=</span>&lt;你的邮箱地址&gt;
</span></span></code></pre></div><p>在这里：</p><ul><li><code>&lt;your-registry-server></code> 是你的私有 Docker 仓库全限定域名（FQDN）。 DockerHub 使用 <code>https://index.docker.io/v1/</code>。</li><li><code>&lt;your-name></code> 是你的 Docker 用户名。</li><li><code>&lt;your-pword></code> 是你的 Docker 密码。</li><li><code>&lt;your-email></code> 是你的 Docker 邮箱。</li></ul><p>这样你就成功地将集群中的 Docker 凭据设置为名为 <code>regcred</code> 的 Secret。</p><p>在命令行上键入 Secret 可能会将它们存储在你的 Shell 历史记录中而不受保护， 并且这些 Secret 信息也可能在 <code>kubectl</code> 运行期间对你 PC 上的其他用户可见。</p><p>了解你创建的 <code>regcred</code> Secret 的内容，可以用 YAML 格式进行查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get secret regcred --output<span class=o>=</span>yaml
</span></span></code></pre></div><p>输出和下面类似：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Secret</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>regcred</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>data</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>.dockerconfigjson</span><span class=p>:</span><span class=w> </span><span class=l>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>kubernetes.io/dockerconfigjson</span><span class=w>
</span></span></span></code></pre></div><p><code>.dockerconfigjson</code> 字段的值是 Docker 凭据的 base64 表示。</p><p>要了解 <code>dockerconfigjson</code> 字段中的内容，请将 Secret 数据转换为可读格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get secret regcred --output<span class=o>=</span><span class=s2>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> <span class=p>|</span> base64 --decode
</span></span></code></pre></div><p>输出和下面类似：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span><span class=nt>&#34;auths&#34;</span><span class=p>:{</span><span class=nt>&#34;your.private.registry.example.com&#34;</span><span class=p>:{</span><span class=nt>&#34;username&#34;</span><span class=p>:</span><span class=s2>&#34;janedoe&#34;</span><span class=p>,</span><span class=nt>&#34;password&#34;</span><span class=p>:</span><span class=s2>&#34;xxxxxxxxxxx&#34;</span><span class=p>,</span><span class=nt>&#34;email&#34;</span><span class=p>:</span><span class=s2>&#34;jdoe@example.com&#34;</span><span class=p>,</span><span class=nt>&#34;auth&#34;</span><span class=p>:</span><span class=s2>&#34;c3R...zE2&#34;</span><span class=p>}}}</span>
</span></span></code></pre></div><p>要了解 <code>auth</code> 字段中的内容，请将 base64 编码过的数据转换为可读格式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;c3R...zE2&#34;</span> <span class=p>|</span> base64 --decode
</span></span></code></pre></div><p>输出结果中，用户名和密码用 <code>:</code> 链接，类似下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>janedoe:xxxxxxxxxxx
</span></span></code></pre></div><p>注意，Secret 数据包含与本地 <code>~/.docker/config.json</code> 文件类似的授权令牌。</p><p>这样你就已经成功地将 Docker 凭据设置为集群中的名为 <code>regcred</code> 的 Secret。</p><p>下面是一个 Pod 配置清单示例，该示例中 Pod 需要访问你的 Docker 凭据 <code>regcred</code>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>private-reg</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>private-reg-container</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>&lt;your-private-image&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>imagePullSecrets</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>regcred</span><span class=w>
</span></span></span></code></pre></div><p>将上述文件下载到你的计算机中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>curl -L -o my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</span></span></code></pre></div><p>在 <code>my-private-reg-pod.yaml</code> 文件中，使用私有仓库的镜像路径替换 <code>&lt;your-private-image></code>，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>your.private.registry.example.com/janedoe/jdoe-private:v1
</span></span></code></pre></div><p>要从私有仓库拉取镜像，Kubernetes 需要凭据。 配置文件中的 <code>imagePullSecrets</code> 字段表明 Kubernetes 应该通过名为 <code>regcred</code> 的 Secret 获取凭据。</p><p>创建使用了你的 Secret 的 Pod，并检查它是否正常运行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f my-private-reg-pod.yaml
</span></span><span class=line><span class=cl>kubectl get pod private-reg
</span></span></code></pre></div><p>要为 Pod（或 Deployment，或其他有 Pod 模板的对象）使用镜像拉取 Secret， 你需要确保合适的 Secret 确实存在于正确的名字空间中。 要使用的是你定义 Pod 时所用的名字空间。</p><p>此外，如果 Pod 启动失败，状态为 <code>ImagePullBackOff</code>，查看 Pod 事件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl describe pod private-reg
</span></span></code></pre></div><p>如果你看到一个原因设为 <code>FailedToRetrieveImagePullSecret</code> 的事件， 那么 Kubernetes 找不到指定名称（此例中为 <code>regcred</code>）的 Secret。</p><p>确保你指定的 Secret 存在，并且其名称拼写正确。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Events:
</span></span><span class=line><span class=cl>  ...  Reason                           ...  Message
</span></span><span class=line><span class=cl>       ------                                -------
</span></span><span class=line><span class=cl>  ...  FailedToRetrieveImagePullSecret  ...  Unable to retrieve some image pull secrets <span class=o>(</span>&lt;regcr
</span></span></code></pre></div><h3 id=配置存活就绪和启动探针>配置存活、就绪和启动探针<a hidden class=anchor aria-hidden=true href=#配置存活就绪和启动探针>#</a></h3><p><a href=https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/ target=_blank>kubelet</a> 使用存活探针来确定什么时候要重启容器。 例如，存活探针可以探测到应用死锁（应用在运行，但是无法继续执行后面的步骤）情况。 重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。</p><p>存活探针的常见模式是为就绪探针使用相同的低成本 HTTP 端点，但具有更高的 <code>failureThreshold</code>。 这样可以确保在硬性终止 Pod 之前，将观察到 Pod 在一段时间内处于非就绪状态。</p><p>kubelet 使用就绪探针可以知道容器何时准备好接受请求流量。 这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。 当 Pod 的 <code>Ready</code>
<a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions target=_blank>状况</a> 为 true 时，Pod 被认为是就绪的。若 Pod 未就绪，会被从 Service 的负载均衡器中剔除。 当 Pod 所在节点的 <code>Ready</code> 状况不为 true 时、当 Pod 的某个 <code>readinessGates</code> 为 false 时，或者当 Pod 中有任何一个容器未就绪时，Pod 的 <code>Ready</code> 状况为 false。</p><p>kubelet 使用启动探针来了解应用容器何时启动。 如果配置了这类探针，存活探针和就绪探针在启动探针成功之前不会启动，从而确保存活探针或就绪探针不会影响应用的启动。 启动探针可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</p><p>存活探针是一种从应用故障中恢复的强劲方式，但应谨慎使用。 你必须仔细配置存活探针，确保它能真正标示出不可恢复的应用故障，例如死锁。</p><p>错误的存活探针可能会导致级联故障。 这会导致在高负载下容器重启；例如由于应用无法扩展，导致客户端请求失败；以及由于某些 Pod 失败而导致剩余 Pod 的工作负载增加。了解就绪探针和存活探针之间的区别， 以及何时为应用配置使用它们非常重要。</p><p>许多长时间运行的应用最终会进入损坏状态，除非重新启动，否则无法被恢复。 Kubernetes 提供了存活探针来发现并处理这种情况。</p><p>在本练习中，你会创建一个 Pod，其中运行一个基于 <code>registry.k8s.io/busybox:1.27.2</code> 镜像的容器。 下面是这个 Pod 的配置文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>test</span><span class=p>:</span><span class=w> </span><span class=l>liveness</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness-exec</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.k8s.io/busybox:1.27.2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>/bin/sh</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- -<span class=l>c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>exec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>command</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>cat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=l>/tmp/healthy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span></code></pre></div><p>在这个配置文件中，可以看到 Pod 中只有一个 <code>Container</code>。 <code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。 kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。 如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。 如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p><p>当容器启动时，执行如下的命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/bin/sh -c <span class=s2>&#34;touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600&#34;</span>
</span></span></code></pre></div><p>这个容器生命的前 30 秒，<code>/tmp/healthy</code> 文件是存在的。 所以在这最开始的 30 秒内，执行命令 <code>cat /tmp/healthy</code> 会返回成功代码。 30 秒之后，执行命令 <code>cat /tmp/healthy</code> 就会返回失败代码。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</span></span></code></pre></div><p>在 30 秒内，查看 Pod 的事件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>输出结果表明还没有存活探针失败：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Type    Reason     Age   From               Message
</span></span><span class=line><span class=cl>----    ------     ----  ----               -------
</span></span><span class=line><span class=cl>Normal  Scheduled  11s   default-scheduler  Successfully assigned default/liveness-exec to node01
</span></span><span class=line><span class=cl>Normal  Pulling    9s    kubelet, node01    Pulling image &#34;registry.k8s.io/busybox:1.27.2&#34;
</span></span><span class=line><span class=cl>Normal  Pulled     7s    kubelet, node01    Successfully pulled image &#34;registry.k8s.io/busybox:1.27.2&#34;
</span></span><span class=line><span class=cl>Normal  Created    7s    kubelet, node01    Created container liveness
</span></span><span class=line><span class=cl>Normal  Started    7s    kubelet, node01    Started container liveness
</span></span></code></pre></div><p>35 秒之后，再来看 Pod 的事件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>在输出结果的最下面，有信息显示存活探针失败了，这个失败的容器被杀死并且被重建了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Type     Reason     Age                From               Message
</span></span><span class=line><span class=cl>----     ------     ----               ----               -------
</span></span><span class=line><span class=cl>Normal   Scheduled  57s                default-scheduler  Successfully assigned default/liveness-exec to node01
</span></span><span class=line><span class=cl>Normal   Pulling    55s                kubelet, node01    Pulling image &#34;registry.k8s.io/busybox:1.27.2&#34;
</span></span><span class=line><span class=cl>Normal   Pulled     53s                kubelet, node01    Successfully pulled image &#34;registry.k8s.io/busybox:1.27.2&#34;
</span></span><span class=line><span class=cl>Normal   Created    53s                kubelet, node01    Created container liveness
</span></span><span class=line><span class=cl>Normal   Started    53s                kubelet, node01    Started container liveness
</span></span><span class=line><span class=cl>Warning  Unhealthy  10s (x3 over 20s)  kubelet, node01    Liveness probe failed: cat: can&#39;t open &#39;/tmp/healthy&#39;: No such file or directory
</span></span><span class=line><span class=cl>Normal   Killing    10s                kubelet, node01    Container liveness failed liveness probe, will be restarted
</span></span></code></pre></div><p>再等 30 秒，确认这个容器被重启了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl get pod liveness-exec
</span></span></code></pre></div><p>输出结果显示 <code>RESTARTS</code> 的值增加了 1。 请注意，一旦失败的容器恢复为运行状态，<code>RESTARTS</code> 计数器就会增加 1：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>NAME            READY     STATUS    RESTARTS   AGE
</span></span><span class=line><span class=cl>liveness-exec   1/1       Running   1          1m
</span></span></code></pre></div><p>另外一种类型的存活探测方式是使用 HTTP GET 请求。 下面是一个 Pod 的配置文件，其中运行一个基于 <code>registry.k8s.io/e2e-test-images/agnhost</code> 镜像的容器。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>test</span><span class=p>:</span><span class=w> </span><span class=l>liveness</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness-http</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.k8s.io/e2e-test-images/agnhost:2.40</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>args</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>liveness</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>httpHeaders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Custom-Header</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>Awesome</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span></code></pre></div><p>在这个配置文件中，你可以看到 Pod 也只有一个容器。 <code>periodSeconds</code> 字段指定了 kubelet 每隔 3 秒执行一次存活探测。 <code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。 kubelet 会向容器内运行的服务（服务在监听 8080 端口）发送一个 HTTP GET 请求来执行探测。 如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。 如果处理程序返回失败代码，则 kubelet 会杀死这个容器并将其重启。</p><p>返回大于或等于 200 并且小于 400 的任何代码都标示成功，其它返回代码都标示失败。</p><p>你可以访问
<a href=https://github.com/kubernetes/kubernetes/blob/master/test/images/agnhost/liveness/server.go target=_blank><code>server.go</code></a> 阅读服务的源码。 容器存活期间的最开始 10 秒中，<code>/healthz</code> 处理程序返回 200 的状态码。 之后处理程序返回 500 的状态码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>http</span><span class=p>.</span><span class=nf>HandleFunc</span><span class=p>(</span><span class=s>&#34;/healthz&#34;</span><span class=p>,</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=nx>w</span><span class=w> </span><span class=nx>http</span><span class=p>.</span><span class=nx>ResponseWriter</span><span class=p>,</span><span class=w> </span><span class=nx>r</span><span class=w> </span><span class=o>*</span><span class=nx>http</span><span class=p>.</span><span class=nx>Request</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>duration</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>().</span><span class=nf>Sub</span><span class=p>(</span><span class=nx>started</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>duration</span><span class=p>.</span><span class=nf>Seconds</span><span class=p>()</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=mi>500</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Sprintf</span><span class=p>(</span><span class=s>&#34;error: %v&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>duration</span><span class=p>.</span><span class=nf>Seconds</span><span class=p>())))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>w</span><span class=p>.</span><span class=nf>WriteHeader</span><span class=p>(</span><span class=mi>200</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>w</span><span class=p>.</span><span class=nf>Write</span><span class=p>([]</span><span class=nb>byte</span><span class=p>(</span><span class=s>&#34;ok&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>})</span><span class=w>
</span></span></span></code></pre></div><p>kubelet 在容器启动之后 3 秒开始执行健康检查。所以前几次健康检查都是成功的。 但是 10 秒之后，健康检查会失败，并且 kubelet 会杀死容器再重新启动容器。</p><p>创建一个 Pod 来测试 HTTP 的存活检测：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</span></span></code></pre></div><p>10 秒之后，通过查看 Pod 事件来确认存活探针已经失败，并且容器被重新启动了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl describe pod liveness-http
</span></span></code></pre></div><p>在 1.13 之后的版本中，设置本地的 HTTP 代理环境变量不会影响 HTTP 的存活探测。</p><p>第三种类型的存活探测是使用 TCP 套接字。 使用这种配置时，kubelet 会尝试在指定端口和容器建立套接字链接。 如果能建立连接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>goproxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>goproxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>goproxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.k8s.io/goproxy:0.1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>tcpSocket</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>15</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>tcpSocket</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>15</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span></code></pre></div><p>如你所见，TCP 检测的配置和 HTTP 检测非常相似。 下面这个例子同时使用就绪探针和存活探针。kubelet 会在容器启动 15 秒后运行第一次存活探测。 此探测会尝试连接 <code>goproxy</code> 容器的 8080 端口。 如果此存活探测失败，容器将被重启。kubelet 将继续每隔 10 秒运行一次这种探测。</p><p>除了存活探针，这个配置还包括一个就绪探针。 kubelet 会在容器启动 15 秒后运行第一次就绪探测。 与存活探测类似，就绪探测会尝试连接 <code>goproxy</code> 容器的 8080 端口。 如果就绪探测失败，Pod 将被标记为未就绪，且不会接收来自任何服务的流量。</p><p>要尝试 TCP 存活检测，运行以下命令创建 Pod：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</span></span></code></pre></div><p>15 秒之后，通过查看 Pod 事件来检测存活探针：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl describe pod goproxy
</span></span></code></pre></div><h4 id=定义-grpc-存活探针>定义 gRPC 存活探针
<a href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe target=_blank></a></h4><p>如果你的应用实现了
<a href=https://github.com/grpc/grpc/blob/master/doc/health-checking.md target=_blank>gRPC 健康检查协议</a>， 这个例子展示了如何配置 Kubernetes 以将其用于应用的存活性检查。 类似地，你可以配置就绪探针和启动探针。</p><p>下面是一个示例清单：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>etcd-with-grpc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>etcd</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>registry.k8s.io/etcd:3.5.1-0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=w> </span><span class=s2>&#34;/usr/local/bin/etcd&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--data-dir&#34;</span><span class=p>,</span><span class=w>  </span><span class=s2>&#34;/var/lib/etcd&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--listen-client-urls&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;http://0.0.0.0:2379&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--advertise-client-urls&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;http://127.0.0.1:2379&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;--log-level&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;debug&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>2379</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>grpc</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>2379</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span></code></pre></div><p>要使用 gRPC 探针，必须配置 <code>port</code> 属性。 如果要区分不同类型的探针和不同功能的探针，可以使用 <code>service</code> 字段。 你可以将 <code>service</code> 设置为 <code>liveness</code>，并使你的 gRPC 健康检查端点对该请求的响应与将 <code>service</code> 设置为 <code>readiness</code> 时不同。 这使你可以使用相同的端点进行不同类型的容器健康检查而不是监听两个不同的端口。 如果你想指定自己的自定义服务名称并指定探测类型，Kubernetes 项目建议你使用使用一个可以关联服务和探测类型的名称来命名。 例如：<code>myservice-liveness</code>（使用 <code>-</code> 作为分隔符）。</p><p>与 HTTP 或 TCP 探针不同，gRPC 探测不能按名称指定健康检查端口， 也不能自定义主机名。</p><p>配置问题（例如：错误的 <code>port</code> 或 <code>service</code>、未实现健康检查协议） 都被认作是探测失败，这一点与 HTTP 和 TCP 探针类似。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl apply -f https://k8s.io/examples/pods/probe/grpc-liveness.yaml
</span></span></code></pre></div><p>15 秒钟之后，查看 Pod 事件确认存活性检查并未失败：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>kubectl describe pod etcd-with-grpc
</span></span></code></pre></div><p>当使用 gRPC 探针时，需要注意以下一些技术细节：</p><ul><li>这些探针运行时针对的是 Pod 的 IP 地址或其主机名。 请一定配置你的 gRPC 端点使之监听于 Pod 的 IP 地址之上。</li><li>这些探针不支持任何身份认证参数（例如 <code>-tls</code>）。</li><li>对于内置的探针而言，不存在错误代码。所有错误都被视作探测失败。</li><li>如果 <code>ExecProbeTimeout</code> 特性门控被设置为 <code>false</code>，则 <code>grpc-health-probe</code> 不会考虑 <code>timeoutSeconds</code> 设置状态（默认值为 <code>1s</code>）， 而内置探针则会在超时时返回失败。</li></ul><h4 id=使用命名端口>使用命名端口<a hidden class=anchor aria-hidden=true href=#使用命名端口>#</a></h4><p>对于 HTTP 和 TCP 存活检测可以使用命名的
<a href=https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#ports target=_blank><code>port</code></a> （gRPC 探针不支持使用命名端口）。</p><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span></code></pre></div><h4 id=使用启动探针保护慢启动容器>使用启动探针保护慢启动容器<a hidden class=anchor aria-hidden=true href=#使用启动探针保护慢启动容器>#</a></h4><p>有时候，会有一些现有的应用在启动时需要较长的初始化时间。 在这种情况下，若要不影响对死锁作出快速响应的探测，设置存活探测参数是要技巧的。 解决办法是使用相同的命令来设置启动探测，针对 HTTP 或 TCP 检测，可以通过将 <code>failureThreshold * periodSeconds</code> 参数设置为足够长的时间来应对最糟糕情况下的启动时间。</p><p>这样，前面的例子就变成了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>startupProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span></code></pre></div><p>幸亏有启动探测，应用将会有最多 5 分钟（30 * 10 = 300s）的时间来完成其启动过程。 一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁作出快速响应。 如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 <code>restartPolicy</code> 来执行进一步处置。</p><h4 id=定义就绪探针>定义就绪探针<a hidden class=anchor aria-hidden=true href=#定义就绪探针>#</a></h4><p>有时候，应用会暂时性地无法为请求提供服务。 例如，应用在启动时可能需要加载大量的数据或配置文件，或是启动后要依赖等待外部服务。 在这种情况下，既不想杀死应用，也不想给它发送请求。 Kubernetes 提供了就绪探针来发现并缓解这些情况。 容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service 的流量。</p><blockquote><p>就绪探针在容器的整个生命周期中保持运行状态。</p></blockquote><p>存活探针与就绪性探针相互间不等待对方成功。 如果要在执行就绪性探针之前等待，应该使用 <code>initialDelaySeconds</code> 或 <code>startupProbe</code>。</p><p>就绪探针的配置和存活探针的配置相似。 唯一区别就是要使用 <code>readinessProbe</code> 字段，而不是 <code>livenessProbe</code> 字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>exec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>cat</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=l>/tmp/healthy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>5</span><span class=w>
</span></span></span></code></pre></div><p>HTTP 和 TCP 的就绪探针配置也和存活探针的配置完全相同。</p><p>就绪和存活探测可以在同一个容器上并行使用。 两者共同使用，可以确保流量不会发给还未就绪的容器，当这些探测失败时容器会被重新启动。</p><h4 id=配置探针>配置探针<a hidden class=anchor aria-hidden=true href=#配置探针>#</a></h4><p><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/#probe-v1-core target=_blank>Probe</a> 有很多配置字段，可以使用这些字段精确地控制启动、存活和就绪检测的行为：</p><ul><li><p><code>initialDelaySeconds</code>：容器启动后要等待多少秒后才启动启动、存活和就绪探针。 如果定义了启动探针，则存活探针和就绪探针的延迟将在启动探针已成功之后才开始计算。 在某些较旧的 Kubernetes 版本中，如果 <code>periodSeconds</code> 的值大于 <code>initialDelaySeconds</code>， 则 <code>initialDelaySeconds</code> 将被忽略。然而，在当前版本中，<code>initialDelaySeconds</code> 总是被遵守， 并且探测不会在这个初始延迟之前开始。默认是 0 秒，最小值是 0。</p></li><li><p><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。 当容器未就绪时，<code>ReadinessProbe</code> 可能会在除配置的 <code>periodSeconds</code> 间隔以外的时间执行。这是为了让 Pod 更快地达到可用状态。</p></li><li><p><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</p></li><li><p><code>successThreshold</code>：探针在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</p></li><li><p><code>failureThreshold</code>：探针连续失败了 <code>failureThreshold</code> 次之后， Kubernetes 认为总体上检查已失败：容器状态未就绪、不健康、不活跃。 默认值为 3，最小值为 1。 对于启动探针或存活探针而言，如果至少有 <code>failureThreshold</code> 个探针已失败， Kubernetes 会将容器视为不健康并为这个特定的容器触发重启操作。 kubelet 遵循该容器的 <code>terminationGracePeriodSeconds</code> 设置。 对于失败的就绪探针，kubelet 继续运行检查失败的容器，并继续运行更多探针； 因为检查失败，kubelet 将 Pod 的 <code>Ready</code>
<a href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions target=_blank>状况</a>设置为 <code>false</code>。</p></li><li><p><code>terminationGracePeriodSeconds</code>：为 kubelet 配置从为失败的容器触发终止操作到强制容器运行时停止该容器之前等待的宽限时长。 默认值是继承 Pod 级别的 <code>terminationGracePeriodSeconds</code> 值（如果不设置则为 30 秒），最小值为 1。 更多细节请参见
<a href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#probe-level-terminationgraceperiodseconds target=_blank>探针级别 <code>terminationGracePeriodSeconds</code></a>。</p></li></ul><p>如果就绪态探针的实现不正确，可能会导致容器中进程的数量不断上升。 如果不对其采取措施，很可能导致资源枯竭的状况。</p><h4 id=http-探测>HTTP 探测<a hidden class=anchor aria-hidden=true href=#http-探测>#</a></h4><p><a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.34/#httpgetaction-v1-core target=_blank>HTTP Probe</a> 允许针对 <code>httpGet</code> 配置额外的字段：</p><ul><li><code>host</code>：连接使用的主机名，默认是 Pod 的 IP。也可以在 HTTP 头中设置 &ldquo;Host&rdquo; 来代替。</li><li><code>scheme</code>：用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 &ldquo;HTTP&rdquo;。</li><li><code>path</code>：访问 HTTP 服务的路径。默认值为 &ldquo;/"。</li><li><code>httpHeaders</code>：请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li><li><code>port</code>：访问容器的端口号或者端口名。如果数字必须在 1～65535 之间。</li></ul><p>对于 HTTP 探测，kubelet 发送一个 HTTP 请求到指定的端口和路径来执行检测。 除非 <code>httpGet</code> 中的 <code>host</code> 字段设置了，否则 kubelet 默认是给 Pod 的 IP 地址发送探测。 如果 <code>scheme</code> 字段设置为了 <code>HTTPS</code>，kubelet 会跳过证书验证发送 HTTPS 请求。 大多数情况下，不需要设置 <code>host</code> 字段。 这里有个需要设置 <code>host</code> 字段的场景，假设容器监听 <code>127.0.0.1</code>，并且 Pod 的 <code>hostNetwork</code> 字段设置为了 <code>true</code>。那么 <code>httpGet</code> 中的 <code>host</code> 字段应该设置为 <code>127.0.0.1</code>。 可能更常见的情况是如果 Pod 依赖虚拟主机，你不应该设置 <code>host</code> 字段，而是应该在 <code>httpHeaders</code> 中设置 <code>Host</code>。</p><p>针对 HTTP 探针，kubelet 除了必需的 <code>Host</code> 头部之外还发送两个请求头部字段：</p><ul><li><code>User-Agent</code>：默认值是 <code>kube-probe/1.34</code>，其中 <code>1.34</code> 是 kubelet 的版本号。</li><li><code>Accept</code>：默认值 <code>*/*</code>。</li></ul><p>你可以通过为探测设置 <code>httpHeaders</code> 来重载默认的头部字段值。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>httpHeaders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Accept</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>application/json</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>startupProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>httpHeaders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>User-Agent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>MyUserAgent</span><span class=w>
</span></span></span></code></pre></div><p>你也可以通过将这些头部字段定义为空值，从请求中去掉这些头部字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>httpHeaders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>Accept</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>startupProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>httpHeaders</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>User-Agent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;&#34;</span><span class=w>
</span></span></span></code></pre></div><p>当 kubelet 使用 HTTP 探测 Pod 时，仅当重定向到同一主机时，它才会遵循重定向。 如果 kubelet 在探测期间收到 11 个或更多重定向，则认为探测成功并创建相关事件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Events:
</span></span><span class=line><span class=cl>  Type     Reason        Age                     From               Message
</span></span><span class=line><span class=cl>  ----     ------        ----                    ----               -------
</span></span><span class=line><span class=cl>  Normal   Scheduled     29m                     default-scheduler  Successfully assigned default/httpbin-7b8bc9cb85-bjzwn to daocloud
</span></span><span class=line><span class=cl>  Normal   Pulling       29m                     kubelet            Pulling image &#34;docker.io/kennethreitz/httpbin&#34;
</span></span><span class=line><span class=cl>  Normal   Pulled        24m                     kubelet            Successfully pulled image &#34;docker.io/kennethreitz/httpbin&#34; in 5m12.402735213s
</span></span><span class=line><span class=cl>  Normal   Created       24m                     kubelet            Created container httpbin
</span></span><span class=line><span class=cl>  Normal   Started       24m                     kubelet            Started container httpbin
</span></span><span class=line><span class=cl> Warning  ProbeWarning  4m11s (x1197 over 24m)  kubelet            Readiness probe warning: Probe terminated redirects
</span></span></code></pre></div><p>如果 kubelet 收到主机名与请求不同的重定向，则探测结果将被视为成功，并且 kubelet 将创建一个事件来报告重定向失败。</p><blockquote><p>在处理 <strong>httpGet</strong> 探针时，kubelet 在读取了 10KiB 的响应体后会停止读取。 探针的成功与否仅由响应状态码决定，此状态码位于响应头中。</p><p>如果你探测一个返回的响应体大于 <strong>10KiB</strong> 的端点，kubelet 仍然会根据状态码将探针标记为成功， 但在达到 10KiB 限制后关闭连接。这种突然的关闭可能导致 <strong>connection reset by peer</strong> 或 <strong>broken pipe error</strong> 出现在你的应用程序日志中，这可能难以与合法的网络问题区分。</p><p>对于可靠的 <code>httpGet</code> 探针，强烈建议使用专用的健康检查端点， 这些端点返回最小的响应体。如果你必须使用具有大量数据负载的现有端点， 可以考虑使用 <code>exec</code> 探针来执行 HEAD 请求。</p></blockquote><h4 id=tcp-探测>TCP 探测<a hidden class=anchor aria-hidden=true href=#tcp-探测>#</a></h4><p>对于 TCP 探测而言，kubelet 在节点上（不是在 Pod 里面）发起探测连接， 这意味着你不能在 <code>host</code> 参数上配置服务名称，因为 kubelet 不能解析服务名称。</p><h4 id=探针层面的-terminationgraceperiodseconds>探针层面的 <code>terminationGracePeriodSeconds</code><a hidden class=anchor aria-hidden=true href=#探针层面的-terminationgraceperiodseconds>#</a></h4><p><strong>特性状态：</strong> <code>Kubernetes v1.28 [stable]</code></p><p>在 1.25 及以上版本中，用户可以指定一个探针层面的 <code>terminationGracePeriodSeconds</code> 作为探针规约的一部分。 当 Pod 层面和探针层面的 <code>terminationGracePeriodSeconds</code> 都已设置，kubelet 将使用探针层面设置的值。</p><p>当设置 <code>terminationGracePeriodSeconds</code> 时，请注意以下事项：</p><ul><li><p>kubelet 始终优先选用探针级别 <code>terminationGracePeriodSeconds</code> 字段 （如果它存在于 Pod 上）。</p></li><li><p>如果你已经为现有 Pod 设置了 <code>terminationGracePeriodSeconds</code> 字段并且不再希望使用针对每个探针的终止宽限期，则必须删除现有的这类 Pod。</p></li></ul><p>例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>terminationGracePeriodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>3600</span><span class=w>  </span><span class=c># Pod 级别设置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>test</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/healthz</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=l>liveness-port</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c># 重载 Pod 级别的 terminationGracePeriodSeconds</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>terminationGracePeriodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>60</span><span class=w>
</span></span></span></code></pre></div><p>探针层面的 <code>terminationGracePeriodSeconds</code> 不能用于就绪态探针。 这一设置将被 API 服务器拒绝。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://waite.wang/tags/k8s/>K8S</a></li></ul><nav class=paginav><a class=prev href=https://waite.wang/posts/tools/sentry-can-not-get-mail/><span class=title>« 上一页</span><br><span>Sentry 的安装部署以及邮件无法发送问题解决</span>
</a><a class=next href=https://waite.wang/posts/vue/pdf-preview-and-annotation/><span class=title>下一页 »</span><br><span>Vue PDF 预览与标注实现解析</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Waite0603/HugoBlog issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span><a href=https://beian.miit.gov.cn/ target=_blank rel="noopener noreferrer">粤ICP备2022028437号-1</a></span><br><span>Copyright &copy; 2018 - 2025 By <a href=https://waite.wang/>Waite</a>, All Rights
Reserved.</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=/js/jquery-3.5.1.min.js></script><link rel=stylesheet href=/css/jquery.fancybox.min.css><script src=/js/jquery.fancybox.min.js></script></body></html>